--- /dev/null
+++ b/deps/uv/android-configure-arm
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+export TOOLCHAIN=$PWD/android-toolchain-arm
+mkdir -p $TOOLCHAIN
+API=${3:-24}
+$1/build/tools/make-standalone-toolchain.sh \
+    --toolchain=arm-linux-androideabi-4.9 \
+    --arch=arm \
+    --install-dir=$TOOLCHAIN \
+    --platform=android-$API \
+    --force
+export PATH=$TOOLCHAIN/bin:$PATH
+export AR=arm-linux-androideabi-ar
+export CC=arm-linux-androideabi-gcc
+export CXX=arm-linux-androideabi-g++
+export LINK=arm-linux-androideabi-g++
+export PLATFORM=android
+export CFLAGS="-D__ANDROID_API__=$API"
+
+if [[ $2 == 'gyp' ]]
+  then
+    ./gyp_uv.py -Dtarget_arch=arm -DOS=android -f make-android
+fi
--- /dev/null
+++ b/deps/uv/android-configure-arm64
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+export TOOLCHAIN=$PWD/android-toolchain-arm64
+mkdir -p $TOOLCHAIN
+API=${3:-24}
+$1/build/tools/make-standalone-toolchain.sh \
+    --toolchain=aarch64-linux-android-4.9 \
+    --arch=arm64 \
+    --install-dir=$TOOLCHAIN \
+    --platform=android-$API \
+    --force
+export PATH=$TOOLCHAIN/bin:$PATH
+export AR=aarch64-linux-android-ar
+export CC=aarch64-linux-android-gcc
+export CXX=aarch64-linux-android-g++
+export LINK=aarch64-linux-android-g++
+export PLATFORM=android
+export CFLAGS="-D__ANDROID_API__=$API"
+
+if [[ $2 == 'gyp' ]]
+  then
+    ./gyp_uv.py -Dtarget_arch=arm64 -DOS=android -f make-android
+fi
--- /dev/null
+++ b/deps/uv/android-configure-x86
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+export TOOLCHAIN=$PWD/android-toolchain-x86
+mkdir -p $TOOLCHAIN
+API=${3:-24}
+$1/build/tools/make-standalone-toolchain.sh \
+    --toolchain=x86-4.9 \
+    --arch=x86 \
+    --install-dir=$TOOLCHAIN \
+    --platform=android-$API \
+    --force
+export PATH=$TOOLCHAIN/bin:$PATH
+export AR=i686-linux-android-ar
+export CC=i686-linux-android-gcc
+export CXX=i686-linux-android-g++
+export LINK=i686-linux-android-g++
+export PLATFORM=android
+export CFLAGS="-D__ANDROID_API__=$API"
+
+if [[ $2 == 'gyp' ]]
+  then
+    ./gyp_uv.py -Dtarget_arch=x86 -DOS=android -f make-android
+fi
--- /dev/null
+++ b/deps/uv/android-configure-x86_64
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+export TOOLCHAIN=$PWD/android-toolchain-x86_64
+mkdir -p $TOOLCHAIN
+API=${3:-24}
+$1/build/tools/make-standalone-toolchain.sh \
+    --toolchain=x86_64-4.9 \
+    --arch=x86_64 \
+    --install-dir=$TOOLCHAIN \
+    --platform=android-$API \
+    --force
+export PATH=$TOOLCHAIN/bin:$PATH
+export AR=x86_64-linux-android-ar
+export CC=x86_64-linux-android-gcc
+export CXX=x86_64-linux-android-g++
+export LINK=x86_64-linux-android-g++
+export PLATFORM=android
+export CFLAGS="-D__ANDROID_API__=$API -fPIC"
+export CXXFLAGS="-D__ANDROID_API__=$API -fPIC"
+export LDFLAGS="-fPIC"
+
+if [[ $2 == 'gyp' ]]
+  then
+    ./gyp_uv.py -Dtarget_arch=x86_64 -DOS=android -f make-android
+fi
--- /dev/null
+++ b/deps/uv/appveyor.yml
@@ -0,0 +1,32 @@
+version: v1.18.0.build{build}
+
+init:
+  - git config --global core.autocrlf true
+
+install:
+  - cinst -y nsis
+
+matrix:
+  fast_finish: true
+  allow_failures:
+    - platform: x86
+      configuration: Release
+    - platform: x64
+      configuration: Release
+
+platform:
+  - x86
+  - x64
+
+configuration:
+  - Release
+
+build_script:
+  # Fixed tag version number if using a tag.
+  - cmd: if "%APPVEYOR_REPO_TAG%" == "true" set APPVEYOR_BUILD_VERSION=%APPVEYOR_REPO_TAG_NAME%
+  # vcbuild overwrites the platform variable.
+  - cmd: set ARCH=%platform%
+  - cmd: vcbuild.bat release %ARCH% shared
+
+cache:
+  - C:\projects\libuv\build\gyp
--- a/deps/uv/AUTHORS
+++ b/deps/uv/AUTHORS
@@ -412,23 +412,3 @@ ZYSzys <zyszys98@gmail.com>
 Carl Lei <xecycle@gmail.com>
 Stefan Bender <stefan.bender@ntnu.no>
 nia <nia@NetBSD.org>
-virtualyw <virtualyw@gmail.com>
-Witold Kręcicki <wpk@isc.org>
-Dominique Dumont <dod@debian.org>
-Manuel BACHMANN <tarnyko@tarnyko.net>
-Marek Vavrusa <marek@vavrusa.com>
-TK-one <tk5641@naver.com>
-Irek Fakhrutdinov <ifakhrutdinov@rocketsoftware.com>
-Lin Zhang <linroid@gmail.com>
-毛毛 <srayuws@users.noreply.github.com>
-Sk Sajidul Kadir <sheikh.sajid522@gmail.com>
-twosee <twose@qq.com>
-Rikard Falkeborn <rikard.falkeborn@gmail.com>
-Yash Ladha <yashladhapankajladha123@gmail.com>
-James Ross <git@james-ross.co.uk>
-Colin Finck <colin@reactos.org>
-Shohei YOSHIDA <syohex@gmail.com>
-Philip Chimento <philip.chimento@gmail.com>
-Michal Artazov <michal@artazov.cz>
-Jeroen Roovers <jer@gentoo.org>
-MasterDuke17 <MasterDuke17@users.noreply.github.com>
--- a/deps/uv/ChangeLog
+++ b/deps/uv/ChangeLog
@@ -1,347 +1,3 @@
-2020.05.18, Version 1.38.0 (Stable), 1ab9ea3790378f9f25c4e78e9e2b511c75f9c9ed
-
-Changes since version 1.37.0:
-
-* test: skip poll_duplex and poll_unidirectional on PASE (Xu Meng)
-
-* linux: make cpu_times consistently be milliseconds (James Ross)
-
-* win: DRY uv_poll_start() and uv_poll_stop() (Ben Noordhuis)
-
-* win: DRY uv_poll_close() (Ben Noordhuis)
-
-* unix,win: add uv_library_shutdown() (Ben Noordhuis)
-
-* unix: yield cpu when spinlocking on async handle (Ben Noordhuis)
-
-* win: remove dep on GetQueuedCompletionStatusEx (Colin Finck)
-
-* doc: correct source lines (Shohei YOSHIDA)
-
-* build,android: fix typo (twosee)
-
-* doc: uv_cancel() handles uv_random_t requests (Philip Chimento)
-
-* doc: fix unescaped character (Philip Chimento)
-
-* build,cmake: fix compilation on old MinGW (erw7)
-
-* build: remove unnessesary MSVC warnings (Bartosz Sosnowski)
-
-* win: make uv_udp_init_ex() accept UV_UDP_RECVMMSG (Ben Noordhuis)
-
-* unix: simplify uv__udp_init_ex() (Ben Noordhuis)
-
-* win: remove MAX_PATH limitations (Bartosz Sosnowski)
-
-* build, win: add long path aware manifest (Bartosz Sosnowski)
-
-* doc: check/idle/prepare functions always succeed (Ben Noordhuis)
-
-* darwin: fix build with non-apple compilers (Ben Noordhuis)
-
-* win: support environment variables > 32767 chars (Ben Noordhuis)
-
-* unix: fully initialize struct msghdr (Ben Noordhuis)
-
-* doc: add uv_replace_allocator thread safety warning (twosee)
-
-* unix: fix int overflow when copying large files (Michal Artazov)
-
-* fs: report original error (Bartosz Sosnowski)
-
-* win, fs: add IO_REPARSE_TAG_APPEXECLINK support (Bartosz Sosnowski)
-
-* doc: fix formatting (Ben Noordhuis)
-
-* unix: fix memory leak when uv_loop_init() fails (Anna Henningsen)
-
-* unix: shrink uv_udp_set_source_membership() stack (Ben Noordhuis)
-
-* unix,win: fix wrong sizeof argument to memcpy() (Ben Noordhuis)
-
-* build: check for libraries not provided by libc (Jeroen Roovers)
-
-* doc: fix the order of arguments to calloc() (MasterDuke17)
-
-* unix: don't abort when getrlimit() fails (Ben Noordhuis)
-
-* test: support common user profile on IBMi (Xu Meng)
-
-* build: test on more platforms via QEMU in CI (gengjiawen)
-
-
-2020.04.20, Version 1.37.0 (Stable), 02a9e1be252b623ee032a3137c0b0c94afbe6809
-
-Changes since version 1.36.0:
-
-* timer: remove redundant check in heap compare (Yash Ladha)
-
-* udp: add flag to enable recvmmsg(2) explicitly (Saúl Ibarra Corretgé)
-
-
-2020.04.16, Version 1.36.0 (Stable), 533b738838ad8407032e14b6772b29ef9af63cfa
-
-Changes since version 1.35.0:
-
-* build: add aix-common.c for AIX cmake build (Jesse Gorzinski)
-
-* zos: explicitly mark message queue events (Irek Fakhrutdinov)
-
-* zos: move mq check out of loop to save cpu cycles (Irek Fakhrutdinov)
-
-* zos: add checks to ensure behavior of epoll_wait (Irek Fakhrutdinov)
-
-* src: add uv__reallocf() (Ben Noordhuis)
-
-* build: ibmi support for cmake (Jesse Gorzinski)
-
-* build: fix gyp build for Android API >= 28 (Lin Zhang)
-
-* udp: return recvmmsg-ed datagrams in order (Saúl Ibarra Corretgé)
-
-* zos,test: fix spawn_empty_env for shared library build (Richard Lau)
-
-* zos: fix non-Release builds (Richard Lau)
-
-* zos: fix return value on expired nanosleep() call (Richard Lau)
-
-* build: fix z/OS cmake build (Richard Lau)
-
-* test: add a bunch of ASSERT macros (Santiago Gimeno)
-
-* test: remove unused extern declaration (Ben Noordhuis)
-
-* test: canonicalize argv[0] in exepath test (Ben Noordhuis)
-
-* test: simplify platform_init() (Ben Noordhuis)
-
-* ibmi: Fix isatty EBADF handling and refactor (Kevin Adler)
-
-* test: Test EBADF tty handling (Kevin Adler)
-
-* build: make cmake build benchmarks (Ben Noordhuis)
-
-* win: use RtlGenRandom from advapi32.dll directly (Ben Noordhuis)
-
-* android: fix OOB write in uv_interface_addresses() (Lin Zhang)
-
-* test: pass test when hostname is single character (毛毛)
-
-* ibmi: set the highest process priority to -10 (Xu Meng)
-
-* build: remove support for gyp (Ben Noordhuis)
-
-* doc: add note to README on cross-compiling (Ben Noordhuis)
-
-* fs: add uv_fs_lutime() (Sk Sajidul Kadir)
-
-* unix: implement cpu_relax() for arm (David Carlier)
-
-* linux: fix uv__accept4() (twosee)
-
-* win: handle file paths in uv_fs_statfs() (erw7)
-
-* unix: fix uv_os_environ() null pointer check (Rikard Falkeborn)
-
-* win: fix uv_os_environ() null pointer check (Rikard Falkeborn)
-
-* unix: fix compilation on macOS 32-bit architectures (Brad King)
-
-* win: replace alloca() with stack-based array (Ben Noordhuis)
-
-
-2020.03.12, Version 1.35.0 (Stable), e45f1ec38db882f8dc17b51f51a6684027034609
-
-Changes since version 1.34.2:
-
-* src: android build fix (David Carlier)
-
-* build: make code compilable for iOS on Xcode (ssrlive)
-
-* ibmi: skip unsupported fs test cases (Xu Meng)
-
-* ibmi: ensure that pipe backlog is not zero (Xu Meng)
-
-* test,udp6: fix udp_ipv6 test flakiness (Jameson Nash)
-
-* test: fix fs_event_watch_dir_recursive flakiness (Santiago Gimeno)
-
-* pipe: disallow listening on an IPC pipe (Witold Kręcicki)
-
-* build,cmake: improve buil experience (Isabella Muerte)
-
-* unix: remove support for FreeBSD < 10 (Saúl Ibarra Corretgé)
-
-* linux: simplify uv__accept() (Ben Noordhuis)
-
-* linux: assume presence of SOCK_CLOEXEC flag (Ben Noordhuis)
-
-* linux: simplify uv__dup2_cloexec() (Ben Noordhuis)
-
-* freebsd,linux: simplify uv__make_socketpair() (Ben Noordhuis)
-
-* unix: fix error handling in uv__make_socketpair() (Ben Noordhuis)
-
-* freebsd,linux: simplify uv__make_pipe() (Ben Noordhuis)
-
-* unix: fix error handling in uv__make_pipe() (Ben Noordhuis)
-
-* linux: simplify uv__async_eventfd() (Ben Noordhuis)
-
-* linux: assume the presence of inotify system calls (Ben Noordhuis)
-
-* doc: strip ICC profile from 2 jpg files (Dominique Dumont)
-
-* unix: make uv_tcp_keepalive predictable (Manuel BACHMANN)
-
-* docs: uv_setup_args() may take ownership of argv (Ben Noordhuis)
-
-* unix: fix error path in uv_setup_args() (Ben Noordhuis)
-
-* unix: fix size check in uv_get_process_title() (Ben Noordhuis)
-
-* doc: add erw7 to maintainers (erw7)
-
-* test: fixed udp4_echo_server implementation (Marek Vavrusa)
-
-* test: added udp ping benchmark (1,10,100 pingers) (Marek Vavrusa)
-
-* freebsd,linux: add recvmmsg() + sendmmsg() udp implementation (Marek Vavrusa)
-
-* win,pipe: DRY/simplify some code paths (Jameson Nash)
-
-* win: address some style nits (Jameson Nash)
-
-* win,pipe: ensure `req->event_handle` is defined (Elliot Saba)
-
-* win,pipe: consolidate overlapped initialization (Elliot Saba)
-
-* win,pipe: erase event_handle after deleting pointer (Jameson Nash)
-
-* build: fix android cmake build, build missing file (Ben Noordhuis)
-
-* test: skip some UDP tests on IBMi (Xu Meng)
-
-* test: skip some spawn test cases on IBMi (Xu Meng)
-
-* src: fix wrong method name in comment (TK-one)
-
-* test: add UV_TIMEOUT_MULTIPLIER environment var (Ben Noordhuis)
-
-* unix: fix uv_cpu_info always returning UV_ENOTDIR on OpenBSD (Ben Davies)
-
-* test: skip the pwd_shell test on IBMi (Xu Meng)
-
-* win,tty: Change to restore cursor shape with uv_tty_reset() (erw7)
-
-* win,tty: Added set cursor style to CSI sequences (erw7)
-
-* test: handle EINTR, fix EOF check in poll test (Ben Noordhuis)
-
-* unix: use socklen_t instead of size_t (Ben Noordhuis)
-
-* doc: fix header file location (TK-one)
-
-* unix: fix signal handle closing deferral (Ben Noordhuis)
-
-* ibmi: set the amount of memory in use to zero (Xu Meng)
-
-* zos: return on realloc failure in scandir() (Milad Farazmand)
-
-* zos: fix scandir() error path NULL pointer deref (Ben Noordhuis)
-
-
-2020.01.24, Version 1.34.2 (Stable), f868c9ab0c307525a16fff99fd21e32a6ebc3837
-
-Changes since version 1.34.1:
-
-* misc: adjust stalebot deadlines (Jameson Nash)
-
-* test: fix env-vars flakiness (cjihrig)
-
-* test: avoid truncating output lines (Jameson Nash)
-
-* darwin: stop calling SetApplicationIsDaemon() (Ben Noordhuis)
-
-* ibmi: implement uv_interface_addresses() (Xu Meng)
-
-* osx,fsevent: fix race during uv_loop_close (Jameson Nash)
-
-* osx,fsevent: clear pointer when deleting it [NFCI] (Jameson Nash)
-
-* Revert "aix: replace ECONNRESET with EOF if already closed" (Jameson Nash)
-
-* unix: handle uv__open_cloexec return value correctly (Anna Henningsen)
-
-
-2020.01.13, Version 1.34.1 (Stable), 8aa5636ec72990bb2856f81e14c95813024a5c2b
-
-Changes since version 1.34.0:
-
-* unix: fix -Wstrict-aliasing compiler warning (Ben Noordhuis)
-
-* unix: cache address of dlsym("mkostemp") (Ben Noordhuis)
-
-* build: remove -pedantic from compiler flags (Ben Noordhuis)
-
-* Revert "darwin: assume pthread_setname_np() is available" (Ben Noordhuis)
-
-* Revert "darwin: speed up uv_set_process_title()" (Ben Noordhuis)
-
-* darwin: assume pthread_setname_np() is available (Ben Noordhuis)
-
-* ibmi: fix the false isatty() issue on IBMi (Xu Meng)
-
-* test: fix test failure under NetBSD and OpenBSD (David Carlier)
-
-* test: skip some test cases on IBMi (Xu Meng)
-
-* test: skip uv_(get|set)_process_title on IBMi (Xu Meng)
-
-* doc: remove binaries for Windows from README (Richard Lau)
-
-* unix: fix -Wunused-but-set-variable warning (George Zhao)
-
-* unix: pass sysctl size arg using ARRAY_SIZE macro (David Carlier)
-
-* test: disallow running the test suite as root (cjihrig)
-
-* unix: suppress -Waddress-of-packed-member warning (Ben Noordhuis)
-
-* misc: make more tags "not-stale" (Jameson Nash)
-
-* test: fix pthread memory leak (Trevor Norris)
-
-* docs: delete socks5-proxy sample (Jameson Nash)
-
-* ibmi: fix the CMSG length issue (Xu Meng)
-
-* docs: fix formatting (Jameson Nash)
-
-* unix: squelch fchmod() EPERM on CIFS share (Ben Noordhuis)
-
-* docs: fix linkcheck (Jameson Nash)
-
-* docs: switch from linux.die.net to man7.org (Jameson Nash)
-
-* win: remove abort when non-IFS LSP detection fails (virtualyw)
-
-* docs: clarify that uv_pipe_t is a pipe (Jameson Nash)
-
-* win,tty: avoid regressions in utf-8 handling (Jameson Nash)
-
-* win: remove bad assert in uv_loop_close (Jameson Nash)
-
-* test: fix -fno-common build errors (Ben Noordhuis)
-
-* build: turn on -fno-common to catch regressions (Ben Noordhuis)
-
-* test: fix fs birth time test failure (Ben Noordhuis)
-
-* tty,unix: avoid affecting controlling TTY (Jameson Nash)
-
-
 2019.12.05, Version 1.34.0 (Stable), 15ae750151ac9341e5945eb38f8982d59fb99201
 
 Changes since version 1.33.1:
--- a/deps/uv/CMakeLists.txt
+++ b/deps/uv/CMakeLists.txt
@@ -1,95 +1,23 @@
+# TODO: determine CMAKE_SYSTEM_NAME on OS/390.  Currently assumes "OS/390".
 cmake_minimum_required(VERSION 3.4)
 project(libuv LANGUAGES C)
 
-cmake_policy(SET CMP0057 NEW) # Enable IN_LIST operator
-cmake_policy(SET CMP0064 NEW) # Support if (TEST) operator
-
-list(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
-
 include(CMakePackageConfigHelpers)
 include(CMakeDependentOption)
-include(CheckCCompilerFlag)
 include(GNUInstallDirs)
 include(CTest)
 
-set(CMAKE_C_VISIBILITY_PRESET hidden)
-set(CMAKE_C_STANDARD_REQUIRED ON)
-set(CMAKE_C_EXTENSIONS ON)
-set(CMAKE_C_STANDARD 90)
-
 cmake_dependent_option(LIBUV_BUILD_TESTS
   "Build the unit tests when BUILD_TESTING is enabled and we are the root project" ON
   "BUILD_TESTING;CMAKE_SOURCE_DIR STREQUAL PROJECT_SOURCE_DIR" OFF)
-cmake_dependent_option(LIBUV_BUILD_BENCH
-  "Build the benchmarks when building unit tests and we are the root project" ON
-  "LIBUV_BUILD_TESTS" OFF)
-
-# Qemu Build
-option(QEMU "build for qemu" OFF)
-if(QEMU)
-  add_definitions(-D__QEMU__=1)
-endif()
-
-# Compiler check
-string(CONCAT is-msvc $<OR:
-  $<C_COMPILER_ID:MSVC>,
-  $<STREQUAL:${CMAKE_C_COMPILER_FRONTEND_VARIANT},MSVC>
->)
-
-check_c_compiler_flag(/W4 UV_LINT_W4)
-check_c_compiler_flag(/wd4100 UV_LINT_NO_UNUSED_PARAMETER_MSVC)
-check_c_compiler_flag(/wd4127 UV_LINT_NO_CONDITIONAL_CONSTANT_MSVC)
-check_c_compiler_flag(/wd4201 UV_LINT_NO_NONSTANDARD_MSVC)
-check_c_compiler_flag(/wd4206 UV_LINT_NO_NONSTANDARD_EMPTY_TU_MSVC)
-check_c_compiler_flag(/wd4210 UV_LINT_NO_NONSTANDARD_FILE_SCOPE_MSVC)
-check_c_compiler_flag(/wd4232 UV_LINT_NO_NONSTANDARD_NONSTATIC_DLIMPORT_MSVC)
-check_c_compiler_flag(/wd4456 UV_LINT_NO_HIDES_LOCAL)
-check_c_compiler_flag(/wd4457 UV_LINT_NO_HIDES_PARAM)
-check_c_compiler_flag(/wd4459 UV_LINT_NO_HIDES_GLOBAL)
-check_c_compiler_flag(/wd4706 UV_LINT_NO_CONDITIONAL_ASSIGNMENT_MSVC)
-check_c_compiler_flag(/wd4996 UV_LINT_NO_UNSAFE_MSVC)
-
-check_c_compiler_flag(-Wall UV_LINT_WALL) # DO NOT use this under MSVC
-
-# TODO: Place these into its own function
-check_c_compiler_flag(-Wno-unused-parameter UV_LINT_NO_UNUSED_PARAMETER)
-check_c_compiler_flag(-Wstrict-prototypes UV_LINT_STRICT_PROTOTYPES)
-check_c_compiler_flag(-Wextra UV_LINT_EXTRA)
-
-set(lint-no-unused-parameter $<$<BOOL:${UV_LINT_NO_UNUSED_PARAMETER}>:-Wno-unused-parameter>)
-set(lint-strict-prototypes $<$<BOOL:${UV_LINT_STRICT_PROTOTYPES}>:-Wstrict-prototypes>)
-set(lint-extra $<$<BOOL:${UV_LINT_EXTRA}>:-Wextra>)
-set(lint-w4 $<$<BOOL:${UV_LINT_W4}>:/W4>)
-set(lint-no-unused-parameter-msvc $<$<BOOL:${UV_LINT_NO_UNUSED_PARAMETER_MSVC}>:/wd4100>)
-set(lint-no-conditional-constant-msvc $<$<BOOL:${UV_LINT_NO_CONDITIONAL_CONSTANT_MSVC}>:/wd4127>)
-set(lint-no-nonstandard-msvc $<$<BOOL:${UV_LINT_NO_NONSTANDARD_MSVC}>:/wd4201>)
-set(lint-no-nonstandard-empty-tu-msvc $<$<BOOL:${UV_LINT_NO_NONSTANDARD_EMPTY_TU_MSVC}>:/wd4206>)
-set(lint-no-nonstandard-file-scope-msvc $<$<BOOL:${UV_LINT_NO_NONSTANDARD_FILE_SCOPE_MSVC}>:/wd4210>)
-set(lint-no-nonstandard-nonstatic-dlimport-msvc $<$<BOOL:${UV_LINT_NO_NONSTANDARD_NONSTATIC_DLIMPORT_MSVC}>:/wd4232>)
-set(lint-no-hides-local-msvc $<$<BOOL:${UV_LINT_NO_HIDES_LOCAL}>:/wd4456>)
-set(lint-no-hides-param-msvc $<$<BOOL:${UV_LINT_NO_HIDES_PARAM}>:/wd4457>)
-set(lint-no-hides-global-msvc $<$<BOOL:${UV_LINT_NO_HIDES_GLOBAL}>:/wd4459>)
-set(lint-no-conditional-assignment-msvc $<$<BOOL:${UV_LINT_NO_CONDITIONAL_ASSIGNMENT_MSVC}>:/wd4706>)
-set(lint-no-unsafe-msvc $<$<BOOL:${UV_LINT_NO_UNSAFE_MSVC}>:/wd4996>)
-# Unfortunately, this one is complicated because MSVC and clang-cl support -Wall
-# but using it is like calling -Weverything
-string(CONCAT lint-default $<
-  $<AND:$<BOOL:${UV_LINT_WALL}>,$<NOT:${is-msvc}>>:-Wall
->)
-
-list(APPEND uv_cflags ${lint-strict-prototypes} ${lint-extra} ${lint-default} ${lint-w4})
-list(APPEND uv_cflags ${lint-no-unused-parameter})
-list(APPEND uv_cflags ${lint-no-unused-parameter-msvc})
-list(APPEND uv_cflags ${lint-no-conditional-constant-msvc})
-list(APPEND uv_cflags ${lint-no-nonstandard-msvc})
-list(APPEND uv_cflags ${lint-no-nonstandard-empty-tu-msvc})
-list(APPEND uv_cflags ${lint-no-nonstandard-file-scope-msvc})
-list(APPEND uv_cflags ${lint-no-nonstandard-nonstatic-dlimport-msvc})
-list(APPEND uv_cflags ${lint-no-hides-local-msvc})
-list(APPEND uv_cflags ${lint-no-hides-param-msvc})
-list(APPEND uv_cflags ${lint-no-hides-global-msvc})
-list(APPEND uv_cflags ${lint-no-conditional-assignment-msvc})
-list(APPEND uv_cflags ${lint-no-unsafe-msvc})
+
+if(MSVC)
+  list(APPEND uv_cflags /W4)
+elseif(CMAKE_C_COMPILER_ID MATCHES "AppleClang|Clang|GNU")
+  list(APPEND uv_cflags -fvisibility=hidden --std=gnu89)
+  list(APPEND uv_cflags -Wall -Wextra -Wstrict-prototypes)
+  list(APPEND uv_cflags -Wno-unused-parameter)
+endif()
 
 set(uv_sources
     src/fs-poll.c
@@ -103,11 +31,172 @@ set(uv_sources
     src/uv-data-getter-setters.c
     src/version.c)
 
+set(uv_test_sources
+    test/blackhole-server.c
+    test/echo-server.c
+    test/run-tests.c
+    test/runner.c
+    test/test-active.c
+    test/test-async-null-cb.c
+    test/test-async.c
+    test/test-barrier.c
+    test/test-callback-order.c
+    test/test-callback-stack.c
+    test/test-close-fd.c
+    test/test-close-order.c
+    test/test-condvar.c
+    test/test-connect-unspecified.c
+    test/test-connection-fail.c
+    test/test-cwd-and-chdir.c
+    test/test-default-loop-close.c
+    test/test-delayed-accept.c
+    test/test-dlerror.c
+    test/test-eintr-handling.c
+    test/test-embed.c
+    test/test-emfile.c
+    test/test-env-vars.c
+    test/test-error.c
+    test/test-fail-always.c
+    test/test-fork.c
+    test/test-fs-copyfile.c
+    test/test-fs-event.c
+    test/test-fs-poll.c
+    test/test-fs.c
+    test/test-fs-readdir.c
+    test/test-fs-fd-hash.c
+    test/test-fs-open-flags.c
+    test/test-get-currentexe.c
+    test/test-get-loadavg.c
+    test/test-get-memory.c
+    test/test-get-passwd.c
+    test/test-getaddrinfo.c
+    test/test-gethostname.c
+    test/test-getnameinfo.c
+    test/test-getsockname.c
+    test/test-getters-setters.c
+    test/test-gettimeofday.c
+    test/test-handle-fileno.c
+    test/test-homedir.c
+    test/test-hrtime.c
+    test/test-idle.c
+    test/test-idna.c
+    test/test-ip4-addr.c
+    test/test-ip6-addr.c
+    test/test-ipc-heavy-traffic-deadlock-bug.c
+    test/test-ipc-send-recv.c
+    test/test-ipc.c
+    test/test-loop-alive.c
+    test/test-loop-close.c
+    test/test-loop-configure.c
+    test/test-loop-handles.c
+    test/test-loop-stop.c
+    test/test-loop-time.c
+    test/test-multiple-listen.c
+    test/test-mutexes.c
+    test/test-osx-select.c
+    test/test-pass-always.c
+    test/test-ping-pong.c
+    test/test-pipe-bind-error.c
+    test/test-pipe-close-stdout-read-stdin.c
+    test/test-pipe-connect-error.c
+    test/test-pipe-connect-multiple.c
+    test/test-pipe-connect-prepare.c
+    test/test-pipe-getsockname.c
+    test/test-pipe-pending-instances.c
+    test/test-pipe-sendmsg.c
+    test/test-pipe-server-close.c
+    test/test-pipe-set-fchmod.c
+    test/test-pipe-set-non-blocking.c
+    test/test-platform-output.c
+    test/test-poll-close-doesnt-corrupt-stack.c
+    test/test-poll-close.c
+    test/test-poll-closesocket.c
+    test/test-poll-oob.c
+    test/test-poll.c
+    test/test-process-priority.c
+    test/test-process-title-threadsafe.c
+    test/test-process-title.c
+    test/test-queue-foreach-delete.c
+    test/test-random.c
+    test/test-ref.c
+    test/test-run-nowait.c
+    test/test-run-once.c
+    test/test-semaphore.c
+    test/test-shutdown-close.c
+    test/test-shutdown-eof.c
+    test/test-shutdown-twice.c
+    test/test-signal-multiple-loops.c
+    test/test-signal-pending-on-close.c
+    test/test-signal.c
+    test/test-socket-buffer-size.c
+    test/test-spawn.c
+    test/test-stdio-over-pipes.c
+    test/test-strscpy.c
+    test/test-tcp-alloc-cb-fail.c
+    test/test-tcp-bind-error.c
+    test/test-tcp-bind6-error.c
+    test/test-tcp-close-accept.c
+    test/test-tcp-close-while-connecting.c
+    test/test-tcp-close.c
+    test/test-tcp-close-reset.c
+    test/test-tcp-connect-error-after-write.c
+    test/test-tcp-connect-error.c
+    test/test-tcp-connect-timeout.c
+    test/test-tcp-connect6-error.c
+    test/test-tcp-create-socket-early.c
+    test/test-tcp-flags.c
+    test/test-tcp-oob.c
+    test/test-tcp-open.c
+    test/test-tcp-read-stop.c
+    test/test-tcp-shutdown-after-write.c
+    test/test-tcp-try-write.c
+    test/test-tcp-try-write-error.c
+    test/test-tcp-unexpected-read.c
+    test/test-tcp-write-after-connect.c
+    test/test-tcp-write-fail.c
+    test/test-tcp-write-queue-order.c
+    test/test-tcp-write-to-half-open-connection.c
+    test/test-tcp-writealot.c
+    test/test-thread-equal.c
+    test/test-thread.c
+    test/test-threadpool-cancel.c
+    test/test-threadpool.c
+    test/test-timer-again.c
+    test/test-timer-from-check.c
+    test/test-timer.c
+    test/test-tmpdir.c
+    test/test-tty-duplicate-key.c
+    test/test-tty.c
+    test/test-udp-alloc-cb-fail.c
+    test/test-udp-bind.c
+    test/test-udp-connect.c
+    test/test-udp-create-socket-early.c
+    test/test-udp-dgram-too-big.c
+    test/test-udp-ipv6.c
+    test/test-udp-multicast-interface.c
+    test/test-udp-multicast-interface6.c
+    test/test-udp-multicast-join.c
+    test/test-udp-multicast-join6.c
+    test/test-udp-multicast-ttl.c
+    test/test-udp-open.c
+    test/test-udp-options.c
+    test/test-udp-send-and-recv.c
+    test/test-udp-send-hang-loop.c
+    test/test-udp-send-immediate.c
+    test/test-udp-send-unreachable.c
+    test/test-udp-try-send.c
+    test/test-uname.c
+    test/test-walk-handles.c
+    test/test-watcher-cross-stop.c)
+
 if(WIN32)
   list(APPEND uv_defines WIN32_LEAN_AND_MEAN _WIN32_WINNT=0x0600)
   list(APPEND uv_libraries
-       psapi
+       advapi32
        iphlpapi
+       psapi
+       shell32
+       user32
        userenv
        ws2_32)
   list(APPEND uv_sources
@@ -140,8 +229,7 @@ if(WIN32)
   list(APPEND uv_test_sources src/win/snprintf.c test/runner-win.c)
 else()
   list(APPEND uv_defines _FILE_OFFSET_BITS=64 _LARGEFILE_SOURCE)
-  if(NOT CMAKE_SYSTEM_NAME MATCHES "Android|OS390")
-    # TODO: This should be replaced with find_package(Threads) if possible
+  if(NOT CMAKE_SYSTEM_NAME STREQUAL "Android")
     # Android has pthread as part of its c library, not as a separate
     # libpthread.so.
     list(APPEND uv_libraries pthread)
@@ -173,16 +261,13 @@ if(CMAKE_SYSTEM_NAME STREQUAL "AIX")
        _ALL_SOURCE
        _LINUX_SOURCE_COMPAT
        _THREAD_SAFE
-       _XOPEN_SOURCE=500
-       HAVE_SYS_AHAFS_EVPRODS_H)
+       _XOPEN_SOURCE=500)
   list(APPEND uv_libraries perfstat)
-  list(APPEND uv_sources
-       src/unix/aix.c
-       src/unix/aix-common.c)
+  list(APPEND uv_sources src/unix/aix.c)
 endif()
 
 if(CMAKE_SYSTEM_NAME STREQUAL "Android")
-  list(APPEND uv_libraries dl)
+  list(APPEND uv_libs dl)
   list(APPEND uv_sources
        src/unix/android-ifaddrs.c
        src/unix/linux-core.c
@@ -190,13 +275,12 @@ if(CMAKE_SYSTEM_NAME STREQUAL "Android")
        src/unix/linux-syscalls.c
        src/unix/procfs-exepath.c
        src/unix/pthread-fixes.c
-       src/unix/random-getentropy.c
        src/unix/random-getrandom.c
        src/unix/random-sysctl-linux.c
        src/unix/sysinfo-loadavg.c)
 endif()
 
-if(APPLE OR CMAKE_SYSTEM_NAME MATCHES "Android|Linux|OS390")
+if(APPLE OR CMAKE_SYSTEM_NAME MATCHES "Android|Linux|OS/390")
   list(APPEND uv_sources src/unix/proctitle.c)
 endif()
 
@@ -250,11 +334,10 @@ if(CMAKE_SYSTEM_NAME STREQUAL "OpenBSD")
   list(APPEND uv_sources src/unix/openbsd.c)
 endif()
 
-if(CMAKE_SYSTEM_NAME STREQUAL "OS390")
+if(CMAKE_SYSTEM_NAME STREQUAL "OS/390")
   list(APPEND uv_defines PATH_MAX=255)
   list(APPEND uv_defines _AE_BIMODAL)
   list(APPEND uv_defines _ALL_SOURCE)
-  list(APPEND uv_defines _ISOC99_SOURCE)
   list(APPEND uv_defines _LARGE_TIME_API)
   list(APPEND uv_defines _OPEN_MSGQ_EXT)
   list(APPEND uv_defines _OPEN_SYS_FILE_EXT)
@@ -267,25 +350,9 @@ if(CMAKE_SYSTEM_NAME STREQUAL "OS390")
   list(APPEND uv_defines _XOPEN_SOURCE_EXTENDED)
   list(APPEND uv_sources
        src/unix/pthread-fixes.c
+       src/unix/pthread-barrier.c
        src/unix/os390.c
        src/unix/os390-syscalls.c)
-  list(APPEND uv_cflags -Wc,DLL -Wc,exportall -Wc,xplink)
-  list(APPEND uv_libraries -Wl,xplink)
-  list(APPEND uv_test_libraries -Wl,xplink)
-endif()
-
-if(CMAKE_SYSTEM_NAME STREQUAL "OS400")
-  list(APPEND uv_defines
-       _ALL_SOURCE
-       _LINUX_SOURCE_COMPAT
-       _THREAD_SAFE
-       _XOPEN_SOURCE=500)
-  list(APPEND uv_sources
-    src/unix/aix-common.c
-    src/unix/ibmi.c
-    src/unix/no-fsevents.c
-    src/unix/no-proctitle.c
-    src/unix/posix-poll.c)
 endif()
 
 if(CMAKE_SYSTEM_NAME STREQUAL "SunOS")
@@ -300,223 +367,20 @@ endif()
 
 add_library(uv SHARED ${uv_sources})
 target_compile_definitions(uv
-  INTERFACE
-    USING_UV_SHARED=1
-  PRIVATE
-    BUILDING_UV_SHARED=1
-    ${uv_defines})
+                           INTERFACE USING_UV_SHARED=1
+                           PRIVATE ${uv_defines} BUILDING_UV_SHARED=1)
 target_compile_options(uv PRIVATE ${uv_cflags})
-target_include_directories(uv
-  PUBLIC
-    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-  PRIVATE
-    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/src>)
+target_include_directories(uv PUBLIC include PRIVATE src)
 target_link_libraries(uv ${uv_libraries})
 
 add_library(uv_a STATIC ${uv_sources})
 target_compile_definitions(uv_a PRIVATE ${uv_defines})
 target_compile_options(uv_a PRIVATE ${uv_cflags})
-target_include_directories(uv_a
-  PUBLIC
-    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-  PRIVATE
-    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/src>)
+target_include_directories(uv_a PUBLIC include PRIVATE src)
 target_link_libraries(uv_a ${uv_libraries})
 
 if(LIBUV_BUILD_TESTS)
-  # Small hack: use ${uv_test_sources} now to get the runner skeleton,
-  # before the actual tests are added.
-  add_executable(
-    uv_run_benchmarks_a
-    ${uv_test_sources}
-    test/benchmark-async-pummel.c
-    test/benchmark-async.c
-    test/benchmark-fs-stat.c
-    test/benchmark-getaddrinfo.c
-    test/benchmark-loop-count.c
-    test/benchmark-million-async.c
-    test/benchmark-million-timers.c
-    test/benchmark-multi-accept.c
-    test/benchmark-ping-pongs.c
-    test/benchmark-ping-udp.c
-    test/benchmark-pound.c
-    test/benchmark-pump.c
-    test/benchmark-sizes.c
-    test/benchmark-spawn.c
-    test/benchmark-tcp-write-batch.c
-    test/benchmark-thread.c
-    test/benchmark-udp-pummel.c
-    test/blackhole-server.c
-    test/dns-server.c
-    test/echo-server.c
-    test/run-benchmarks.c
-    test/runner.c)
-  target_compile_definitions(uv_run_benchmarks_a PRIVATE ${uv_defines})
-  target_compile_options(uv_run_benchmarks_a PRIVATE ${uv_cflags})
-  target_link_libraries(uv_run_benchmarks_a uv_a ${uv_test_libraries})
-
-  list(APPEND uv_test_sources
-       test/blackhole-server.c
-       test/echo-server.c
-       test/run-tests.c
-       test/runner.c
-       test/test-active.c
-       test/test-async-null-cb.c
-       test/test-async.c
-       test/test-barrier.c
-       test/test-callback-order.c
-       test/test-callback-stack.c
-       test/test-close-fd.c
-       test/test-close-order.c
-       test/test-condvar.c
-       test/test-connect-unspecified.c
-       test/test-connection-fail.c
-       test/test-cwd-and-chdir.c
-       test/test-default-loop-close.c
-       test/test-delayed-accept.c
-       test/test-dlerror.c
-       test/test-eintr-handling.c
-       test/test-embed.c
-       test/test-emfile.c
-       test/test-env-vars.c
-       test/test-error.c
-       test/test-fail-always.c
-       test/test-fork.c
-       test/test-fs-copyfile.c
-       test/test-fs-event.c
-       test/test-fs-poll.c
-       test/test-fs.c
-       test/test-fs-readdir.c
-       test/test-fs-fd-hash.c
-       test/test-fs-open-flags.c
-       test/test-get-currentexe.c
-       test/test-get-loadavg.c
-       test/test-get-memory.c
-       test/test-get-passwd.c
-       test/test-getaddrinfo.c
-       test/test-gethostname.c
-       test/test-getnameinfo.c
-       test/test-getsockname.c
-       test/test-getters-setters.c
-       test/test-gettimeofday.c
-       test/test-handle-fileno.c
-       test/test-homedir.c
-       test/test-hrtime.c
-       test/test-idle.c
-       test/test-idna.c
-       test/test-ip4-addr.c
-       test/test-ip6-addr.c
-       test/test-ipc-heavy-traffic-deadlock-bug.c
-       test/test-ipc-send-recv.c
-       test/test-ipc.c
-       test/test-loop-alive.c
-       test/test-loop-close.c
-       test/test-loop-configure.c
-       test/test-loop-handles.c
-       test/test-loop-stop.c
-       test/test-loop-time.c
-       test/test-multiple-listen.c
-       test/test-mutexes.c
-       test/test-osx-select.c
-       test/test-pass-always.c
-       test/test-ping-pong.c
-       test/test-pipe-bind-error.c
-       test/test-pipe-close-stdout-read-stdin.c
-       test/test-pipe-connect-error.c
-       test/test-pipe-connect-multiple.c
-       test/test-pipe-connect-prepare.c
-       test/test-pipe-getsockname.c
-       test/test-pipe-pending-instances.c
-       test/test-pipe-sendmsg.c
-       test/test-pipe-server-close.c
-       test/test-pipe-set-fchmod.c
-       test/test-pipe-set-non-blocking.c
-       test/test-platform-output.c
-       test/test-poll-close-doesnt-corrupt-stack.c
-       test/test-poll-close.c
-       test/test-poll-closesocket.c
-       test/test-poll-oob.c
-       test/test-poll.c
-       test/test-process-priority.c
-       test/test-process-title-threadsafe.c
-       test/test-process-title.c
-       test/test-queue-foreach-delete.c
-       test/test-random.c
-       test/test-ref.c
-       test/test-run-nowait.c
-       test/test-run-once.c
-       test/test-semaphore.c
-       test/test-shutdown-close.c
-       test/test-shutdown-eof.c
-       test/test-shutdown-twice.c
-       test/test-signal-multiple-loops.c
-       test/test-signal-pending-on-close.c
-       test/test-signal.c
-       test/test-socket-buffer-size.c
-       test/test-spawn.c
-       test/test-stdio-over-pipes.c
-       test/test-strscpy.c
-       test/test-tcp-alloc-cb-fail.c
-       test/test-tcp-bind-error.c
-       test/test-tcp-bind6-error.c
-       test/test-tcp-close-accept.c
-       test/test-tcp-close-while-connecting.c
-       test/test-tcp-close.c
-       test/test-tcp-close-reset.c
-       test/test-tcp-connect-error-after-write.c
-       test/test-tcp-connect-error.c
-       test/test-tcp-connect-timeout.c
-       test/test-tcp-connect6-error.c
-       test/test-tcp-create-socket-early.c
-       test/test-tcp-flags.c
-       test/test-tcp-oob.c
-       test/test-tcp-open.c
-       test/test-tcp-read-stop.c
-       test/test-tcp-shutdown-after-write.c
-       test/test-tcp-try-write.c
-       test/test-tcp-try-write-error.c
-       test/test-tcp-unexpected-read.c
-       test/test-tcp-write-after-connect.c
-       test/test-tcp-write-fail.c
-       test/test-tcp-write-queue-order.c
-       test/test-tcp-write-to-half-open-connection.c
-       test/test-tcp-writealot.c
-       test/test-thread-equal.c
-       test/test-thread.c
-       test/test-threadpool-cancel.c
-       test/test-threadpool.c
-       test/test-timer-again.c
-       test/test-timer-from-check.c
-       test/test-timer.c
-       test/test-tmpdir.c
-       test/test-tty-duplicate-key.c
-       test/test-tty-escape-sequence-processing.c
-       test/test-tty.c
-       test/test-udp-alloc-cb-fail.c
-       test/test-udp-bind.c
-       test/test-udp-connect.c
-       test/test-udp-create-socket-early.c
-       test/test-udp-dgram-too-big.c
-       test/test-udp-ipv6.c
-       test/test-udp-multicast-interface.c
-       test/test-udp-multicast-interface6.c
-       test/test-udp-multicast-join.c
-       test/test-udp-multicast-join6.c
-       test/test-udp-multicast-ttl.c
-       test/test-udp-open.c
-       test/test-udp-options.c
-       test/test-udp-send-and-recv.c
-       test/test-udp-send-hang-loop.c
-       test/test-udp-send-immediate.c
-       test/test-udp-send-unreachable.c
-       test/test-udp-try-send.c
-       test/test-uname.c
-       test/test-walk-handles.c
-       test/test-watcher-cross-stop.c)
-
-  add_executable(uv_run_tests ${uv_test_sources} uv_win_longpath.manifest)
+  add_executable(uv_run_tests ${uv_test_sources})
   target_compile_definitions(uv_run_tests
                              PRIVATE ${uv_defines} USING_UV_SHARED=1)
   target_compile_options(uv_run_tests PRIVATE ${uv_cflags})
@@ -524,18 +388,10 @@ if(LIBUV_BUILD_TESTS)
   add_test(NAME uv_test
            COMMAND uv_run_tests
            WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
-  if(CMAKE_SYSTEM_NAME STREQUAL "OS390")
-    set_tests_properties(uv_test PROPERTIES ENVIRONMENT
-                         "LIBPATH=${CMAKE_BINARY_DIR}:$ENV{LIBPATH}")
-  endif()
-  add_executable(uv_run_tests_a ${uv_test_sources} uv_win_longpath.manifest)
+  add_executable(uv_run_tests_a ${uv_test_sources})
   target_compile_definitions(uv_run_tests_a PRIVATE ${uv_defines})
   target_compile_options(uv_run_tests_a PRIVATE ${uv_cflags})
-  if(QEMU)
-    target_link_libraries(uv_run_tests_a uv_a ${uv_test_libraries} -static)
-  else()
-    target_link_libraries(uv_run_tests_a uv_a ${uv_test_libraries})
-  endif()
+  target_link_libraries(uv_run_tests_a uv_a ${uv_test_libraries})
   add_test(NAME uv_test_a
            COMMAND uv_run_tests_a
            WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
@@ -543,26 +399,23 @@ endif()
 
 if(UNIX)
   # Now for some gibbering horrors from beyond the stars...
-  foreach(lib IN LISTS uv_libraries)
-    list(APPEND LIBS "-l${lib}")
-  endforeach()
-  string(REPLACE ";" " " LIBS "${LIBS}")
-  # Consider setting project version via project() call?
+  foreach(x ${uv_libraries})
+    set(LIBS "${LIBS} -l${x}")
+  endforeach(x)
   file(STRINGS configure.ac configure_ac REGEX ^AC_INIT)
-  string(REGEX MATCH "([0-9]+)[.][0-9]+[.][0-9]+" PACKAGE_VERSION "${configure_ac}")
-  set(UV_VERSION_MAJOR "${CMAKE_MATCH_1}")
+  string(REGEX MATCH [0-9]+[.][0-9]+[.][0-9]+ PACKAGE_VERSION "${configure_ac}")
+  string(REGEX MATCH ^[0-9]+ UV_VERSION_MAJOR "${PACKAGE_VERSION}")
   # The version in the filename is mirroring the behaviour of autotools.
-  set_target_properties(uv PROPERTIES
-    VERSION ${UV_VERSION_MAJOR}.0.0
-    SOVERSION ${UV_VERSION_MAJOR})
+  set_target_properties(uv PROPERTIES VERSION ${UV_VERSION_MAJOR}.0.0
+				      SOVERSION ${UV_VERSION_MAJOR})
   set(includedir ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR})
   set(libdir ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR})
   set(prefix ${CMAKE_INSTALL_PREFIX})
-  configure_file(libuv.pc.in libuv.pc @ONLY)
+  configure_file(libuv.pc.in ${CMAKE_CURRENT_BINARY_DIR}/libuv.pc @ONLY)
 
   install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
   install(FILES LICENSE DESTINATION ${CMAKE_INSTALL_DOCDIR})
-  install(FILES ${PROJECT_BINARY_DIR}/libuv.pc
+  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libuv.pc
           DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
   install(TARGETS uv LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
   install(TARGETS uv_a ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
@@ -575,11 +428,3 @@ if(WIN32)
           RUNTIME DESTINATION lib/$<CONFIG>
           ARCHIVE DESTINATION lib/$<CONFIG>)
 endif()
-
-message(STATUS "summary of build options:
-    Install prefix:  ${CMAKE_INSTALL_PREFIX}
-    Target system:   ${CMAKE_SYSTEM_NAME}
-    Compiler:
-      C compiler:    ${CMAKE_C_COMPILER}
-      CFLAGS:        ${CMAKE_C_FLAGS_${_build_type}} ${CMAKE_C_FLAGS}
-")
--- a/deps/uv/common.gypi
+++ b/deps/uv/common.gypi
@@ -35,7 +35,7 @@
         },
         'conditions': [
           ['OS != "zos"', {
-            'cflags': [ '-O0', '-fno-common', '-fwrapv' ]
+            'cflags': [ '-O0', '-fwrapv' ]
           }],
           ['OS == "android"', {
             'cflags': [ '-fPIE' ],
@@ -80,10 +80,9 @@
         'conditions': [
           ['OS != "zos"', {
             'cflags': [
+              '-fomit-frame-pointer',
               '-fdata-sections',
               '-ffunction-sections',
-              '-fno-common',
-              '-fomit-frame-pointer',
             ],
           }],
         ]
--- a/deps/uv/configure.ac
+++ b/deps/uv/configure.ac
@@ -13,7 +13,7 @@
 # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 AC_PREREQ(2.57)
-AC_INIT([libuv], [1.38.0], [https://github.com/libuv/libuv/issues])
+AC_INIT([libuv], [1.34.0], [https://github.com/libuv/libuv/issues])
 AC_CONFIG_MACRO_DIR([m4])
 m4_include([m4/libuv-extra-automake-flags.m4])
 m4_include([m4/as_case.m4])
@@ -24,6 +24,9 @@ AC_ENABLE_SHARED
 AC_ENABLE_STATIC
 AC_PROG_CC
 AM_PROG_CC_C_O
+AS_IF([AS_CASE([$host_os],[openedition*],  [false], [true])], [
+  CC_CHECK_CFLAGS_APPEND([-pedantic])
+])
 CC_FLAG_VISIBILITY #[-fvisibility=hidden]
 CC_CHECK_CFLAGS_APPEND([-g])
 CC_CHECK_CFLAGS_APPEND([-std=gnu89])
@@ -38,17 +41,15 @@ m4_ifdef([AM_PROG_AR], [AM_PROG_AR])
 AC_PROG_LIBTOOL
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 LT_INIT
-AX_PTHREAD([
-    LIBS="$LIBS $PTHREAD_LIBS"
-    CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
-])
+# TODO(bnoordhuis) Check for -pthread vs. -pthreads
 AC_CHECK_LIB([dl], [dlopen])
-AC_SEARCH_LIBS([kstat_lookup], [kstat])
-AC_SEARCH_LIBS([gethostbyname], [nsl])
-AC_SEARCH_LIBS([perfstat_cpu], [perfstat])
-AC_SEARCH_LIBS([clock_gettime], [rt])
-AC_SEARCH_LIBS([sendfile], [sendfile])
-AC_SEARCH_LIBS([socket], [socket])
+AC_CHECK_LIB([kstat], [kstat_lookup])
+AC_CHECK_LIB([nsl], [gethostbyname])
+AC_CHECK_LIB([perfstat], [perfstat_cpu])
+AC_CHECK_LIB([pthread], [pthread_mutex_init])
+AC_CHECK_LIB([rt], [clock_gettime])
+AC_CHECK_LIB([sendfile], [sendfile])
+AC_CHECK_LIB([socket], [socket])
 AC_SYS_LARGEFILE
 AM_CONDITIONAL([AIX],      [AS_CASE([$host_os],[aix*],          [true], [false])])
 AM_CONDITIONAL([ANDROID],  [AS_CASE([$host_os],[linux-android*],[true], [false])])
--- a/deps/uv/CONTRIBUTING.md
+++ b/deps/uv/CONTRIBUTING.md
@@ -48,11 +48,11 @@ the [Google C/C++ style guide]. Some of
 additional guidelines, are enumerated below.
 
 * Code that is specific to unix-y platforms should be placed in `src/unix`, and
-  declarations go into `include/uv/unix.h`.
+  declarations go into `include/uv-unix.h`.
 
 * Source code that is Windows-specific goes into `src/win`, and related
   publicly exported types, functions and macro declarations should generally
-  be declared in `include/uv/win.h`.
+  be declared in `include/uv-win.h`.
 
 * Names should be descriptive and concise.
 
@@ -142,6 +142,7 @@ Bug fixes and features should come with
 If you add a new test file, it needs to be registered in three places:
 - `CMakeLists.txt`: add the file's name to the `uv_test_sources` list.
 - `Makefile.am`: add the file's name to the `test_run_tests_SOURCES` list.
+- `uv.gyp`: add the file's name to the `sources` list in the `run-tests` target.
 
 Look at other tests to see how they should be structured (license boilerplate,
 the way entry points are declared, etc.).
--- a/deps/uv/.gitignore
+++ b/deps/uv/.gitignore
@@ -37,6 +37,11 @@ vgcore.*
 Makefile
 Makefile.in
 
+# Generated by gyp for android
+*.target.mk
+/android-toolchain
+
+/out/
 /build/
 
 /test/.libs/
@@ -67,7 +72,6 @@ ipch
 
 # Clion / IntelliJ project files
 /.idea/
-cmake-build-debug/
 
 *.xcodeproj
 *.xcworkspace
--- /dev/null
+++ b/deps/uv/gyp_uv.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python
+
+import os
+import platform
+import sys
+
+try:
+  import multiprocessing.synchronize
+  gyp_parallel_support = True
+except ImportError:
+  gyp_parallel_support = False
+
+
+CC = os.environ.get('CC', 'cc')
+script_dir = os.path.dirname(__file__)
+uv_root = os.path.normpath(script_dir)
+output_dir = os.path.join(os.path.abspath(uv_root), 'out')
+
+sys.path.insert(0, os.path.join(uv_root, 'build', 'gyp', 'pylib'))
+try:
+  import gyp
+except ImportError:
+  print('You need to install gyp in build/gyp first. See the README.')
+  sys.exit(42)
+
+
+def host_arch():
+  machine = platform.machine()
+  if machine == 'i386': return 'ia32'
+  if machine == 'AMD64': return 'x64'
+  if machine == 'x86_64': return 'x64'
+  if machine.startswith('arm'): return 'arm'
+  if machine.startswith('mips'): return 'mips'
+  return machine  # Return as-is and hope for the best.
+
+
+def run_gyp(args):
+  rc = gyp.main(args)
+  if rc != 0:
+    print('Error running GYP')
+    sys.exit(rc)
+
+
+if __name__ == '__main__':
+  args = sys.argv[1:]
+  args.extend('-I common.gypi test/test.gyp'.split(' '))
+  args.append('--depth=' + uv_root)
+
+  # There's a bug with windows which doesn't allow this feature.
+  if sys.platform != 'win32':
+    if '-f' not in args:
+      args.extend('-f make'.split())
+    if 'eclipse' not in args and 'ninja' not in args:
+      args.extend(['-Goutput_dir=' + output_dir])
+      args.extend(['--generator-output', output_dir])
+
+  if not any(a.startswith('-Dhost_arch=') for a in args):
+    args.append('-Dhost_arch=%s' % host_arch())
+
+  if not any(a.startswith('-Dtarget_arch=') for a in args):
+    args.append('-Dtarget_arch=%s' % host_arch())
+
+  if not any(a.startswith('-Duv_library=') for a in args):
+    args.append('-Duv_library=static_library')
+
+  # Some platforms (OpenBSD for example) don't have multiprocessing.synchronize
+  # so gyp must be run with --no-parallel
+  if not gyp_parallel_support:
+    args.append('--no-parallel')
+
+  gyp_args = list(args)
+  print(gyp_args)
+  run_gyp(gyp_args)
--- a/deps/uv/include/uv/version.h
+++ b/deps/uv/include/uv/version.h
@@ -26,12 +26,12 @@
  * Versions with the same major number are ABI stable. API is allowed to
  * evolve between minor releases, but only in a backwards compatible way.
  * Make sure you update the -soname directives in configure.ac
- * whenever you bump UV_VERSION_MAJOR or UV_VERSION_MINOR (but
+ * and uv.gyp whenever you bump UV_VERSION_MAJOR or UV_VERSION_MINOR (but
  * not UV_VERSION_PATCH.)
  */
 
 #define UV_VERSION_MAJOR 1
-#define UV_VERSION_MINOR 38
+#define UV_VERSION_MINOR 34
 #define UV_VERSION_PATCH 0
 #define UV_VERSION_IS_RELEASE 1
 #define UV_VERSION_SUFFIX ""
--- a/deps/uv/include/uv/win.h
+++ b/deps/uv/include/uv/win.h
@@ -517,7 +517,7 @@ typedef struct {
       /* eol conversion state */                                              \
       unsigned char previous_eol;                                             \
       /* ansi parser state */                                                 \
-      unsigned short ansi_parser_state;                                       \
+      unsigned char ansi_parser_state;                                        \
       unsigned char ansi_csi_argc;                                            \
       unsigned short ansi_csi_argv[4];                                        \
       COORD saved_position;                                                   \
--- a/deps/uv/include/uv.h
+++ b/deps/uv/include/uv.h
@@ -265,8 +265,6 @@ typedef void* (*uv_realloc_func)(void* p
 typedef void* (*uv_calloc_func)(size_t count, size_t size);
 typedef void (*uv_free_func)(void* ptr);
 
-UV_EXTERN void uv_library_shutdown(void);
-
 UV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,
                                    uv_realloc_func realloc_func,
                                    uv_calloc_func calloc_func,
@@ -607,17 +605,7 @@ enum uv_udp_flags {
    * (provided they all set the flag) but only the last one to bind will receive
    * any traffic, in effect "stealing" the port from the previous listener.
    */
-  UV_UDP_REUSEADDR = 4,
-  /*
-   * Indicates that the message was received by recvmmsg, so the buffer provided
-   * must not be freed by the recv_cb callback.
-   */
-  UV_UDP_MMSG_CHUNK = 8,
-
-  /*
-   * Indicates that recvmmsg should be used, if available.
-   */
-  UV_UDP_RECVMMSG = 256
+  UV_UDP_REUSEADDR = 4
 };
 
 typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);
@@ -1071,11 +1059,11 @@ UV_EXTERN int uv_cancel(uv_req_t* req);
 
 
 struct uv_cpu_times_s {
-  uint64_t user; /* milliseconds */
-  uint64_t nice; /* milliseconds */
-  uint64_t sys; /* milliseconds */
-  uint64_t idle; /* milliseconds */
-  uint64_t irq; /* milliseconds */
+  uint64_t user;
+  uint64_t nice;
+  uint64_t sys;
+  uint64_t idle;
+  uint64_t irq;
 };
 
 struct uv_cpu_info_s {
@@ -1189,22 +1177,12 @@ UV_EXTERN void uv_os_free_passwd(uv_pass
 UV_EXTERN uv_pid_t uv_os_getpid(void);
 UV_EXTERN uv_pid_t uv_os_getppid(void);
 
-#if defined(__PASE__)
-/* On IBM i PASE, the highest process priority is -10 */
-# define UV_PRIORITY_LOW 39            // RUNPTY(99)
-# define UV_PRIORITY_BELOW_NORMAL 15   // RUNPTY(50)
-# define UV_PRIORITY_NORMAL 0          // RUNPTY(20)
-# define UV_PRIORITY_ABOVE_NORMAL -4   // RUNTY(12)
-# define UV_PRIORITY_HIGH -7           // RUNPTY(6)
-# define UV_PRIORITY_HIGHEST -10       // RUNPTY(1)
-#else
-# define UV_PRIORITY_LOW 19
-# define UV_PRIORITY_BELOW_NORMAL 10
-# define UV_PRIORITY_NORMAL 0
-# define UV_PRIORITY_ABOVE_NORMAL -7
-# define UV_PRIORITY_HIGH -14
-# define UV_PRIORITY_HIGHEST -20
-#endif
+#define UV_PRIORITY_LOW 19
+#define UV_PRIORITY_BELOW_NORMAL 10
+#define UV_PRIORITY_NORMAL 0
+#define UV_PRIORITY_ABOVE_NORMAL -7
+#define UV_PRIORITY_HIGH -14
+#define UV_PRIORITY_HIGHEST -20
 
 UV_EXTERN int uv_os_getpriority(uv_pid_t pid, int* priority);
 UV_EXTERN int uv_os_setpriority(uv_pid_t pid, int priority);
@@ -1281,8 +1259,7 @@ typedef enum {
   UV_FS_READDIR,
   UV_FS_CLOSEDIR,
   UV_FS_STATFS,
-  UV_FS_MKSTEMP,
-  UV_FS_LUTIME
+  UV_FS_MKSTEMP
 } uv_fs_type;
 
 struct uv_dir_s {
@@ -1307,7 +1284,6 @@ struct uv_fs_s {
 
 UV_EXTERN uv_fs_type uv_fs_get_type(const uv_fs_t*);
 UV_EXTERN ssize_t uv_fs_get_result(const uv_fs_t*);
-UV_EXTERN int uv_fs_get_system_error(const uv_fs_t*);
 UV_EXTERN void* uv_fs_get_ptr(const uv_fs_t*);
 UV_EXTERN const char* uv_fs_get_path(const uv_fs_t*);
 UV_EXTERN uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);
@@ -1456,12 +1432,6 @@ UV_EXTERN int uv_fs_futime(uv_loop_t* lo
                            double atime,
                            double mtime,
                            uv_fs_cb cb);
-UV_EXTERN int uv_fs_lutime(uv_loop_t* loop,
-                           uv_fs_t* req,
-                           const char* path,
-                           double atime,
-                           double mtime,
-                           uv_fs_cb cb);
 UV_EXTERN int uv_fs_lstat(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
--- a/deps/uv/.mailmap
+++ b/deps/uv/.mailmap
@@ -17,7 +17,6 @@ Imran Iqbal <imrani@ca.ibm.com> <imran@i
 Isaac Z. Schlueter <i@izs.me>
 Jason Williams <necmon@yahoo.com>
 Jesse Gorzinski <jgorzinski@gmail.com>
-Jesse Gorzinski <jgorzinski@gmail.com> <jgorzins@us.ibm.com>
 Justin Venus <justin.venus@gmail.com> <justin.venus@orbitz.com>
 Keno Fischer <kenof@stanford.edu> <kfischer+github@college.harvard.edu>
 Keno Fischer <kenof@stanford.edu> <kfischer@college.harvard.edu>
--- a/deps/uv/MAINTAINERS.md
+++ b/deps/uv/MAINTAINERS.md
@@ -17,8 +17,6 @@ libuv is currently managed by the follow
   - GPG key: 9DFE AA5F 481B BF77 2D90  03CE D592 4925 2F8E C41A (pubkey-iwuzhere)
 * **Jameson Nash** ([@vtjnash](https://github.com/vtjnash))
 * **John Barboza** ([@jbarz](https://github.com/jbarz))
-* **Kaoru Takanashi** ([@erw7](https://github.com/erw7))
-  - GPG Key: 5804 F999 8A92 2AFB A398  47A0 7183 5090 6134 887F (pubkey-erw7)
 * **Richard Lau** ([@richardlau](https://github.com/richardlau))
   - GPG key: C82F A3AE 1CBE DC6B E46B  9360 C43C EC45 C17A B93C (pubkey-richardlau)
 * **Santiago Gimeno** ([@santigimeno](https://github.com/santigimeno))
--- a/deps/uv/Makefile.am
+++ b/deps/uv/Makefile.am
@@ -123,9 +123,18 @@ EXTRA_DIST = test/fixtures/empty_file \
              include \
              docs \
              img \
+             samples \
+             android-configure-arm \
+             android-configure-arm64 \
+             android-configure-x86 \
+             android-configure-x86_64 \
              CONTRIBUTING.md \
              LICENSE \
-             README.md
+             README.md \
+             vcbuild.bat \
+             common.gypi \
+             gyp_uv.py \
+             uv.gyp
 
 
 
@@ -278,7 +287,6 @@ test_run_tests_SOURCES = test/blackhole-
                          test/test-timer.c \
                          test/test-tmpdir.c \
                          test/test-tty-duplicate-key.c \
-                         test/test-tty-escape-sequence-processing.c \
                          test/test-tty.c \
                          test/test-udp-alloc-cb-fail.c \
                          test/test-udp-bind.c \
@@ -338,8 +346,7 @@ test_run_tests_CFLAGS += -D__EXTENSIONS_
 endif
 
 if OS390
-test_run_tests_CFLAGS += -D_ISOC99_SOURCE \
-                         -D_UNIX03_THREADS \
+test_run_tests_CFLAGS += -D_UNIX03_THREADS \
                          -D_UNIX03_SOURCE \
                          -D_OPEN_SYS_IF_EXT=1 \
                          -D_OPEN_SYS_SOCK_IPV6 \
@@ -409,9 +416,8 @@ uvinclude_HEADERS += include/uv/darwin.h
 libuv_la_CFLAGS += -D_DARWIN_USE_64_BIT_INODE=1
 libuv_la_CFLAGS += -D_DARWIN_UNLIMITED_SELECT=1
 libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \
-                    src/unix/darwin-proctitle.c \
-                    src/unix/darwin-stub.h \
                     src/unix/darwin.c \
+                    src/unix/darwin-proctitle.c \
                     src/unix/fsevents.c \
                     src/unix/kqueue.c \
                     src/unix/proctitle.c \
--- a/deps/uv/README.md
+++ b/deps/uv/README.md
@@ -116,6 +116,9 @@ libuv can be downloaded either from the
 [GitHub repository](https://github.com/libuv/libuv)
 or from the [downloads site](http://dist.libuv.org/dist/).
 
+Starting with libuv 1.7.0, binaries for Windows are also provided. This is to
+be considered EXPERIMENTAL.
+
 Before verifying the git tags or signature files, importing the relevant keys
 is necessary. Key IDs are listed in the
 [MAINTAINERS](https://github.com/libuv/libuv/blob/master/MAINTAINERS.md)
@@ -152,14 +155,47 @@ $ gpg --verify libuv-1.7.0.tar.gz.sign
 
 ## Build Instructions
 
-For UNIX-like platforms, including macOS, there are two build methods:
-autotools or [CMake][].
+For GCC there are two build methods: via autotools or via [GYP][].
+GYP is a meta-build system which can generate MSVS, Makefile, and XCode
+backends. It is best used for integration into other projects.
+
+To build with autotools:
+
+```bash
+$ sh autogen.sh
+$ ./configure
+$ make
+$ make check
+$ make install
+```
+
+To build with [CMake](https://cmake.org/):
+
+```bash
+$ mkdir -p out/cmake ; cd out/cmake   # create build directory
+$ cmake ../.. -DBUILD_TESTING=ON      # generate project with test
+$ cmake --build .                     # build
+$ ctest -C Debug --output-on-failure  # run tests
+
+# Or manually run tests:
+$ ./out/cmake/uv_run_tests    # shared library build
+$ ./out/cmake/uv_run_tests_a  # static library build
+```
+
+To build with GYP, first run:
+
+```bash
+$ git clone https://chromium.googlesource.com/external/gyp build/gyp
+```
 
-For Windows, [CMake][] is the only supported build method and has the
-following prerequisites:
+### Windows
 
-<details>
+Prerequisites:
 
+* [Python 2.6 or 2.7][] as it is required
+  by [GYP][].
+  If python is not in your path, set the environment variable `PYTHON` to its
+  location. For example: `set PYTHON=C:\Python27\python.exe`
 * One of:
   * [Visual C++ Build Tools][]
   * [Visual Studio 2015 Update 3][], all editions
@@ -172,44 +208,67 @@ following prerequisites:
   [Git for Windows][] includes Git Bash
   and tools which can be included in the global `PATH`.
 
-</details>
+To build, launch a git shell (e.g. Cmd or PowerShell), run `vcbuild.bat`
+(to build with VS2017 you need to explicitly add a `vs2017` argument),
+which will checkout the GYP code into `build/gyp`, generate `uv.sln`
+as well as the necesery related project files, and start building.
 
-To build with autotools:
+```console
+> vcbuild
+```
 
-```bash
-$ sh autogen.sh
-$ ./configure
-$ make
-$ make check
-$ make install
+Or:
+
+```console
+> vcbuild vs2017
 ```
 
-To build with [CMake][]:
+To run the tests:
 
-```bash
-$ mkdir -p build
+```console
+> vcbuild test
+```
 
-$ (cd build && cmake .. -DBUILD_TESTING=ON) # generate project with tests
-$ cmake --build build                       # add `-j <n>` with cmake >= 3.12
+To see all the options that could passed to `vcbuild`:
 
-# Run tests:
-$ (cd build && ctest -C Debug --output-on-failure)
+```console
+> vcbuild help
+vcbuild.bat [debug/release] [test/bench] [clean] [noprojgen] [nobuild] [vs2017] [x86/x64] [static/shared]
+Examples:
+  vcbuild.bat              : builds debug build
+  vcbuild.bat test         : builds debug build and runs tests
+  vcbuild.bat release bench: builds release build and runs benchmarks
+```
 
-# Or manually run tests:
-$ build/uv_run_tests                        # shared library build
-$ build/uv_run_tests_a                      # static library build
+
+### Unix
+
+For Debug builds (recommended) run:
+
+```bash
+$ ./gyp_uv.py -f make
+$ make -C out
+```
+
+For Release builds run:
+
+```bash
+$ ./gyp_uv.py -f make
+$ BUILDTYPE=Release make -C out
 ```
 
-To cross-compile with [CMake][] (unsupported but generally works):
+Run `./gyp_uv.py -f make -Dtarget_arch=x32` to build [x32][] binaries.
+
+### OS X
+
+Run:
 
 ```bash
-$ cmake ../..                 \
-  -DCMAKE_SYSTEM_NAME=Windows \
-  -DCMAKE_SYSTEM_VERSION=6.1  \
-  -DCMAKE_C_COMPILER=i686-w64-mingw32-gcc
+$ ./gyp_uv.py -f xcode
+$ xcodebuild -ARCHS="x86_64" -project out/uv.xcodeproj -configuration Release -alltargets
 ```
 
-### Install with Homebrew
+Using Homebrew:
 
 ```bash
 $ brew install --HEAD libuv
@@ -221,48 +280,103 @@ Make sure that you specify the architect
 "ARCHS" flag. You can specify more than one by delimiting with a space
 (e.g. "x86_64 i386").
 
+### Android
+
+Run:
+
+For arm
+
+```bash
+$ source ./android-configure-arm NDK_PATH gyp [API_LEVEL]
+$ make -C out
+```
+
+or for arm64
+
+```bash
+$ source ./android-configure-arm64 NDK_PATH gyp [API_LEVEL]
+$ make -C out
+```
+
+or for x86
+
+```bash
+$ source ./android-configure-x86 NDK_PATH gyp [API_LEVEL]
+$ make -C out
+```
+
+or for x86_64
+
+```bash
+$ source ./android-configure-x86_64 NDK_PATH gyp [API_LEVEL]
+$ make -C out
+```
+
+The default API level is 24, but a different one can be selected as follows:
+
+```bash
+$ source ./android-configure-arm ~/android-ndk-r15b gyp 21
+$ make -C out
+```
+
+Note for UNIX users: compile your project with `-D_LARGEFILE_SOURCE` and
+`-D_FILE_OFFSET_BITS=64`. GYP builds take care of that automatically.
+
+### Using Ninja
+
+To use ninja for build on ninja supported platforms, run:
+
+```bash
+$ ./gyp_uv.py -f ninja
+$ ninja -C out/Debug     #for debug build OR
+$ ninja -C out/Release
+```
+
+
 ### Running tests
 
-Some tests are timing sensitive. Relaxing test timeouts may be necessary
-on slow or overloaded machines:
+#### Build
+
+Build (includes tests):
+
+```bash
+$ ./gyp_uv.py -f make
+$ make -C out
+```
+
+#### Run all tests
 
 ```bash
-$ env UV_TEST_TIMEOUT_MULTIPLIER=2 build/uv_run_tests # 10s instead of 5s
+$ ./out/Debug/run-tests
 ```
 
 #### Run one test
 
 The list of all tests is in `test/test-list.h`.
 
-This invocation will cause the test driver to fork and execute `TEST_NAME` in
-a child process:
+This invocation will cause the `run-tests` driver to fork and execute `TEST_NAME` in a child process:
 
 ```bash
-$ build/uv_run_tests_a TEST_NAME
+$ ./out/Debug/run-tests TEST_NAME
 ```
 
-This invocation will cause the test driver to execute the test in
-the same process:
+This invocation will cause the `run-tests` driver to execute the test within the `run-tests` process:
 
 ```bash
-$ build/uv_run_tests_a TEST_NAME TEST_NAME
+$ ./out/Debug/run-tests TEST_NAME TEST_NAME
 ```
 
 #### Debugging tools
 
-When running the test from within the test driver process
-(`build/uv_run_tests_a TEST_NAME TEST_NAME`), tools like gdb and valgrind
-work normally.
-
-When running the test from a child of the test driver process
-(`build/uv_run_tests_a TEST_NAME`), use these tools in a fork-aware manner.
+When running the test from within the `run-tests` process (`run-tests TEST_NAME TEST_NAME`), tools like gdb and valgrind work normally.
+When running the test from a child of the `run-tests` process (`run-tests TEST_NAME`), use these tools in a fork-aware manner.
 
 ##### Fork-aware gdb
 
 Use the [follow-fork-mode](https://sourceware.org/gdb/onlinedocs/gdb/Forks.html) setting:
 
 ```
-$ gdb --args build/uv_run_tests_a TEST_NAME
+$ gdb --args out/Debug/run-tests TEST_NAME
 
 (gdb) set follow-fork-mode child
 ...
@@ -273,14 +387,13 @@ $ gdb --args build/uv_run_tests_a TEST_N
 Use the `--trace-children=yes` parameter:
 
 ```bash
-$ valgrind --trace-children=yes -v --tool=memcheck --leak-check=full --track-origins=yes --leak-resolution=high --show-reachable=yes --log-file=memcheck-%p.log build/uv_run_tests_a TEST_NAME
+$ valgrind --trace-children=yes -v --tool=memcheck --leak-check=full --track-origins=yes --leak-resolution=high --show-reachable=yes --log-file=memcheck-%p.log out/Debug/run-tests TEST_NAME
 ```
 
 ### Running benchmarks
 
 See the section on running tests.
-The benchmark driver is `./uv_run_benchmarks_a` and the benchmarks are
-listed in `test/benchmark-list.h`.
+The benchmark driver is `out/Debug/run-benchmarks` and the benchmarks are listed in `test/benchmark-list.h`.
 
 ## Supported Platforms
 
@@ -296,6 +409,8 @@ that is detected by `autoconf`.
 [IBM documentation](http://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/)
 describes the package in more detail.
 
+AIX support for filesystem events is not compiled when building with `gyp`.
+
 ### z/OS Notes
 
 z/OS creates System V semaphores and message queues. These persist on the system
@@ -307,10 +422,12 @@ Use the `ipcrm` command to manually clea
 
 See the [guidelines for contributing][].
 
-[CMake]: https://cmake.org/
 [node.js]: http://nodejs.org/
+[GYP]: http://code.google.com/p/gyp/
 [guidelines for contributing]: https://github.com/libuv/libuv/blob/master/CONTRIBUTING.md
 [libuv_banner]: https://raw.githubusercontent.com/libuv/libuv/master/img/banner.png
+[x32]: https://en.wikipedia.org/wiki/X32_ABI
+[Python 2.6 or 2.7]: https://www.python.org/downloads/
 [Visual C++ Build Tools]: https://visualstudio.microsoft.com/visual-cpp-build-tools/
 [Visual Studio 2015 Update 3]: https://www.visualstudio.com/vs/older-downloads/
 [Visual Studio 2017]: https://www.visualstudio.com/downloads/
--- a/deps/uv/src/threadpool.c
+++ b/deps/uv/src/threadpool.c
@@ -160,8 +160,8 @@ static void post(QUEUE* q, enum uv__work
 }
 
 
-void uv__threadpool_cleanup(void) {
 #ifndef _WIN32
+UV_DESTRUCTOR(static void cleanup(void)) {
   unsigned int i;
 
   if (nthreads == 0)
@@ -181,8 +181,8 @@ void uv__threadpool_cleanup(void) {
 
   threads = NULL;
   nthreads = 0;
-#endif
 }
+#endif
 
 
 static void init_threads(void) {
--- a/deps/uv/src/timer.c
+++ b/deps/uv/src/timer.c
@@ -51,7 +51,12 @@ static int timer_less_than(const struct
   /* Compare start_id when both have the same timeout. start_id is
    * allocated with loop->timer_counter in uv_timer_start().
    */
-  return a->start_id < b->start_id;
+  if (a->start_id < b->start_id)
+    return 1;
+  if (b->start_id < a->start_id)
+    return 0;
+
+  return 0;
 }
 
 
@@ -82,7 +87,7 @@ int uv_timer_start(uv_timer_t* handle,
   handle->timer_cb = cb;
   handle->timeout = clamped_timeout;
   handle->repeat = repeat;
-  /* start_id is the second index to be compared in timer_less_than() */
+  /* start_id is the second index to be compared in uv__timer_cmp() */
   handle->start_id = handle->loop->timer_counter++;
 
   heap_insert(timer_heap(handle->loop),
--- a/deps/uv/src/unix/aix.c
+++ b/deps/uv/src/unix/aix.c
@@ -926,7 +926,7 @@ int uv_get_process_title(char* buffer, s
 }
 
 
-void uv__process_title_cleanup(void) {
+UV_DESTRUCTOR(static void free_args_mem(void)) {
   uv__free(args_mem);  /* Keep valgrind happy. */
   args_mem = NULL;
 }
@@ -1039,186 +1039,6 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
 }
 
 
-int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
-  uv_interface_address_t* address;
-  int sockfd, sock6fd, inet6, i, r, size = 1;
-  struct ifconf ifc;
-  struct ifreq *ifr, *p, flg;
-  struct in6_ifreq if6;
-  struct sockaddr_dl* sa_addr;
-
-  ifc.ifc_req = NULL;
-  sock6fd = -1;
-  r = 0;
-  *count = 0;
-  *addresses = NULL;
-
-  if (0 > (sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP))) {
-    r = UV__ERR(errno);
-    goto cleanup;
-  }
-
-  if (0 > (sock6fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_IP))) {
-    r = UV__ERR(errno);
-    goto cleanup;
-  }
-
-  if (ioctl(sockfd, SIOCGSIZIFCONF, &size) == -1) {
-    r = UV__ERR(errno);
-    goto cleanup;
-  }
-
-  ifc.ifc_req = (struct ifreq*)uv__malloc(size);
-  if (ifc.ifc_req == NULL) {
-    r = UV_ENOMEM;
-    goto cleanup;
-  }
-  ifc.ifc_len = size;
-  if (ioctl(sockfd, SIOCGIFCONF, &ifc) == -1) {
-    r = UV__ERR(errno);
-    goto cleanup;
-  }
-
-#define ADDR_SIZE(p) MAX((p).sa_len, sizeof(p))
-
-  /* Count all up and running ipv4/ipv6 addresses */
-  ifr = ifc.ifc_req;
-  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {
-    p = ifr;
-    ifr = (struct ifreq*)
-      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));
-
-    if (!(p->ifr_addr.sa_family == AF_INET6 ||
-          p->ifr_addr.sa_family == AF_INET))
-      continue;
-
-    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));
-    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {
-      r = UV__ERR(errno);
-      goto cleanup;
-    }
-
-    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))
-      continue;
-
-    (*count)++;
-  }
-
-  if (*count == 0)
-    goto cleanup;
-
-  /* Alloc the return interface structs */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
-  if (!(*addresses)) {
-    r = UV_ENOMEM;
-    goto cleanup;
-  }
-  address = *addresses;
-
-  ifr = ifc.ifc_req;
-  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {
-    p = ifr;
-    ifr = (struct ifreq*)
-      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));
-
-    if (!(p->ifr_addr.sa_family == AF_INET6 ||
-          p->ifr_addr.sa_family == AF_INET))
-      continue;
-
-    inet6 = (p->ifr_addr.sa_family == AF_INET6);
-
-    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));
-    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1)
-      goto syserror;
-
-    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))
-      continue;
-
-    /* All conditions above must match count loop */
-
-    address->name = uv__strdup(p->ifr_name);
-
-    if (inet6)
-      address->address.address6 = *((struct sockaddr_in6*) &p->ifr_addr);
-    else
-      address->address.address4 = *((struct sockaddr_in*) &p->ifr_addr);
-
-    if (inet6) {
-      memset(&if6, 0, sizeof(if6));
-      r = uv__strscpy(if6.ifr_name, p->ifr_name, sizeof(if6.ifr_name));
-      if (r == UV_E2BIG)
-        goto cleanup;
-      r = 0;
-      memcpy(&if6.ifr_Addr, &p->ifr_addr, sizeof(if6.ifr_Addr));
-      if (ioctl(sock6fd, SIOCGIFNETMASK6, &if6) == -1)
-        goto syserror;
-      address->netmask.netmask6 = *((struct sockaddr_in6*) &if6.ifr_Addr);
-      /* Explicitly set family as the ioctl call appears to return it as 0. */
-      address->netmask.netmask6.sin6_family = AF_INET6;
-    } else {
-      if (ioctl(sockfd, SIOCGIFNETMASK, p) == -1)
-        goto syserror;
-      address->netmask.netmask4 = *((struct sockaddr_in*) &p->ifr_addr);
-      /* Explicitly set family as the ioctl call appears to return it as 0. */
-      address->netmask.netmask4.sin_family = AF_INET;
-    }
-
-    address->is_internal = flg.ifr_flags & IFF_LOOPBACK ? 1 : 0;
-
-    address++;
-  }
-
-  /* Fill in physical addresses. */
-  ifr = ifc.ifc_req;
-  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {
-    p = ifr;
-    ifr = (struct ifreq*)
-      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));
-
-    if (p->ifr_addr.sa_family != AF_LINK)
-      continue;
-
-    address = *addresses;
-    for (i = 0; i < *count; i++) {
-      if (strcmp(address->name, p->ifr_name) == 0) {
-        sa_addr = (struct sockaddr_dl*) &p->ifr_addr;
-        memcpy(address->phys_addr, LLADDR(sa_addr), sizeof(address->phys_addr));
-      }
-      address++;
-    }
-  }
-
-#undef ADDR_SIZE
-  goto cleanup;
-
-syserror:
-  uv_free_interface_addresses(*addresses, *count);
-  *addresses = NULL;
-  *count = 0;
-  r = UV_ENOSYS;
-
-cleanup:
-  if (sockfd != -1)
-    uv__close(sockfd);
-  if (sock6fd != -1)
-    uv__close(sock6fd);
-  uv__free(ifc.ifc_req);
-  return r;
-}
-
-
-void uv_free_interface_addresses(uv_interface_address_t* addresses,
-  int count) {
-  int i;
-
-  for (i = 0; i < count; ++i) {
-    uv__free(addresses[i].name);
-  }
-
-  uv__free(addresses);
-}
-
-
 void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {
   struct pollfd* events;
   uintptr_t i;
--- a/deps/uv/src/unix/aix-common.c
+++ b/deps/uv/src/unix/aix-common.c
@@ -155,3 +155,183 @@ int uv_exepath(char* buffer, size_t* siz
     return UV_EINVAL;
   }
 }
+
+
+int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
+  uv_interface_address_t* address;
+  int sockfd, sock6fd, inet6, i, r, size = 1;
+  struct ifconf ifc;
+  struct ifreq *ifr, *p, flg;
+  struct in6_ifreq if6;
+  struct sockaddr_dl* sa_addr;
+
+  ifc.ifc_req = NULL;
+  sock6fd = -1;
+  r = 0;
+  *count = 0;
+  *addresses = NULL;
+
+  if (0 > (sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP))) {
+    r = UV__ERR(errno);
+    goto cleanup;
+  }
+
+  if (0 > (sock6fd = socket(AF_INET6, SOCK_DGRAM, IPPROTO_IP))) {
+    r = UV__ERR(errno);
+    goto cleanup;
+  }
+
+  if (ioctl(sockfd, SIOCGSIZIFCONF, &size) == -1) {
+    r = UV__ERR(errno);
+    goto cleanup;
+  }
+
+  ifc.ifc_req = (struct ifreq*)uv__malloc(size);
+  if (ifc.ifc_req == NULL) {
+    r = UV_ENOMEM;
+    goto cleanup;
+  }
+  ifc.ifc_len = size;
+  if (ioctl(sockfd, SIOCGIFCONF, &ifc) == -1) {
+    r = UV__ERR(errno);
+    goto cleanup;
+  }
+
+#define ADDR_SIZE(p) MAX((p).sa_len, sizeof(p))
+
+  /* Count all up and running ipv4/ipv6 addresses */
+  ifr = ifc.ifc_req;
+  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {
+    p = ifr;
+    ifr = (struct ifreq*)
+      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));
+
+    if (!(p->ifr_addr.sa_family == AF_INET6 ||
+          p->ifr_addr.sa_family == AF_INET))
+      continue;
+
+    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));
+    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {
+      r = UV__ERR(errno);
+      goto cleanup;
+    }
+
+    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))
+      continue;
+
+    (*count)++;
+  }
+
+  if (*count == 0)
+    goto cleanup;
+
+  /* Alloc the return interface structs */
+  *addresses = uv__calloc(*count, sizeof(**addresses));
+  if (!(*addresses)) {
+    r = UV_ENOMEM;
+    goto cleanup;
+  }
+  address = *addresses;
+
+  ifr = ifc.ifc_req;
+  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {
+    p = ifr;
+    ifr = (struct ifreq*)
+      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));
+
+    if (!(p->ifr_addr.sa_family == AF_INET6 ||
+          p->ifr_addr.sa_family == AF_INET))
+      continue;
+
+    inet6 = (p->ifr_addr.sa_family == AF_INET6);
+
+    memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));
+    if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1)
+      goto syserror;
+
+    if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))
+      continue;
+
+    /* All conditions above must match count loop */
+
+    address->name = uv__strdup(p->ifr_name);
+
+    if (inet6)
+      address->address.address6 = *((struct sockaddr_in6*) &p->ifr_addr);
+    else
+      address->address.address4 = *((struct sockaddr_in*) &p->ifr_addr);
+
+    if (inet6) {
+      memset(&if6, 0, sizeof(if6));
+      r = uv__strscpy(if6.ifr_name, p->ifr_name, sizeof(if6.ifr_name));
+      if (r == UV_E2BIG)
+        goto cleanup;
+      r = 0;
+      memcpy(&if6.ifr_Addr, &p->ifr_addr, sizeof(if6.ifr_Addr));
+      if (ioctl(sock6fd, SIOCGIFNETMASK6, &if6) == -1)
+        goto syserror;
+      address->netmask.netmask6 = *((struct sockaddr_in6*) &if6.ifr_Addr);
+      /* Explicitly set family as the ioctl call appears to return it as 0. */
+      address->netmask.netmask6.sin6_family = AF_INET6;
+    } else {
+      if (ioctl(sockfd, SIOCGIFNETMASK, p) == -1)
+        goto syserror;
+      address->netmask.netmask4 = *((struct sockaddr_in*) &p->ifr_addr);
+      /* Explicitly set family as the ioctl call appears to return it as 0. */
+      address->netmask.netmask4.sin_family = AF_INET;
+    }
+
+    address->is_internal = flg.ifr_flags & IFF_LOOPBACK ? 1 : 0;
+
+    address++;
+  }
+
+  /* Fill in physical addresses. */
+  ifr = ifc.ifc_req;
+  while ((char*)ifr < (char*)ifc.ifc_req + ifc.ifc_len) {
+    p = ifr;
+    ifr = (struct ifreq*)
+      ((char*)ifr + sizeof(ifr->ifr_name) + ADDR_SIZE(ifr->ifr_addr));
+
+    if (p->ifr_addr.sa_family != AF_LINK)
+      continue;
+
+    address = *addresses;
+    for (i = 0; i < *count; i++) {
+      if (strcmp(address->name, p->ifr_name) == 0) {
+        sa_addr = (struct sockaddr_dl*) &p->ifr_addr;
+        memcpy(address->phys_addr, LLADDR(sa_addr), sizeof(address->phys_addr));
+      }
+      address++;
+    }
+  }
+
+#undef ADDR_SIZE
+  goto cleanup;
+
+syserror:
+  uv_free_interface_addresses(*addresses, *count);
+  *addresses = NULL;
+  *count = 0;
+  r = UV_ENOSYS;
+
+cleanup:
+  if (sockfd != -1)
+    uv__close(sockfd);
+  if (sock6fd != -1)
+    uv__close(sock6fd);
+  uv__free(ifc.ifc_req);
+  return r;
+}
+
+
+void uv_free_interface_addresses(uv_interface_address_t* addresses,
+  int count) {
+  int i;
+
+  for (i = 0; i < count; ++i) {
+    uv__free(addresses[i].name);
+  }
+
+  uv__free(addresses);
+}
--- a/deps/uv/src/unix/android-ifaddrs.c
+++ b/deps/uv/src/unix/android-ifaddrs.c
@@ -470,14 +470,13 @@ static int interpretAddr(struct nlmsghdr
         {
             case IFA_ADDRESS:
             case IFA_LOCAL:
-                l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));
                 if((l_info->ifa_family == AF_INET || l_info->ifa_family == AF_INET6) && !l_addedNetmask)
                 {
                     /* Make room for netmask */
                     l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));
                     l_addedNetmask = 1;
                 }
-                break;
+		break;
             case IFA_BROADCAST:
                 l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));
                 break;
--- a/deps/uv/src/unix/async.c
+++ b/deps/uv/src/unix/async.c
@@ -32,14 +32,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <sched.h>  /* sched_yield() */
-
-#ifdef __linux__
-#include <sys/eventfd.h>
-#endif
 
 static void uv__async_send(uv_loop_t* loop);
 static int uv__async_start(uv_loop_t* loop);
+static int uv__async_eventfd(void);
 
 
 int uv_async_init(uv_loop_t* loop, uv_async_t* handle, uv_async_cb async_cb) {
@@ -82,32 +78,20 @@ int uv_async_send(uv_async_t* handle) {
 
 /* Only call this from the event loop thread. */
 static int uv__async_spin(uv_async_t* handle) {
-  int i;
   int rc;
 
   for (;;) {
-    /* 997 is not completely chosen at random. It's a prime number, acyclical
-     * by nature, and should therefore hopefully dampen sympathetic resonance.
+    /* rc=0 -- handle is not pending.
+     * rc=1 -- handle is pending, other thread is still working with it.
+     * rc=2 -- handle is pending, other thread is done.
      */
-    for (i = 0; i < 997; i++) {
-      /* rc=0 -- handle is not pending.
-       * rc=1 -- handle is pending, other thread is still working with it.
-       * rc=2 -- handle is pending, other thread is done.
-       */
-      rc = cmpxchgi(&handle->pending, 2, 0);
+    rc = cmpxchgi(&handle->pending, 2, 0);
 
-      if (rc != 1)
-        return rc;
+    if (rc != 1)
+      return rc;
 
-      /* Other thread is busy with this handle, spin until it's done. */
-      cpu_relax();
-    }
-
-    /* Yield the CPU. We may have preempted the other thread while it's
-     * inside the critical section and if it's running on the same CPU
-     * as us, we'll just burn CPU cycles until the end of our time slice.
-     */
-    sched_yield();
+    /* Other thread is busy with this handle, spin until it's done. */
+    cpu_relax();
   }
 }
 
@@ -206,18 +190,36 @@ static int uv__async_start(uv_loop_t* lo
   if (loop->async_io_watcher.fd != -1)
     return 0;
 
-#ifdef __linux__
-  err = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-  if (err < 0)
-    return UV__ERR(errno);
+  err = uv__async_eventfd();
+  if (err >= 0) {
+    pipefd[0] = err;
+    pipefd[1] = -1;
+  }
+  else if (err == UV_ENOSYS) {
+    err = uv__make_pipe(pipefd, UV__F_NONBLOCK);
+#if defined(__linux__)
+    /* Save a file descriptor by opening one of the pipe descriptors as
+     * read/write through the procfs.  That file descriptor can then
+     * function as both ends of the pipe.
+     */
+    if (err == 0) {
+      char buf[32];
+      int fd;
+
+      snprintf(buf, sizeof(buf), "/proc/self/fd/%d", pipefd[0]);
+      fd = uv__open_cloexec(buf, O_RDWR);
+      if (fd >= 0) {
+        uv__close(pipefd[0]);
+        uv__close(pipefd[1]);
+        pipefd[0] = fd;
+        pipefd[1] = fd;
+      }
+    }
+#endif
+  }
 
-  pipefd[0] = err;
-  pipefd[1] = -1;
-#else
-  err = uv__make_pipe(pipefd, UV__F_NONBLOCK);
   if (err < 0)
     return err;
-#endif
 
   uv__io_init(&loop->async_io_watcher, uv__async_io, pipefd[0]);
   uv__io_start(loop, &loop->async_io_watcher, POLLIN);
@@ -251,3 +253,46 @@ void uv__async_stop(uv_loop_t* loop) {
   uv__close(loop->async_io_watcher.fd);
   loop->async_io_watcher.fd = -1;
 }
+
+
+static int uv__async_eventfd(void) {
+#if defined(__linux__)
+  static int no_eventfd2;
+  static int no_eventfd;
+  int fd;
+
+  if (no_eventfd2)
+    goto skip_eventfd2;
+
+  fd = uv__eventfd2(0, UV__EFD_CLOEXEC | UV__EFD_NONBLOCK);
+  if (fd != -1)
+    return fd;
+
+  if (errno != ENOSYS)
+    return UV__ERR(errno);
+
+  no_eventfd2 = 1;
+
+skip_eventfd2:
+
+  if (no_eventfd)
+    goto skip_eventfd;
+
+  fd = uv__eventfd(0);
+  if (fd != -1) {
+    uv__cloexec(fd, 1);
+    uv__nonblock(fd, 1);
+    return fd;
+  }
+
+  if (errno != ENOSYS)
+    return UV__ERR(errno);
+
+  no_eventfd = 1;
+
+skip_eventfd:
+
+#endif
+
+  return UV_ENOSYS;
+}
--- a/deps/uv/src/unix/atomic-ops.h
+++ b/deps/uv/src/unix/atomic-ops.h
@@ -53,8 +53,6 @@ UV_UNUSED(static int cmpxchgi(int* ptr,
 UV_UNUSED(static void cpu_relax(void)) {
 #if defined(__i386__) || defined(__x86_64__)
   __asm__ __volatile__ ("rep; nop");  /* a.k.a. PAUSE */
-#elif (defined(__arm__) && __ARM_ARCH >= 7) || defined(__aarch64__)
-  __asm__ volatile("yield");
 #endif
 }
 
--- a/deps/uv/src/unix/bsd-proctitle.c
+++ b/deps/uv/src/unix/bsd-proctitle.c
@@ -37,13 +37,6 @@ static void init_process_title_mutex_onc
 }
 
 
-void uv__process_title_cleanup(void) {
-  /* TODO(bnoordhuis) uv_mutex_destroy(&process_title_mutex)
-   * and reset process_title_mutex_once?
-   */
-}
-
-
 char** uv_setup_args(int argc, char** argv) {
   process_title = argc > 0 ? uv__strdup(argv[0]) : NULL;
   return argv;
--- a/deps/uv/src/unix/core.c
+++ b/deps/uv/src/unix/core.c
@@ -71,12 +71,20 @@ extern char** environ;
 # include <sys/sysctl.h>
 # include <sys/filio.h>
 # include <sys/wait.h>
-# if defined(__FreeBSD__)
+# if defined(__FreeBSD__) && __FreeBSD__ >= 10
 #  define uv__accept4 accept4
 # endif
 # if defined(__NetBSD__)
 #  define uv__accept4(a, b, c, d) paccept((a), (b), (c), NULL, (d))
 # endif
+# if (defined(__FreeBSD__) && __FreeBSD__ >= 10) || \
+      defined(__NetBSD__) || defined(__OpenBSD__)
+#  define UV__SOCK_NONBLOCK SOCK_NONBLOCK
+#  define UV__SOCK_CLOEXEC  SOCK_CLOEXEC
+# endif
+# if !defined(F_DUP2FD_CLOEXEC) && defined(_F_DUP2FD_CLOEXEC)
+#  define F_DUP2FD_CLOEXEC  _F_DUP2FD_CLOEXEC
+# endif
 #endif
 
 #if defined(__ANDROID_API__) && __ANDROID_API__ < 21
@@ -88,8 +96,7 @@ extern char** environ;
 #endif
 
 #if defined(__linux__)
-# include <sys/syscall.h>
-# define uv__accept4 accept4
+#include <sys/syscall.h>
 #endif
 
 static int uv__run_pending(uv_loop_t* loop);
@@ -172,7 +179,9 @@ void uv_close(uv_handle_t* handle, uv_cl
 
   case UV_SIGNAL:
     uv__signal_close((uv_signal_t*) handle);
-    break;
+    /* Signal handles may not be closed immediately. The signal code will
+     * itself close uv__make_close_pending whenever appropriate. */
+    return;
 
   default:
     assert(0);
@@ -237,8 +246,6 @@ int uv__getiovmax(void) {
 
 
 static void uv__finish_close(uv_handle_t* handle) {
-  uv_signal_t* sh;
-
   /* Note: while the handle is in the UV_HANDLE_CLOSING state now, it's still
    * possible for it to be active in the sense that uv__is_active() returns
    * true.
@@ -261,20 +268,7 @@ static void uv__finish_close(uv_handle_t
     case UV_FS_EVENT:
     case UV_FS_POLL:
     case UV_POLL:
-      break;
-
     case UV_SIGNAL:
-      /* If there are any caught signals "trapped" in the signal pipe,
-       * we can't call the close callback yet. Reinserting the handle
-       * into the closing queue makes the event loop spin but that's
-       * okay because we only need to deliver the pending events.
-       */
-      sh = (uv_signal_t*) handle;
-      if (sh->caught_signals > sh->dispatched_signals) {
-        handle->flags ^= UV_HANDLE_CLOSED;
-        uv__make_close_pending(handle);  /* Back into the queue. */
-        return;
-      }
       break;
 
     case UV_NAMED_PIPE:
@@ -478,32 +472,52 @@ int uv__accept(int sockfd) {
   int peerfd;
   int err;
 
-  (void) &err;
   assert(sockfd >= 0);
 
-  do
-#ifdef uv__accept4
-    peerfd = uv__accept4(sockfd, NULL, NULL, SOCK_NONBLOCK|SOCK_CLOEXEC);
-#else
-    peerfd = accept(sockfd, NULL, NULL);
-#endif
-  while (peerfd == -1 && errno == EINTR);
+  while (1) {
+#if defined(__linux__)                          || \
+    (defined(__FreeBSD__) && __FreeBSD__ >= 10) || \
+    defined(__NetBSD__)
+    static int no_accept4;
+
+    if (no_accept4)
+      goto skip;
+
+    peerfd = uv__accept4(sockfd,
+                         NULL,
+                         NULL,
+                         UV__SOCK_NONBLOCK|UV__SOCK_CLOEXEC);
+    if (peerfd != -1)
+      return peerfd;
 
-  if (peerfd == -1)
-    return UV__ERR(errno);
+    if (errno == EINTR)
+      continue;
 
-#ifndef uv__accept4
-  err = uv__cloexec(peerfd, 1);
-  if (err == 0)
-    err = uv__nonblock(peerfd, 1);
+    if (errno != ENOSYS)
+      return UV__ERR(errno);
 
-  if (err != 0) {
-    uv__close(peerfd);
-    return err;
-  }
+    no_accept4 = 1;
+skip:
 #endif
 
-  return peerfd;
+    peerfd = accept(sockfd, NULL, NULL);
+    if (peerfd == -1) {
+      if (errno == EINTR)
+        continue;
+      return UV__ERR(errno);
+    }
+
+    err = uv__cloexec(peerfd, 1);
+    if (err == 0)
+      err = uv__nonblock(peerfd, 1);
+
+    if (err) {
+      uv__close(peerfd);
+      return err;
+    }
+
+    return peerfd;
+  }
 }
 
 
@@ -519,7 +533,7 @@ int uv__close_nocancel(int fd) {
 #if defined(__APPLE__)
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wdollar-in-identifier-extension"
-#if defined(__LP64__) || TARGET_OS_IPHONE
+#if defined(__LP64__)
   extern int close$NOCANCEL(int);
   return close$NOCANCEL(fd);
 #else
@@ -835,8 +849,8 @@ static void maybe_resize(uv_loop_t* loop
   }
 
   nwatchers = next_power_of_two(len + 2) - 2;
-  watchers = uv__reallocf(loop->watchers,
-                          (nwatchers + 2) * sizeof(loop->watchers[0]));
+  watchers = uv__realloc(loop->watchers,
+                         (nwatchers + 2) * sizeof(loop->watchers[0]));
 
   if (watchers == NULL)
     abort();
@@ -1017,30 +1031,54 @@ int uv__open_cloexec(const char* path, i
 
 
 int uv__dup2_cloexec(int oldfd, int newfd) {
-#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__linux__)
   int r;
-
+#if (defined(__FreeBSD__) && __FreeBSD__ >= 10) || defined(__NetBSD__)
   r = dup3(oldfd, newfd, O_CLOEXEC);
   if (r == -1)
     return UV__ERR(errno);
-
   return r;
+#elif defined(__FreeBSD__) && defined(F_DUP2FD_CLOEXEC)
+  r = fcntl(oldfd, F_DUP2FD_CLOEXEC, newfd);
+  if (r != -1)
+    return r;
+  if (errno != EINVAL)
+    return UV__ERR(errno);
+  /* Fall through. */
+#elif defined(__linux__)
+  static int no_dup3;
+  if (!no_dup3) {
+    do
+      r = uv__dup3(oldfd, newfd, O_CLOEXEC);
+    while (r == -1 && errno == EBUSY);
+    if (r != -1)
+      return r;
+    if (errno != ENOSYS)
+      return UV__ERR(errno);
+    /* Fall through. */
+    no_dup3 = 1;
+  }
+#endif
+  {
+    int err;
+    do
+      r = dup2(oldfd, newfd);
+#if defined(__linux__)
+    while (r == -1 && errno == EBUSY);
 #else
-  int err;
-  int r;
+    while (0);  /* Never retry. */
+#endif
 
-  r = dup2(oldfd, newfd);  /* Never retry. */
-  if (r == -1)
-    return UV__ERR(errno);
+    if (r == -1)
+      return UV__ERR(errno);
 
-  err = uv__cloexec(newfd, 1);
-  if (err != 0) {
-    uv__close(newfd);
-    return err;
-  }
+    err = uv__cloexec(newfd, 1);
+    if (err) {
+      uv__close(newfd);
+      return err;
+    }
 
-  return r;
-#endif
+    return r;
+  }
 }
 
 
@@ -1258,7 +1296,7 @@ int uv_os_environ(uv_env_item_t** envite
 
   *envitems = uv__calloc(i, sizeof(**envitems));
 
-  if (*envitems == NULL)
+  if (envitems == NULL)
     return UV_ENOMEM;
 
   for (j = 0, cnt = 0; j < i; j++) {
--- a/deps/uv/src/unix/darwin.c
+++ b/deps/uv/src/unix/darwin.c
@@ -110,7 +110,7 @@ uint64_t uv_get_total_memory(void) {
   int which[] = {CTL_HW, HW_MEMSIZE};
   size_t size = sizeof(info);
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   return (uint64_t) info;
@@ -127,7 +127,7 @@ void uv_loadavg(double avg[3]) {
   size_t size = sizeof(info);
   int which[] = {CTL_VM, VM_LOADAVG};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0) < 0) return;
+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) return;
 
   avg[0] = (double) info.ldavg[0] / info.fscale;
   avg[1] = (double) info.ldavg[1] / info.fscale;
@@ -162,7 +162,7 @@ int uv_uptime(double* uptime) {
   size_t size = sizeof(info);
   static int which[] = {CTL_KERN, KERN_BOOTTIME};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   now = time(NULL);
--- a/deps/uv/src/unix/darwin-proctitle.c
+++ b/deps/uv/src/unix/darwin-proctitle.c
@@ -30,54 +30,56 @@
 #include <TargetConditionals.h>
 
 #if !TARGET_OS_IPHONE
-#include "darwin-stub.h"
+# include <CoreFoundation/CoreFoundation.h>
+# include <ApplicationServices/ApplicationServices.h>
 #endif
 
+#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)
+
 
-static int uv__pthread_setname_np(const char* name) {
-  char namebuf[64];  /* MAXTHREADNAMESIZE */
-  int err;
-
-  strncpy(namebuf, name, sizeof(namebuf) - 1);
-  namebuf[sizeof(namebuf) - 1] = '\0';
-
-  err = pthread_setname_np(namebuf);
-  if (err)
-    return UV__ERR(err);
+#if !TARGET_OS_IPHONE
+static CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,
+                                                 const char*,
+                                                 CFStringEncoding);
+static CFBundleRef (*pCFBundleGetBundleWithIdentifier)(CFStringRef);
+static void *(*pCFBundleGetDataPointerForName)(CFBundleRef, CFStringRef);
+static void *(*pCFBundleGetFunctionPointerForName)(CFBundleRef, CFStringRef);
+static CFTypeRef (*pLSGetCurrentApplicationASN)(void);
+static OSStatus (*pLSSetApplicationInformationItem)(int,
+                                                    CFTypeRef,
+                                                    CFStringRef,
+                                                    CFStringRef,
+                                                    CFDictionaryRef*);
+static void* application_services_handle;
+static void* core_foundation_handle;
+static CFBundleRef launch_services_bundle;
+static CFStringRef* display_name_key;
+static CFDictionaryRef (*pCFBundleGetInfoDictionary)(CFBundleRef);
+static CFBundleRef (*pCFBundleGetMainBundle)(void);
+static CFBundleRef hi_services_bundle;
+static CFDictionaryRef (*pLSApplicationCheckIn)(int, CFDictionaryRef);
+static void (*pLSSetApplicationLaunchServicesServerConnectionStatus)(uint64_t,
+                                                                     void*);
 
-  return 0;
+
+UV_DESTRUCTOR(static void uv__set_process_title_platform_fini(void)) {
+  if (core_foundation_handle != NULL) {
+    dlclose(core_foundation_handle);
+    core_foundation_handle = NULL;
+  }
+
+  if (application_services_handle != NULL) {
+    dlclose(application_services_handle);
+    application_services_handle = NULL;
+  }
 }
+#endif  /* !TARGET_OS_IPHONE */
 
 
-int uv__set_process_title(const char* title) {
-#if TARGET_OS_IPHONE
-  return uv__pthread_setname_np(title);
-#else
-  CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,
-                                            const char*,
-                                            CFStringEncoding);
-  CFBundleRef (*pCFBundleGetBundleWithIdentifier)(CFStringRef);
-  void *(*pCFBundleGetDataPointerForName)(CFBundleRef, CFStringRef);
-  void *(*pCFBundleGetFunctionPointerForName)(CFBundleRef, CFStringRef);
-  CFTypeRef (*pLSGetCurrentApplicationASN)(void);
-  OSStatus (*pLSSetApplicationInformationItem)(int,
-                                               CFTypeRef,
-                                               CFStringRef,
-                                               CFStringRef,
-                                               CFDictionaryRef*);
-  void* application_services_handle;
-  void* core_foundation_handle;
-  CFBundleRef launch_services_bundle;
-  CFStringRef* display_name_key;
-  CFDictionaryRef (*pCFBundleGetInfoDictionary)(CFBundleRef);
-  CFBundleRef (*pCFBundleGetMainBundle)(void);
-  CFDictionaryRef (*pLSApplicationCheckIn)(int, CFDictionaryRef);
-  void (*pLSSetApplicationLaunchServicesServerConnectionStatus)(uint64_t,
-                                                                void*);
-  CFTypeRef asn;
-  int err;
+void uv__set_process_title_platform_init(void) {
+#if !TARGET_OS_IPHONE
+  OSStatus (*pSetApplicationIsDaemon)(int);
 
-  err = UV_ENOENT;
   application_services_handle = dlopen("/System/Library/Frameworks/"
                                        "ApplicationServices.framework/"
                                        "Versions/A/ApplicationServices",
@@ -106,8 +108,6 @@ int uv__set_process_title(const char* ti
     goto out;
   }
 
-#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)
-
   launch_services_bundle =
       pCFBundleGetBundleWithIdentifier(S("com.apple.LaunchServices"));
 
@@ -138,55 +138,59 @@ int uv__set_process_title(const char* ti
                                      "CFBundleGetInfoDictionary");
   *(void **)(&pCFBundleGetMainBundle) = dlsym(core_foundation_handle,
                                  "CFBundleGetMainBundle");
+
   if (pCFBundleGetInfoDictionary == NULL || pCFBundleGetMainBundle == NULL)
     goto out;
 
-  *(void **)(&pLSApplicationCheckIn) = pCFBundleGetFunctionPointerForName(
-      launch_services_bundle,
-      S("_LSApplicationCheckIn"));
+  /* Black 10.9 magic, to remove (Not responding) mark in Activity Monitor */
+  hi_services_bundle =
+      pCFBundleGetBundleWithIdentifier(S("com.apple.HIServices"));
 
-  if (pLSApplicationCheckIn == NULL)
+  if (hi_services_bundle == NULL)
     goto out;
 
+  *(void **)(&pSetApplicationIsDaemon) = pCFBundleGetFunctionPointerForName(
+      hi_services_bundle,
+      S("SetApplicationIsDaemon"));
+  *(void **)(&pLSApplicationCheckIn) = pCFBundleGetFunctionPointerForName(
+      launch_services_bundle,
+      S("_LSApplicationCheckIn"));
   *(void **)(&pLSSetApplicationLaunchServicesServerConnectionStatus) =
       pCFBundleGetFunctionPointerForName(
           launch_services_bundle,
           S("_LSSetApplicationLaunchServicesServerConnectionStatus"));
 
-  if (pLSSetApplicationLaunchServicesServerConnectionStatus == NULL)
-    goto out;
-
-  pLSSetApplicationLaunchServicesServerConnectionStatus(0, NULL);
-
-  /* Check into process manager?! */
-  pLSApplicationCheckIn(-2,
-                        pCFBundleGetInfoDictionary(pCFBundleGetMainBundle()));
-
-  asn = pLSGetCurrentApplicationASN();
-
-  err = UV_EBUSY;
-  if (asn == NULL)
-    goto out;
-
-  err = UV_EINVAL;
-  if (pLSSetApplicationInformationItem(-2,  /* Magic value. */
-                                       asn,
-                                       *display_name_key,
-                                       S(title),
-                                       NULL) != noErr) {
+  if (pSetApplicationIsDaemon == NULL ||
+      pLSApplicationCheckIn == NULL ||
+      pLSSetApplicationLaunchServicesServerConnectionStatus == NULL) {
     goto out;
   }
 
-  uv__pthread_setname_np(title);  /* Don't care if it fails. */
-  err = 0;
+  /* Prevent crash when LaunchServices cannot be connected to. */
+  pSetApplicationIsDaemon(1);
+  return;
 
 out:
-  if (core_foundation_handle != NULL)
-    dlclose(core_foundation_handle);
+  uv__set_process_title_platform_fini();
+#endif  /* !TARGET_OS_IPHONE */
+}
 
-  if (application_services_handle != NULL)
-    dlclose(application_services_handle);
 
-  return err;
+void uv__set_process_title(const char* title) {
+  char namebuf[64 /* MAXTHREADNAMESIZE */];
+
+#if !TARGET_OS_IPHONE
+  if (core_foundation_handle != NULL) {
+    CFTypeRef asn;
+    pLSSetApplicationLaunchServicesServerConnectionStatus(0, NULL);
+    pLSApplicationCheckIn(/* Magic value */ -2,
+                          pCFBundleGetInfoDictionary(pCFBundleGetMainBundle()));
+    asn = pLSGetCurrentApplicationASN();
+    pLSSetApplicationInformationItem(/* Magic value */ -2, asn,
+                                     *display_name_key, S(title), NULL);
+  }
 #endif  /* !TARGET_OS_IPHONE */
+
+  uv__strscpy(namebuf, title, sizeof(namebuf));
+  pthread_setname_np(namebuf);
 }
--- a/deps/uv/src/unix/darwin-stub.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* Copyright libuv project contributors. All rights reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#ifndef UV_DARWIN_STUB_H_
-#define UV_DARWIN_STUB_H_
-
-#include <stdint.h>
-
-struct CFArrayCallBacks;
-struct CFRunLoopSourceContext;
-struct FSEventStreamContext;
-
-typedef double CFAbsoluteTime;
-typedef double CFTimeInterval;
-typedef int FSEventStreamEventFlags;
-typedef int OSStatus;
-typedef long CFIndex;
-typedef struct CFArrayCallBacks CFArrayCallBacks;
-typedef struct CFRunLoopSourceContext CFRunLoopSourceContext;
-typedef struct FSEventStreamContext FSEventStreamContext;
-typedef uint32_t FSEventStreamCreateFlags;
-typedef uint64_t FSEventStreamEventId;
-typedef unsigned CFStringEncoding;
-typedef void* CFAllocatorRef;
-typedef void* CFArrayRef;
-typedef void* CFBundleRef;
-typedef void* CFDictionaryRef;
-typedef void* CFRunLoopRef;
-typedef void* CFRunLoopSourceRef;
-typedef void* CFStringRef;
-typedef void* CFTypeRef;
-typedef void* FSEventStreamRef;
-
-typedef void (*FSEventStreamCallback)(const FSEventStreamRef,
-                                      void*,
-                                      size_t,
-                                      void*,
-                                      const FSEventStreamEventFlags*,
-                                      const FSEventStreamEventId*);
-
-struct CFRunLoopSourceContext {
-  CFIndex version;
-  void* info;
-  void* pad[7];
-  void (*perform)(void*);
-};
-
-struct FSEventStreamContext {
-  CFIndex version;
-  void* info;
-  void* pad[3];
-};
-
-static const CFStringEncoding kCFStringEncodingUTF8 = 0x8000100;
-static const OSStatus noErr = 0;
-
-static const FSEventStreamEventId kFSEventStreamEventIdSinceNow = -1;
-
-static const int kFSEventStreamCreateFlagNoDefer = 2;
-static const int kFSEventStreamCreateFlagFileEvents = 16;
-
-static const int kFSEventStreamEventFlagEventIdsWrapped = 8;
-static const int kFSEventStreamEventFlagHistoryDone = 16;
-static const int kFSEventStreamEventFlagItemChangeOwner = 0x4000;
-static const int kFSEventStreamEventFlagItemCreated = 0x100;
-static const int kFSEventStreamEventFlagItemFinderInfoMod = 0x2000;
-static const int kFSEventStreamEventFlagItemInodeMetaMod = 0x400;
-static const int kFSEventStreamEventFlagItemIsDir = 0x20000;
-static const int kFSEventStreamEventFlagItemModified = 0x1000;
-static const int kFSEventStreamEventFlagItemRemoved = 0x200;
-static const int kFSEventStreamEventFlagItemRenamed = 0x800;
-static const int kFSEventStreamEventFlagItemXattrMod = 0x8000;
-static const int kFSEventStreamEventFlagKernelDropped = 4;
-static const int kFSEventStreamEventFlagMount = 64;
-static const int kFSEventStreamEventFlagRootChanged = 32;
-static const int kFSEventStreamEventFlagUnmount = 128;
-static const int kFSEventStreamEventFlagUserDropped = 2;
-
-#endif  /* UV_DARWIN_STUB_H_ */
--- a/deps/uv/src/unix/freebsd.c
+++ b/deps/uv/src/unix/freebsd.c
@@ -95,7 +95,7 @@ int uv_exepath(char* buffer, size_t* siz
   mib[3] = -1;
 
   abspath_size = sizeof abspath;
-  if (sysctl(mib, ARRAY_SIZE(mib), abspath, &abspath_size, NULL, 0))
+  if (sysctl(mib, 4, abspath, &abspath_size, NULL, 0))
     return UV__ERR(errno);
 
   assert(abspath_size > 0);
@@ -130,7 +130,7 @@ uint64_t uv_get_total_memory(void) {
 
   size_t size = sizeof(info);
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   return (uint64_t) info;
@@ -147,7 +147,7 @@ void uv_loadavg(double avg[3]) {
   size_t size = sizeof(info);
   int which[] = {CTL_VM, VM_LOADAVG};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0) < 0) return;
+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) return;
 
   avg[0] = (double) info.ldavg[0] / info.fscale;
   avg[1] = (double) info.ldavg[1] / info.fscale;
@@ -168,7 +168,7 @@ int uv_resident_set_memory(size_t* rss)
 
   kinfo_size = sizeof(kinfo);
 
-  if (sysctl(mib, ARRAY_SIZE(mib), &kinfo, &kinfo_size, NULL, 0))
+  if (sysctl(mib, 4, &kinfo, &kinfo_size, NULL, 0))
     return UV__ERR(errno);
 
   page_size = getpagesize();
@@ -288,28 +288,3 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
   uv__free(cp_times);
   return 0;
 }
-
-
-int uv__sendmmsg(int fd,
-                 struct uv__mmsghdr* mmsg,
-                 unsigned int vlen,
-                 unsigned int flags) {
-#if __FreeBSD__ >= 11
-  return sendmmsg(fd, mmsg, vlen, flags);
-#else
-  return errno = ENOSYS, -1;
-#endif
-}
-
-
-int uv__recvmmsg(int fd,
-                 struct uv__mmsghdr* mmsg,
-                 unsigned int vlen,
-                 unsigned int flags,
-                 struct timespec* timeout) {
-#if __FreeBSD__ >= 11
-  return recvmmsg(fd, mmsg, vlen, flags, timeout);
-#else
-  return errno = ENOSYS, -1;
-#endif
-}
--- a/deps/uv/src/unix/fs.c
+++ b/deps/uv/src/unix/fs.c
@@ -205,20 +205,6 @@ static ssize_t uv__fs_fdatasync(uv_fs_t*
 }
 
 
-UV_UNUSED(static struct timespec uv__fs_to_timespec(double time)) {
-  struct timespec ts;
-  ts.tv_sec  = time;
-  ts.tv_nsec = (uint64_t)(time * 1000000) % 1000000 * 1000;
-  return ts;
-}
-
-UV_UNUSED(static struct timeval uv__fs_to_timeval(double time)) {
-  struct timeval tv;
-  tv.tv_sec  = time;
-  tv.tv_usec = (uint64_t)(time * 1000000) % 1000000;
-  return tv;
-}
-
 static ssize_t uv__fs_futime(uv_fs_t* req) {
 #if defined(__linux__)                                                        \
     || defined(_AIX71)                                                        \
@@ -227,8 +213,10 @@ static ssize_t uv__fs_futime(uv_fs_t* re
    * for the sake of consistency with other platforms.
    */
   struct timespec ts[2];
-  ts[0] = uv__fs_to_timespec(req->atime);
-  ts[1] = uv__fs_to_timespec(req->mtime);
+  ts[0].tv_sec  = req->atime;
+  ts[0].tv_nsec = (uint64_t)(req->atime * 1000000) % 1000000 * 1000;
+  ts[1].tv_sec  = req->mtime;
+  ts[1].tv_nsec = (uint64_t)(req->mtime * 1000000) % 1000000 * 1000;
 #if defined(__ANDROID_API__) && __ANDROID_API__ < 21
   return utimensat(req->file, NULL, ts, 0);
 #else
@@ -242,8 +230,10 @@ static ssize_t uv__fs_futime(uv_fs_t* re
     || defined(__OpenBSD__)                                                   \
     || defined(__sun)
   struct timeval tv[2];
-  tv[0] = uv__fs_to_timeval(req->atime);
-  tv[1] = uv__fs_to_timeval(req->mtime);
+  tv[0].tv_sec  = req->atime;
+  tv[0].tv_usec = (uint64_t)(req->atime * 1000000) % 1000000;
+  tv[1].tv_sec  = req->mtime;
+  tv[1].tv_usec = (uint64_t)(req->mtime * 1000000) % 1000000;
 # if defined(__sun)
   return futimesat(req->file, NULL, tv);
 # else
@@ -269,29 +259,10 @@ static ssize_t uv__fs_mkdtemp(uv_fs_t* r
 }
 
 
-static int (*uv__mkostemp)(char*, int);
-
-
-static void uv__mkostemp_initonce(void) {
-  /* z/os doesn't have RTLD_DEFAULT but that's okay
-   * because it doesn't have mkostemp(O_CLOEXEC) either.
-   */
-#ifdef RTLD_DEFAULT
-  uv__mkostemp = (int (*)(char*, int)) dlsym(RTLD_DEFAULT, "mkostemp");
-
-  /* We don't care about errors, but we do want to clean them up.
-   * If there has been no error, then dlerror() will just return
-   * NULL.
-   */
-  dlerror();
-#endif  /* RTLD_DEFAULT */
-}
-
-
 static int uv__fs_mkstemp(uv_fs_t* req) {
-  static uv_once_t once = UV_ONCE_INIT;
   int r;
 #ifdef O_CLOEXEC
+  int (*mkostemp_function)(char*, int);
   static int no_cloexec_support;
 #endif
   static const char pattern[] = "XXXXXX";
@@ -313,23 +284,30 @@ static int uv__fs_mkstemp(uv_fs_t* req)
     return -1;
   }
 
-  uv_once(&once, uv__mkostemp_initonce);
-
 #ifdef O_CLOEXEC
-  if (no_cloexec_support == 0 && uv__mkostemp != NULL) {
-    r = uv__mkostemp(path, O_CLOEXEC);
+  if (no_cloexec_support == 0) {
+    *(int**)(&mkostemp_function) = dlsym(RTLD_DEFAULT, "mkostemp");
 
-    if (r >= 0)
-      return r;
-
-    /* If mkostemp() returns EINVAL, it means the kernel doesn't
-       support O_CLOEXEC, so we just fallback to mkstemp() below. */
-    if (errno != EINVAL)
-      return r;
-
-    /* We set the static variable so that next calls don't even
-       try to use mkostemp. */
-    no_cloexec_support = 1;
+    /* We don't care about errors, but we do want to clean them up.
+       If there has been no error, then dlerror() will just return
+       NULL. */
+    dlerror();
+
+    if (mkostemp_function != NULL) {
+      r = mkostemp_function(path, O_CLOEXEC);
+
+      if (r >= 0)
+        return r;
+
+      /* If mkostemp() returns EINVAL, it means the kernel doesn't
+         support O_CLOEXEC, so we just fallback to mkstemp() below. */
+      if (errno != EINVAL)
+        return r;
+
+      /* We set the static variable so that next calls don't even
+         try to use mkostemp. */
+      no_cloexec_support = 1;
+    }
   }
 #endif  /* O_CLOEXEC */
 
@@ -676,6 +654,7 @@ static ssize_t uv__fs_readlink(uv_fs_t*
   ssize_t maxlen;
   ssize_t len;
   char* buf;
+  char* newbuf;
 
 #if defined(_POSIX_PATH_MAX) || defined(PATH_MAX)
   maxlen = uv__fs_pathmax_size(req->path);
@@ -719,10 +698,14 @@ static ssize_t uv__fs_readlink(uv_fs_t*
 
   /* Uncommon case: resize to make room for the trailing nul byte. */
   if (len == maxlen) {
-    buf = uv__reallocf(buf, len + 1);
+    newbuf = uv__realloc(buf, len + 1);
 
-    if (buf == NULL)
+    if (newbuf == NULL) {
+      uv__free(buf);
       return -1;
+    }
+
+    buf = newbuf;
   }
 
   buf[len] = '\0';
@@ -982,8 +965,10 @@ static ssize_t uv__fs_utime(uv_fs_t* req
    * for the sake of consistency with other platforms.
    */
   struct timespec ts[2];
-  ts[0] = uv__fs_to_timespec(req->atime);
-  ts[1] = uv__fs_to_timespec(req->mtime);
+  ts[0].tv_sec  = req->atime;
+  ts[0].tv_nsec = (uint64_t)(req->atime * 1000000) % 1000000 * 1000;
+  ts[1].tv_sec  = req->mtime;
+  ts[1].tv_nsec = (uint64_t)(req->mtime * 1000000) % 1000000 * 1000;
   return utimensat(AT_FDCWD, req->path, ts, 0);
 #elif defined(__APPLE__)                                                      \
     || defined(__DragonFly__)                                                 \
@@ -992,8 +977,10 @@ static ssize_t uv__fs_utime(uv_fs_t* req
     || defined(__NetBSD__)                                                    \
     || defined(__OpenBSD__)
   struct timeval tv[2];
-  tv[0] = uv__fs_to_timeval(req->atime);
-  tv[1] = uv__fs_to_timeval(req->mtime);
+  tv[0].tv_sec  = req->atime;
+  tv[0].tv_usec = (uint64_t)(req->atime * 1000000) % 1000000;
+  tv[1].tv_sec  = req->mtime;
+  tv[1].tv_usec = (uint64_t)(req->mtime * 1000000) % 1000000;
   return utimes(req->path, tv);
 #elif defined(_AIX)                                                           \
     && !defined(_AIX71)
@@ -1016,31 +1003,6 @@ static ssize_t uv__fs_utime(uv_fs_t* req
 }
 
 
-static ssize_t uv__fs_lutime(uv_fs_t* req) {
-#if defined(__linux__)            ||                                           \
-    defined(_AIX71)               ||                                           \
-    defined(__sun)                ||                                           \
-    defined(__HAIKU__)
-  struct timespec ts[2];
-  ts[0] = uv__fs_to_timespec(req->atime);
-  ts[1] = uv__fs_to_timespec(req->mtime);
-  return utimensat(AT_FDCWD, req->path, ts, AT_SYMLINK_NOFOLLOW);
-#elif defined(__APPLE__)          ||                                          \
-      defined(__DragonFly__)      ||                                          \
-      defined(__FreeBSD__)        ||                                          \
-      defined(__FreeBSD_kernel__) ||                                          \
-      defined(__NetBSD__)
-  struct timeval tv[2];
-  tv[0] = uv__fs_to_timeval(req->atime);
-  tv[1] = uv__fs_to_timeval(req->mtime);
-  return lutimes(req->path, tv);
-#else
-  errno = ENOSYS;
-  return -1;
-#endif
-}
-
-
 static ssize_t uv__fs_write(uv_fs_t* req) {
 #if defined(__linux__)
   static int no_pwritev;
@@ -1110,10 +1072,9 @@ static ssize_t uv__fs_copyfile(uv_fs_t*
   int dst_flags;
   int result;
   int err;
-  off_t bytes_to_send;
-  off_t in_offset;
-  off_t bytes_written;
-  size_t bytes_chunk;
+  size_t bytes_to_send;
+  int64_t in_offset;
+  ssize_t bytes_written;
 
   dstfd = -1;
   err = 0;
@@ -1164,28 +1125,7 @@ static ssize_t uv__fs_copyfile(uv_fs_t*
 
   if (fchmod(dstfd, src_statsbuf.st_mode) == -1) {
     err = UV__ERR(errno);
-#ifdef __linux__
-    if (err != UV_EPERM)
-      goto out;
-
-    {
-      struct statfs s;
-
-      /* fchmod() on CIFS shares always fails with EPERM unless the share is
-       * mounted with "noperm". As fchmod() is a meaningless operation on such
-       * shares anyway, detect that condition and squelch the error.
-       */
-      if (fstatfs(dstfd, &s) == -1)
-        goto out;
-
-      if (s.f_type != /* CIFS */ 0xFF534D42u)
-        goto out;
-    }
-
-    err = 0;
-#else  /* !__linux__ */
     goto out;
-#endif  /* !__linux__ */
   }
 
 #ifdef FICLONE
@@ -1212,10 +1152,7 @@ static ssize_t uv__fs_copyfile(uv_fs_t*
   bytes_to_send = src_statsbuf.st_size;
   in_offset = 0;
   while (bytes_to_send != 0) {
-    bytes_chunk = SSIZE_MAX;
-    if (bytes_to_send < (off_t) bytes_chunk)
-      bytes_chunk = bytes_to_send;
-    uv_fs_sendfile(NULL, &fs_req, dstfd, srcfd, in_offset, bytes_chunk, NULL);
+    uv_fs_sendfile(NULL, &fs_req, dstfd, srcfd, in_offset, bytes_to_send, NULL);
     bytes_written = fs_req.result;
     uv_fs_req_cleanup(&fs_req);
 
@@ -1558,7 +1495,6 @@ static void uv__fs_work(struct uv__work*
     X(FSYNC, uv__fs_fsync(req));
     X(FTRUNCATE, ftruncate(req->file, req->off));
     X(FUTIME, uv__fs_futime(req));
-    X(LUTIME, uv__fs_lutime(req));
     X(LSTAT, uv__fs_lstat(req->path, &req->statbuf));
     X(LINK, link(req->path, req->new_path));
     X(MKDIR, mkdir(req->path, req->mode));
@@ -1745,19 +1681,6 @@ int uv_fs_futime(uv_loop_t* loop,
   POST;
 }
 
-int uv_fs_lutime(uv_loop_t* loop,
-                 uv_fs_t* req,
-                 const char* path,
-                 double atime,
-                 double mtime,
-                 uv_fs_cb cb) {
-  INIT(LUTIME);
-  PATH;
-  req->atime = atime;
-  req->mtime = mtime;
-  POST;
-}
-
 
 int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
   INIT(LSTAT);
@@ -2086,7 +2009,3 @@ int uv_fs_statfs(uv_loop_t* loop,
   PATH;
   POST;
 }
-
-int uv_fs_get_system_error(const uv_fs_t* req) {
-  return -req->result;
-}
--- a/deps/uv/src/unix/fsevents.c
+++ b/deps/uv/src/unix/fsevents.c
@@ -41,33 +41,34 @@ void uv__fsevents_loop_delete(uv_loop_t*
 
 #else /* TARGET_OS_IPHONE */
 
-#include "darwin-stub.h"
-
 #include <dlfcn.h>
 #include <assert.h>
 #include <stdlib.h>
 #include <pthread.h>
 
-static const int kFSEventsModified =
-    kFSEventStreamEventFlagItemChangeOwner |
-    kFSEventStreamEventFlagItemFinderInfoMod |
-    kFSEventStreamEventFlagItemInodeMetaMod |
-    kFSEventStreamEventFlagItemModified |
-    kFSEventStreamEventFlagItemXattrMod;
-
-static const int kFSEventsRenamed =
-    kFSEventStreamEventFlagItemCreated |
-    kFSEventStreamEventFlagItemRemoved |
-    kFSEventStreamEventFlagItemRenamed;
-
-static const int kFSEventsSystem =
-    kFSEventStreamEventFlagUserDropped |
-    kFSEventStreamEventFlagKernelDropped |
-    kFSEventStreamEventFlagEventIdsWrapped |
-    kFSEventStreamEventFlagHistoryDone |
-    kFSEventStreamEventFlagMount |
-    kFSEventStreamEventFlagUnmount |
-    kFSEventStreamEventFlagRootChanged;
+#include <CoreFoundation/CFRunLoop.h>
+#include <CoreServices/CoreServices.h>
+
+/* These are macros to avoid "initializer element is not constant" errors
+ * with old versions of gcc.
+ */
+#define kFSEventsModified (kFSEventStreamEventFlagItemFinderInfoMod |         \
+                           kFSEventStreamEventFlagItemModified |              \
+                           kFSEventStreamEventFlagItemInodeMetaMod |          \
+                           kFSEventStreamEventFlagItemChangeOwner |           \
+                           kFSEventStreamEventFlagItemXattrMod)
+
+#define kFSEventsRenamed  (kFSEventStreamEventFlagItemCreated |               \
+                           kFSEventStreamEventFlagItemRemoved |               \
+                           kFSEventStreamEventFlagItemRenamed)
+
+#define kFSEventsSystem   (kFSEventStreamEventFlagUserDropped |               \
+                           kFSEventStreamEventFlagKernelDropped |             \
+                           kFSEventStreamEventFlagEventIdsWrapped |           \
+                           kFSEventStreamEventFlagHistoryDone |               \
+                           kFSEventStreamEventFlagMount |                     \
+                           kFSEventStreamEventFlagUnmount |                   \
+                           kFSEventStreamEventFlagRootChanged)
 
 typedef struct uv__fsevents_event_s uv__fsevents_event_t;
 typedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;
@@ -147,7 +148,7 @@ static void (*pFSEventStreamRelease)(FSE
 static void (*pFSEventStreamScheduleWithRunLoop)(FSEventStreamRef,
                                                  CFRunLoopRef,
                                                  CFStringRef);
-static int (*pFSEventStreamStart)(FSEventStreamRef);
+static Boolean (*pFSEventStreamStart)(FSEventStreamRef);
 static void (*pFSEventStreamStop)(FSEventStreamRef);
 
 #define UV__FSEVENTS_PROCESS(handle, block)                                   \
@@ -214,7 +215,7 @@ static void uv__fsevents_push_event(uv_f
 
 
 /* Runs in CF thread, when there're events in FSEventStream */
-static void uv__fsevents_event_cb(const FSEventStreamRef streamRef,
+static void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,
                                   void* info,
                                   size_t numEvents,
                                   void* eventPaths,
@@ -339,8 +340,11 @@ static int uv__fsevents_create_stream(uv
   FSEventStreamCreateFlags flags;
 
   /* Initialize context */
-  memset(&ctx, 0, sizeof(ctx));
+  ctx.version = 0;
   ctx.info = loop;
+  ctx.retain = NULL;
+  ctx.release = NULL;
+  ctx.copyDescription = NULL;
 
   latency = 0.05;
 
@@ -743,8 +747,6 @@ static void* uv__cf_loop_runner(void* ar
                          state->signal_source,
                          *pkCFRunLoopDefaultMode);
 
-  state->loop = NULL;
-
   return NULL;
 }
 
@@ -797,14 +799,13 @@ int uv__cf_loop_signal(uv_loop_t* loop,
 
   uv_mutex_lock(&loop->cf_mutex);
   QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);
+  uv_mutex_unlock(&loop->cf_mutex);
 
   state = loop->cf_state;
   assert(state != NULL);
   pCFRunLoopSourceSignal(state->signal_source);
   pCFRunLoopWakeUp(state->loop);
 
-  uv_mutex_unlock(&loop->cf_mutex);
-
   return 0;
 }
 
--- a/deps/uv/src/unix/ibmi.c
+++ b/deps/uv/src/unix/ibmi.c
@@ -56,7 +56,6 @@
 #include <sys/vnode.h>
 
 #include <as400_protos.h>
-#include <as400_types.h>
 
 
 typedef struct {
@@ -99,91 +98,24 @@ typedef struct {
 } SSTS0200;
 
 
-typedef struct {
-  char header[208];
-  unsigned char loca_adapter_address[12];
-} LIND0500;
-
-
-typedef struct {
-  int bytes_provided;
-  int bytes_available;
-  char msgid[7];
-} errcode_s;
-
-
-static const unsigned char e2a[256] = {
-    0, 1, 2, 3, 156, 9, 134, 127, 151, 141, 142, 11, 12, 13, 14, 15,
-    16, 17, 18, 19, 157, 133, 8, 135, 24, 25, 146, 143, 28, 29, 30, 31,
-    128, 129, 130, 131, 132, 10, 23, 27, 136, 137, 138, 139, 140, 5, 6, 7,
-    144, 145, 22, 147, 148, 149, 150, 4, 152, 153, 154, 155, 20, 21, 158, 26,
-    32, 160, 161, 162, 163, 164, 165, 166, 167, 168, 91, 46, 60, 40, 43, 33,
-    38, 169, 170, 171, 172, 173, 174, 175, 176, 177, 93, 36, 42, 41, 59, 94,
-    45, 47, 178, 179, 180, 181, 182, 183, 184, 185, 124, 44, 37, 95, 62, 63,
-    186, 187, 188, 189, 190, 191, 192, 193, 194, 96, 58, 35, 64, 39, 61, 34,
-    195, 97, 98, 99, 100, 101, 102, 103, 104, 105, 196, 197, 198, 199, 200, 201,
-    202, 106, 107, 108, 109, 110, 111, 112, 113, 114, 203, 204, 205, 206, 207, 208,
-    209, 126, 115, 116, 117, 118, 119, 120, 121, 122, 210, 211, 212, 213, 214, 215,
-    216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231,
-    123, 65, 66, 67, 68, 69, 70, 71, 72, 73, 232, 233, 234, 235, 236, 237,
-    125, 74, 75, 76, 77, 78, 79, 80, 81, 82, 238, 239, 240, 241, 242, 243,
-    92, 159, 83, 84, 85, 86, 87, 88, 89, 90, 244, 245, 246, 247, 248, 249,
-    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 250, 251, 252, 253, 254, 255};
-
-
-static const unsigned char a2e[256] = {
-    0, 1, 2, 3, 55, 45, 46, 47, 22, 5, 37, 11, 12, 13, 14, 15,
-    16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
-    64, 79, 127, 123, 91, 108, 80, 125, 77, 93, 92, 78, 107, 96, 75, 97,
-    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 94, 76, 126, 110, 111,
-    124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 209, 210, 211, 212, 213, 214,
-    215, 216, 217, 226, 227, 228, 229, 230, 231, 232, 233, 74, 224, 90, 95, 109,
-    121, 129, 130, 131, 132, 133, 134, 135, 136, 137, 145, 146, 147, 148, 149, 150,
-    151, 152, 153, 162, 163, 164, 165, 166, 167, 168, 169, 192, 106, 208, 161, 7,
-    32, 33, 34, 35, 36, 21, 6, 23, 40, 41, 42, 43, 44, 9, 10, 27,
-    48, 49, 26, 51, 52, 53, 54, 8, 56, 57, 58, 59, 4, 20, 62, 225,
-    65, 66, 67, 68, 69, 70, 71, 72, 73, 81, 82, 83, 84, 85, 86, 87,
-    88, 89, 98, 99, 100, 101, 102, 103, 104, 105, 112, 113, 114, 115, 116, 117,
-    118, 119, 120, 128, 138, 139, 140, 141, 142, 143, 144, 154, 155, 156, 157, 158,
-    159, 160, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
-    184, 185, 186, 187, 188, 189, 190, 191, 202, 203, 204, 205, 206, 207, 218, 219,
-    220, 221, 222, 223, 234, 235, 236, 237, 238, 239, 250, 251, 252, 253, 254, 255};
-
-
-static void iconv_e2a(unsigned char src[], unsigned char dst[], size_t length) {
-  size_t i;
-  for (i = 0; i < length; i++)
-    dst[i] = e2a[src[i]];
-}
-
-
-static void iconv_a2e(const char* src, unsigned char dst[], size_t length) {
-  size_t srclen;
-  size_t i;
-
-  srclen = strlen(src);
-  if (srclen > length)
-    abort();
-  for (i = 0; i < srclen; i++)
-    dst[i] = a2e[src[i]];
-  /* padding the remaining part with spaces */
-  for (; i < length; i++)
-    dst[i] = a2e[' '];
-}
-
-
 static int get_ibmi_system_status(SSTS0200* rcvr) {
   /* rcvrlen is input parameter 2 to QWCRSSTS */
   unsigned int rcvrlen = sizeof(*rcvr);
-  unsigned char format[8], reset_status[10];
 
-  /* format is input parameter 3 to QWCRSSTS */
-  iconv_a2e("SSTS0200", format, sizeof(format));
-  /* reset_status is input parameter 4 */
-  iconv_a2e("*NO", reset_status, sizeof(reset_status));
+  /* format is input parameter 3 to QWCRSSTS ("SSTS0200" in EBCDIC) */
+  unsigned char format[] = {0xE2, 0xE2, 0xE3, 0xE2, 0xF0, 0xF2, 0xF0, 0xF0};
+
+  /* reset_status is input parameter 4 to QWCRSSTS ("*NO       " in EBCDIC) */
+  unsigned char reset_status[] = {
+    0x5C, 0xD5, 0xD6, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40
+  };
 
   /* errcode is input parameter 5 to QWCRSSTS */
-  errcode_s errcode;
+  struct _errcode {
+    int bytes_provided;
+    int bytes_available;
+    char msgid[7];
+  } errcode;
 
   /* qwcrssts_pointer is the 16-byte tagged system pointer to QWCRSSTS */
   ILEpointer __attribute__((aligned(16))) qwcrssts_pointer;
@@ -213,7 +145,7 @@ static int get_ibmi_system_status(SSTS02
   qwcrssts_argv[5] = NULL;
 
   /* Call the IBM i QWCRSSTS API from PASE */
-  rc = _PGMCALL(&qwcrssts_pointer, qwcrssts_argv, 0);
+  rc = _PGMCALL(&qwcrssts_pointer, (void**)&qwcrssts_argv, 0);
 
   return rc;
 }
@@ -225,7 +157,19 @@ uint64_t uv_get_free_memory(void) {
   if (get_ibmi_system_status(&rcvr))
     return 0;
 
-  return (uint64_t)rcvr.main_storage_size * 1024ULL;
+  /* The amount of main storage, in kilobytes, in the system. */
+  uint64_t main_storage_size = rcvr.main_storage_size;
+
+  /* The current amount of storage in use for temporary objects.
+   * in millions (M) of bytes.
+   */
+  uint64_t current_unprotected_storage_used =
+    rcvr.current_unprotected_storage_used * 1024ULL;
+
+  uint64_t free_storage_size =
+    (main_storage_size - current_unprotected_storage_used) * 1024ULL;
+
+  return free_storage_size < 0 ? 0 : free_storage_size;
 }
 
 
@@ -303,159 +247,3 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
 
   return 0;
 }
-
-
-static int get_ibmi_physical_address(const char* line, char (*phys_addr)[6]) {
-  LIND0500 rcvr;
-  /* rcvrlen is input parameter 2 to QDCRLIND */
-  unsigned int rcvrlen = sizeof(rcvr);
-  unsigned char format[8], line_name[10];
-  unsigned char mac_addr[sizeof(rcvr.loca_adapter_address)];
-  int c[6];
-
-  /* format is input parameter 3 to QDCRLIND */
-  iconv_a2e("LIND0500", format, sizeof(format));
-
-  /* line_name is input parameter 4 to QDCRLIND */
-  iconv_a2e(line, line_name, sizeof(line_name));
-
-  /* err is input parameter 5 to QDCRLIND */
-  errcode_s err;
-
-  /* qwcrssts_pointer is the 16-byte tagged system pointer to QDCRLIND */
-  ILEpointer __attribute__((aligned(16))) qdcrlind_pointer;
-
-  /* qwcrssts_argv is the array of argument pointers to QDCRLIND */
-  void* qdcrlind_argv[6];
-
-  /* Set the IBM i pointer to the QSYS/QDCRLIND *PGM object */
-  int rc = _RSLOBJ2(&qdcrlind_pointer, RSLOBJ_TS_PGM, "QDCRLIND", "QSYS");
-
-  if (rc != 0)
-    return rc;
-
-  /* initialize the QDCRLIND returned info structure */
-  memset(&rcvr, 0, sizeof(rcvr));
-
-  /* initialize the QDCRLIND error code structure */
-  memset(&err, 0, sizeof(err));
-  err.bytes_provided = sizeof(err);
-
-  /* initialize the array of argument pointers for the QDCRLIND API */
-  qdcrlind_argv[0] = &rcvr;
-  qdcrlind_argv[1] = &rcvrlen;
-  qdcrlind_argv[2] = &format;
-  qdcrlind_argv[3] = &line_name;
-  qdcrlind_argv[4] = &err;
-  qdcrlind_argv[5] = NULL;
-
-  /* Call the IBM i QDCRLIND API from PASE */
-  rc = _PGMCALL(&qdcrlind_pointer, qdcrlind_argv, 0);
-  if (rc != 0)
-    return rc;
-
-  /* convert ebcdic loca_adapter_address to ascii first */
-  iconv_e2a(rcvr.loca_adapter_address, mac_addr,
-            sizeof(rcvr.loca_adapter_address));
-
-  /* convert loca_adapter_address(char[12]) to phys_addr(char[6]) */
-  int r = sscanf(mac_addr, "%02x%02x%02x%02x%02x%02x",
-                &c[0], &c[1], &c[2], &c[3], &c[4], &c[5]);
-
-  if (r == ARRAY_SIZE(c)) {
-    (*phys_addr)[0] = c[0];
-    (*phys_addr)[1] = c[1];
-    (*phys_addr)[2] = c[2];
-    (*phys_addr)[3] = c[3];
-    (*phys_addr)[4] = c[4];
-    (*phys_addr)[5] = c[5];
-  } else {
-    memset(*phys_addr, 0, sizeof(*phys_addr));
-    rc = -1;
-  }
-  return rc;
-}
-
-
-int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
-  uv_interface_address_t* address;
-  struct ifaddrs_pase *ifap = NULL, *cur;
-  int inet6, r = 0;
-
-  *count = 0;
-  *addresses = NULL;
-
-  if (Qp2getifaddrs(&ifap))
-    return UV_ENOSYS;
-
-  /* The first loop to get the size of the array to be allocated */
-  for (cur = ifap; cur; cur = cur->ifa_next) {
-    if (!(cur->ifa_addr->sa_family == AF_INET6 ||
-          cur->ifa_addr->sa_family == AF_INET))
-      continue;
-
-    if (!(cur->ifa_flags & IFF_UP && cur->ifa_flags & IFF_RUNNING))
-      continue;
-
-    (*count)++;
-  }
-
-  if (*count == 0) {
-    Qp2freeifaddrs(ifap);
-    return 0;
-  }
-
-  /* Alloc the return interface structs */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
-  if (*addresses == NULL) {
-    Qp2freeifaddrs(ifap);
-    return UV_ENOMEM;
-  }
-  address = *addresses;
-
-  /* The second loop to fill in the array */
-  for (cur = ifap; cur; cur = cur->ifa_next) {
-    if (!(cur->ifa_addr->sa_family == AF_INET6 ||
-          cur->ifa_addr->sa_family == AF_INET))
-      continue;
-
-    if (!(cur->ifa_flags & IFF_UP && cur->ifa_flags & IFF_RUNNING))
-      continue;
-
-    address->name = uv__strdup(cur->ifa_name);
-
-    inet6 = (cur->ifa_addr->sa_family == AF_INET6);
-
-    if (inet6) {
-      address->address.address6 = *((struct sockaddr_in6*)cur->ifa_addr);
-      address->netmask.netmask6 = *((struct sockaddr_in6*)cur->ifa_netmask);
-      address->netmask.netmask6.sin6_family = AF_INET6;
-    } else {
-      address->address.address4 = *((struct sockaddr_in*)cur->ifa_addr);
-      address->netmask.netmask4 = *((struct sockaddr_in*)cur->ifa_netmask);
-      address->netmask.netmask4.sin_family = AF_INET;
-    }
-    address->is_internal = cur->ifa_flags & IFF_LOOPBACK ? 1 : 0;
-    if (!address->is_internal) {
-      int rc = get_ibmi_physical_address(address->name, &address->phys_addr);
-      if (rc != 0)
-        r = rc;
-    }
-
-    address++;
-  }
-
-  Qp2freeifaddrs(ifap);
-  return r;
-}
-
-
-void uv_free_interface_addresses(uv_interface_address_t* addresses, int count) {
-  int i;
-
-  for (i = 0; i < count; ++i) {
-    uv__free(addresses[i].name);
-  }
-
-  uv__free(addresses);
-}
--- a/deps/uv/src/unix/internal.h
+++ b/deps/uv/src/unix/internal.h
@@ -28,10 +28,9 @@
 #include <limits.h> /* _POSIX_PATH_MAX, PATH_MAX */
 #include <stdlib.h> /* abort */
 #include <string.h> /* strrchr */
-#include <fcntl.h>  /* O_CLOEXEC and O_NONBLOCK, if supported. */
+#include <fcntl.h>  /* O_CLOEXEC, may be */
 #include <stdio.h>
 #include <errno.h>
-#include <sys/socket.h>
 
 #if defined(__STRICT_ANSI__)
 # define inline __inline
@@ -106,8 +105,10 @@ int uv__pthread_sigmask(int how, const s
 #if defined(__clang__) ||                                                     \
     defined(__GNUC__) ||                                                      \
     defined(__INTEL_COMPILER)
+# define UV_DESTRUCTOR(declaration) __attribute__((destructor)) declaration
 # define UV_UNUSED(declaration)     __attribute__((unused)) declaration
 #else
+# define UV_DESTRUCTOR(declaration) declaration
 # define UV_UNUSED(declaration)     declaration
 #endif
 
@@ -283,12 +284,13 @@ int uv___stream_fd(const uv_stream_t* ha
 #define uv__stream_fd(handle) ((handle)->io_watcher.fd)
 #endif /* defined(__APPLE__) */
 
-#ifdef O_NONBLOCK
-# define UV__F_NONBLOCK O_NONBLOCK
+#ifdef UV__O_NONBLOCK
+# define UV__F_NONBLOCK UV__O_NONBLOCK
 #else
 # define UV__F_NONBLOCK 1
 #endif
 
+int uv__make_socketpair(int fds[2], int flags);
 int uv__make_pipe(int fds[2], int flags);
 
 #if defined(__APPLE__)
@@ -326,27 +328,4 @@ int uv__getsockpeername(const uv_handle_
                         struct sockaddr* name,
                         int* namelen);
 
-#if defined(__linux__)            ||                                      \
-    defined(__FreeBSD__)          ||                                      \
-    defined(__FreeBSD_kernel__)
-#define HAVE_MMSG 1
-struct uv__mmsghdr {
-  struct msghdr msg_hdr;
-  unsigned int msg_len;
-};
-
-int uv__recvmmsg(int fd,
-                 struct uv__mmsghdr* mmsg,
-                 unsigned int vlen,
-                 unsigned int flags,
-                 struct timespec* timeout);
-int uv__sendmmsg(int fd,
-                 struct uv__mmsghdr* mmsg,
-                 unsigned int vlen,
-                 unsigned int flags);
-#else
-#define HAVE_MMSG 0
-#endif
-
-
 #endif /* UV_UNIX_INTERNAL_H_ */
--- a/deps/uv/src/unix/linux-core.c
+++ b/deps/uv/src/unix/linux-core.c
@@ -359,19 +359,9 @@ void uv__io_poll(uv_loop_t* loop, int ti
     have_signals = 0;
     nevents = 0;
 
-    {
-      /* Squelch a -Waddress-of-packed-member warning with gcc >= 9. */
-      union {
-        struct epoll_event* events;
-        uv__io_t* watchers;
-      } x;
-
-      x.events = events;
-      assert(loop->watchers != NULL);
-      loop->watchers[loop->nwatchers] = x.watchers;
-      loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;
-    }
-
+    assert(loop->watchers != NULL);
+    loop->watchers[loop->nwatchers] = (void*) events;
+    loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;
     for (i = 0; i < nfds; i++) {
       pe = events + i;
       fd = pe->data.fd;
@@ -768,8 +758,7 @@ static int read_times(FILE* statfile_fp,
                       unsigned int numcpus,
                       uv_cpu_info_t* ci) {
   struct uv_cpu_times_s ts;
-  unsigned int ticks;
-  unsigned int multiplier;
+  uint64_t clock_ticks;
   uint64_t user;
   uint64_t nice;
   uint64_t sys;
@@ -780,10 +769,9 @@ static int read_times(FILE* statfile_fp,
   uint64_t len;
   char buf[1024];
 
-  ticks = (unsigned int)sysconf(_SC_CLK_TCK);
-  multiplier = ((uint64_t)1000L / ticks);
-  assert(ticks != (unsigned int) -1);
-  assert(ticks != 0);
+  clock_ticks = sysconf(_SC_CLK_TCK);
+  assert(clock_ticks != (uint64_t) -1);
+  assert(clock_ticks != 0);
 
   rewind(statfile_fp);
 
@@ -825,11 +813,11 @@ static int read_times(FILE* statfile_fp,
                     &irq))
       abort();
 
-    ts.user = user * multiplier;
-    ts.nice = nice * multiplier;
-    ts.sys  = sys * multiplier;
-    ts.idle = idle * multiplier;
-    ts.irq  = irq * multiplier;
+    ts.user = clock_ticks * user;
+    ts.nice = clock_ticks * nice;
+    ts.sys  = clock_ticks * sys;
+    ts.idle = clock_ticks * idle;
+    ts.irq  = clock_ticks * irq;
     ci[num++].cpu_times = ts;
   }
   assert(num == numcpus);
@@ -992,7 +980,7 @@ static uint64_t uv__read_proc_meminfo(co
   rc = 0;
   fd = uv__open_cloexec("/proc/meminfo", O_RDONLY);
 
-  if (fd < 0)
+  if (fd == -1)
     return 0;
 
   n = read(fd, buf, sizeof(buf) - 1);
--- a/deps/uv/src/unix/linux-inotify.c
+++ b/deps/uv/src/unix/linux-inotify.c
@@ -29,7 +29,6 @@
 #include <assert.h>
 #include <errno.h>
 
-#include <sys/inotify.h>
 #include <sys/types.h>
 #include <unistd.h>
 
@@ -65,17 +64,45 @@ static void uv__inotify_read(uv_loop_t*
 static void maybe_free_watcher_list(struct watcher_list* w,
                                     uv_loop_t* loop);
 
-static int init_inotify(uv_loop_t* loop) {
+static int new_inotify_fd(void) {
+  int err;
   int fd;
 
+  fd = uv__inotify_init1(UV__IN_NONBLOCK | UV__IN_CLOEXEC);
+  if (fd != -1)
+    return fd;
+
+  if (errno != ENOSYS)
+    return UV__ERR(errno);
+
+  fd = uv__inotify_init();
+  if (fd == -1)
+    return UV__ERR(errno);
+
+  err = uv__cloexec(fd, 1);
+  if (err == 0)
+    err = uv__nonblock(fd, 1);
+
+  if (err) {
+    uv__close(fd);
+    return err;
+  }
+
+  return fd;
+}
+
+
+static int init_inotify(uv_loop_t* loop) {
+  int err;
+
   if (loop->inotify_fd != -1)
     return 0;
 
-  fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
-  if (fd < 0)
-    return UV__ERR(errno);
+  err = new_inotify_fd();
+  if (err < 0)
+    return err;
 
-  loop->inotify_fd = fd;
+  loop->inotify_fd = err;
   uv__io_init(&loop->inotify_read_watcher, uv__inotify_read, loop->inotify_fd);
   uv__io_start(loop, &loop->inotify_read_watcher, POLLIN);
 
@@ -159,7 +186,7 @@ static void maybe_free_watcher_list(stru
   if ((!w->iterating) && QUEUE_EMPTY(&w->watchers)) {
     /* No watchers left for this path. Clean up. */
     RB_REMOVE(watcher_root, CAST(&loop->inotify_watchers), w);
-    inotify_rm_watch(loop->inotify_fd, w->wd);
+    uv__inotify_rm_watch(loop->inotify_fd, w->wd);
     uv__free(w);
   }
 }
@@ -167,7 +194,7 @@ static void maybe_free_watcher_list(stru
 static void uv__inotify_read(uv_loop_t* loop,
                              uv__io_t* dummy,
                              unsigned int events) {
-  const struct inotify_event* e;
+  const struct uv__inotify_event* e;
   struct watcher_list* w;
   uv_fs_event_t* h;
   QUEUE queue;
@@ -192,12 +219,12 @@ static void uv__inotify_read(uv_loop_t*
 
     /* Now we have one or more inotify_event structs. */
     for (p = buf; p < buf + size; p += sizeof(*e) + e->len) {
-      e = (const struct inotify_event*) p;
+      e = (const struct uv__inotify_event*)p;
 
       events = 0;
-      if (e->mask & (IN_ATTRIB|IN_MODIFY))
+      if (e->mask & (UV__IN_ATTRIB|UV__IN_MODIFY))
         events |= UV_CHANGE;
-      if (e->mask & ~(IN_ATTRIB|IN_MODIFY))
+      if (e->mask & ~(UV__IN_ATTRIB|UV__IN_MODIFY))
         events |= UV_RENAME;
 
       w = find_watcher(loop, e->wd);
@@ -263,16 +290,16 @@ int uv_fs_event_start(uv_fs_event_t* han
   if (err)
     return err;
 
-  events = IN_ATTRIB
-         | IN_CREATE
-         | IN_MODIFY
-         | IN_DELETE
-         | IN_DELETE_SELF
-         | IN_MOVE_SELF
-         | IN_MOVED_FROM
-         | IN_MOVED_TO;
+  events = UV__IN_ATTRIB
+         | UV__IN_CREATE
+         | UV__IN_MODIFY
+         | UV__IN_DELETE
+         | UV__IN_DELETE_SELF
+         | UV__IN_MOVE_SELF
+         | UV__IN_MOVED_FROM
+         | UV__IN_MOVED_TO;
 
-  wd = inotify_add_watch(handle->loop->inotify_fd, path, events);
+  wd = uv__inotify_add_watch(handle->loop->inotify_fd, path, events);
   if (wd == -1)
     return UV__ERR(errno);
 
--- a/deps/uv/src/unix/linux-syscalls.c
+++ b/deps/uv/src/unix/linux-syscalls.c
@@ -26,6 +26,19 @@
 #include <sys/types.h>
 #include <errno.h>
 
+#if defined(__has_feature)
+# if __has_feature(memory_sanitizer)
+#  define MSAN_ACTIVE 1
+#  include <sanitizer/msan_interface.h>
+# endif
+#endif
+
+#if defined(__i386__)
+# ifndef __NR_socketcall
+#  define __NR_socketcall 102
+# endif
+#endif
+
 #if defined(__arm__)
 # if defined(__thumb__) || defined(__ARM_EABI__)
 #  define UV_SYSCALL_BASE 0
@@ -34,6 +47,86 @@
 # endif
 #endif /* __arm__ */
 
+#ifndef __NR_accept4
+# if defined(__x86_64__)
+#  define __NR_accept4 288
+# elif defined(__i386__)
+   /* Nothing. Handled through socketcall(). */
+# elif defined(__arm__)
+#  define __NR_accept4 (UV_SYSCALL_BASE + 366)
+# endif
+#endif /* __NR_accept4 */
+
+#ifndef __NR_eventfd
+# if defined(__x86_64__)
+#  define __NR_eventfd 284
+# elif defined(__i386__)
+#  define __NR_eventfd 323
+# elif defined(__arm__)
+#  define __NR_eventfd (UV_SYSCALL_BASE + 351)
+# endif
+#endif /* __NR_eventfd */
+
+#ifndef __NR_eventfd2
+# if defined(__x86_64__)
+#  define __NR_eventfd2 290
+# elif defined(__i386__)
+#  define __NR_eventfd2 328
+# elif defined(__arm__)
+#  define __NR_eventfd2 (UV_SYSCALL_BASE + 356)
+# endif
+#endif /* __NR_eventfd2 */
+
+#ifndef __NR_inotify_init
+# if defined(__x86_64__)
+#  define __NR_inotify_init 253
+# elif defined(__i386__)
+#  define __NR_inotify_init 291
+# elif defined(__arm__)
+#  define __NR_inotify_init (UV_SYSCALL_BASE + 316)
+# endif
+#endif /* __NR_inotify_init */
+
+#ifndef __NR_inotify_init1
+# if defined(__x86_64__)
+#  define __NR_inotify_init1 294
+# elif defined(__i386__)
+#  define __NR_inotify_init1 332
+# elif defined(__arm__)
+#  define __NR_inotify_init1 (UV_SYSCALL_BASE + 360)
+# endif
+#endif /* __NR_inotify_init1 */
+
+#ifndef __NR_inotify_add_watch
+# if defined(__x86_64__)
+#  define __NR_inotify_add_watch 254
+# elif defined(__i386__)
+#  define __NR_inotify_add_watch 292
+# elif defined(__arm__)
+#  define __NR_inotify_add_watch (UV_SYSCALL_BASE + 317)
+# endif
+#endif /* __NR_inotify_add_watch */
+
+#ifndef __NR_inotify_rm_watch
+# if defined(__x86_64__)
+#  define __NR_inotify_rm_watch 255
+# elif defined(__i386__)
+#  define __NR_inotify_rm_watch 293
+# elif defined(__arm__)
+#  define __NR_inotify_rm_watch (UV_SYSCALL_BASE + 318)
+# endif
+#endif /* __NR_inotify_rm_watch */
+
+#ifndef __NR_pipe2
+# if defined(__x86_64__)
+#  define __NR_pipe2 293
+# elif defined(__i386__)
+#  define __NR_pipe2 331
+# elif defined(__arm__)
+#  define __NR_pipe2 (UV_SYSCALL_BASE + 359)
+# endif
+#endif /* __NR_pipe2 */
+
 #ifndef __NR_recvmmsg
 # if defined(__x86_64__)
 #  define __NR_recvmmsg 299
@@ -126,7 +219,103 @@
 # endif
 #endif /* __NR_getrandom */
 
-struct uv__mmsghdr;
+int uv__accept4(int fd, struct sockaddr* addr, socklen_t* addrlen, int flags) {
+#if defined(__i386__)
+  unsigned long args[4];
+  int r;
+
+  args[0] = (unsigned long) fd;
+  args[1] = (unsigned long) addr;
+  args[2] = (unsigned long) addrlen;
+  args[3] = (unsigned long) flags;
+
+  r = syscall(__NR_socketcall, 18 /* SYS_ACCEPT4 */, args);
+
+  /* socketcall() raises EINVAL when SYS_ACCEPT4 is not supported but so does
+   * a bad flags argument. Try to distinguish between the two cases.
+   */
+  if (r == -1)
+    if (errno == EINVAL)
+      if ((flags & ~(UV__SOCK_CLOEXEC|UV__SOCK_NONBLOCK)) == 0)
+        errno = ENOSYS;
+
+  return r;
+#elif defined(__NR_accept4)
+  return syscall(__NR_accept4, fd, addr, addrlen, flags);
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
+
+int uv__eventfd(unsigned int count) {
+#if defined(__NR_eventfd)
+  return syscall(__NR_eventfd, count);
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
+
+int uv__eventfd2(unsigned int count, int flags) {
+#if defined(__NR_eventfd2)
+  return syscall(__NR_eventfd2, count, flags);
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
+
+int uv__inotify_init(void) {
+#if defined(__NR_inotify_init)
+  return syscall(__NR_inotify_init);
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
+
+int uv__inotify_init1(int flags) {
+#if defined(__NR_inotify_init1)
+  return syscall(__NR_inotify_init1, flags);
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
+
+int uv__inotify_add_watch(int fd, const char* path, uint32_t mask) {
+#if defined(__NR_inotify_add_watch)
+  return syscall(__NR_inotify_add_watch, fd, path, mask);
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
+
+int uv__inotify_rm_watch(int fd, int32_t wd) {
+#if defined(__NR_inotify_rm_watch)
+  return syscall(__NR_inotify_rm_watch, fd, wd);
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
+
+int uv__pipe2(int pipefd[2], int flags) {
+#if defined(__NR_pipe2)
+  int result;
+  result = syscall(__NR_pipe2, pipefd, flags);
+#if MSAN_ACTIVE
+  if (!result)
+    __msan_unpoison(pipefd, sizeof(int[2]));
+#endif
+  return result;
+#else
+  return errno = ENOSYS, -1;
+#endif
+}
+
 
 int uv__sendmmsg(int fd,
                  struct uv__mmsghdr* mmsg,
--- a/deps/uv/src/unix/linux-syscalls.h
+++ b/deps/uv/src/unix/linux-syscalls.h
@@ -31,6 +31,55 @@
 #include <sys/time.h>
 #include <sys/socket.h>
 
+#if defined(__alpha__)
+# define UV__O_CLOEXEC        0x200000
+#elif defined(__hppa__)
+# define UV__O_CLOEXEC        0x200000
+#elif defined(__sparc__)
+# define UV__O_CLOEXEC        0x400000
+#else
+# define UV__O_CLOEXEC        0x80000
+#endif
+
+#if defined(__alpha__)
+# define UV__O_NONBLOCK       0x4
+#elif defined(__hppa__)
+# define UV__O_NONBLOCK       O_NONBLOCK
+#elif defined(__mips__)
+# define UV__O_NONBLOCK       0x80
+#elif defined(__sparc__)
+# define UV__O_NONBLOCK       0x4000
+#else
+# define UV__O_NONBLOCK       0x800
+#endif
+
+#define UV__EFD_CLOEXEC       UV__O_CLOEXEC
+#define UV__EFD_NONBLOCK      UV__O_NONBLOCK
+
+#define UV__IN_CLOEXEC        UV__O_CLOEXEC
+#define UV__IN_NONBLOCK       UV__O_NONBLOCK
+
+#define UV__SOCK_CLOEXEC      UV__O_CLOEXEC
+#if defined(SOCK_NONBLOCK)
+# define UV__SOCK_NONBLOCK    SOCK_NONBLOCK
+#else
+# define UV__SOCK_NONBLOCK    UV__O_NONBLOCK
+#endif
+
+/* inotify flags */
+#define UV__IN_ACCESS         0x001
+#define UV__IN_MODIFY         0x002
+#define UV__IN_ATTRIB         0x004
+#define UV__IN_CLOSE_WRITE    0x008
+#define UV__IN_CLOSE_NOWRITE  0x010
+#define UV__IN_OPEN           0x020
+#define UV__IN_MOVED_FROM     0x040
+#define UV__IN_MOVED_TO       0x080
+#define UV__IN_CREATE         0x100
+#define UV__IN_DELETE         0x200
+#define UV__IN_DELETE_SELF    0x400
+#define UV__IN_MOVE_SELF      0x800
+
 struct uv__statx_timestamp {
   int64_t tv_sec;
   uint32_t tv_nsec;
@@ -61,6 +110,36 @@ struct uv__statx {
   uint64_t unused1[14];
 };
 
+struct uv__inotify_event {
+  int32_t wd;
+  uint32_t mask;
+  uint32_t cookie;
+  uint32_t len;
+  /* char name[0]; */
+};
+
+struct uv__mmsghdr {
+  struct msghdr msg_hdr;
+  unsigned int msg_len;
+};
+
+int uv__accept4(int fd, struct sockaddr* addr, socklen_t* addrlen, int flags);
+int uv__eventfd(unsigned int count);
+int uv__eventfd2(unsigned int count, int flags);
+int uv__inotify_init(void);
+int uv__inotify_init1(int flags);
+int uv__inotify_add_watch(int fd, const char* path, uint32_t mask);
+int uv__inotify_rm_watch(int fd, int32_t wd);
+int uv__pipe2(int pipefd[2], int flags);
+int uv__recvmmsg(int fd,
+                 struct uv__mmsghdr* mmsg,
+                 unsigned int vlen,
+                 unsigned int flags,
+                 struct timespec* timeout);
+int uv__sendmmsg(int fd,
+                 struct uv__mmsghdr* mmsg,
+                 unsigned int vlen,
+                 unsigned int flags);
 ssize_t uv__preadv(int fd, const struct iovec *iov, int iovcnt, int64_t offset);
 ssize_t uv__pwritev(int fd, const struct iovec *iov, int iovcnt, int64_t offset);
 int uv__dup3(int oldfd, int newfd, int flags);
--- a/deps/uv/src/unix/loop.c
+++ b/deps/uv/src/unix/loop.c
@@ -106,8 +106,6 @@ fail_rwlock_init:
 fail_signal_init:
   uv__platform_loop_delete(loop);
 
-  uv__free(loop->watchers);
-  loop->nwatchers = 0;
   return err;
 }
 
--- a/deps/uv/src/unix/netbsd.c
+++ b/deps/uv/src/unix/netbsd.c
@@ -55,7 +55,7 @@ void uv_loadavg(double avg[3]) {
   size_t size = sizeof(info);
   int which[] = {CTL_VM, VM_LOADAVG};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0) == -1) return;
+  if (sysctl(which, 2, &info, &size, NULL, 0) == -1) return;
 
   avg[0] = (double) info.ldavg[0] / info.fscale;
   avg[1] = (double) info.ldavg[1] / info.fscale;
@@ -102,7 +102,7 @@ uint64_t uv_get_free_memory(void) {
   size_t size = sizeof(info);
   int which[] = {CTL_VM, VM_UVMEXP};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   return (uint64_t) info.free * sysconf(_SC_PAGESIZE);
@@ -119,7 +119,7 @@ uint64_t uv_get_total_memory(void) {
 #endif
   size_t size = sizeof(info);
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   return (uint64_t) info;
@@ -167,7 +167,7 @@ int uv_uptime(double* uptime) {
   size_t size = sizeof(info);
   static int which[] = {CTL_KERN, KERN_BOOTTIME};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   now = time(NULL);
--- a/deps/uv/src/unix/no-proctitle.c
+++ b/deps/uv/src/unix/no-proctitle.c
@@ -29,9 +29,6 @@ char** uv_setup_args(int argc, char** ar
   return argv;
 }
 
-void uv__process_title_cleanup(void) {
-}
-
 int uv_set_process_title(const char* title) {
   return 0;
 }
--- a/deps/uv/src/unix/openbsd.c
+++ b/deps/uv/src/unix/openbsd.c
@@ -50,7 +50,7 @@ void uv_loadavg(double avg[3]) {
   size_t size = sizeof(info);
   int which[] = {CTL_VM, VM_LOADAVG};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0) < 0) return;
+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) return;
 
   avg[0] = (double) info.ldavg[0] / info.fscale;
   avg[1] = (double) info.ldavg[1] / info.fscale;
@@ -61,6 +61,7 @@ void uv_loadavg(double avg[3]) {
 int uv_exepath(char* buffer, size_t* size) {
   int mib[4];
   char **argsbuf = NULL;
+  char **argsbuf_tmp;
   size_t argsbuf_size = 100U;
   size_t exepath_size;
   pid_t mypid;
@@ -72,14 +73,15 @@ int uv_exepath(char* buffer, size_t* siz
   mypid = getpid();
   for (;;) {
     err = UV_ENOMEM;
-    argsbuf = uv__reallocf(argsbuf, argsbuf_size);
-    if (argsbuf == NULL)
+    argsbuf_tmp = uv__realloc(argsbuf, argsbuf_size);
+    if (argsbuf_tmp == NULL)
       goto out;
+    argsbuf = argsbuf_tmp;
     mib[0] = CTL_KERN;
     mib[1] = KERN_PROC_ARGS;
     mib[2] = mypid;
     mib[3] = KERN_PROC_ARGV;
-    if (sysctl(mib, ARRAY_SIZE(mib), argsbuf, &argsbuf_size, NULL, 0) == 0) {
+    if (sysctl(mib, 4, argsbuf, &argsbuf_size, NULL, 0) == 0) {
       break;
     }
     if (errno != ENOMEM) {
@@ -115,7 +117,7 @@ uint64_t uv_get_free_memory(void) {
   size_t size = sizeof(info);
   int which[] = {CTL_VM, VM_UVMEXP};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   return (uint64_t) info.free * sysconf(_SC_PAGESIZE);
@@ -127,7 +129,7 @@ uint64_t uv_get_total_memory(void) {
   int which[] = {CTL_HW, HW_PHYSMEM64};
   size_t size = sizeof(info);
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   return (uint64_t) info;
@@ -152,7 +154,7 @@ int uv_resident_set_memory(size_t* rss)
   mib[4] = sizeof(struct kinfo_proc);
   mib[5] = 1;
 
-  if (sysctl(mib, ARRAY_SIZE(mib), &kinfo, &size, NULL, 0) < 0)
+  if (sysctl(mib, 6, &kinfo, &size, NULL, 0) < 0)
     return UV__ERR(errno);
 
   *rss = kinfo.p_vm_rssize * page_size;
@@ -166,7 +168,7 @@ int uv_uptime(double* uptime) {
   size_t size = sizeof(info);
   static int which[] = {CTL_KERN, KERN_BOOTTIME};
 
-  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))
+  if (sysctl(which, 2, &info, &size, NULL, 0))
     return UV__ERR(errno);
 
   now = time(NULL);
@@ -182,19 +184,18 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
   uint64_t info[CPUSTATES];
   char model[512];
   int numcpus = 1;
-  int which[] = {CTL_HW,HW_MODEL};
-  int percpu[] = {CTL_KERN,KERN_CPTIME2,0};
+  int which[] = {CTL_HW,HW_MODEL,0};
   size_t size;
   int i, j;
   uv_cpu_info_t* cpu_info;
 
   size = sizeof(model);
-  if (sysctl(which, ARRAY_SIZE(which), &model, &size, NULL, 0))
+  if (sysctl(which, 2, &model, &size, NULL, 0))
     return UV__ERR(errno);
 
   which[1] = HW_NCPUONLINE;
   size = sizeof(numcpus);
-  if (sysctl(which, ARRAY_SIZE(which), &numcpus, &size, NULL, 0))
+  if (sysctl(which, 2, &numcpus, &size, NULL, 0))
     return UV__ERR(errno);
 
   *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
@@ -206,13 +207,16 @@ int uv_cpu_info(uv_cpu_info_t** cpu_info
 
   which[1] = HW_CPUSPEED;
   size = sizeof(cpuspeed);
-  if (sysctl(which, ARRAY_SIZE(which), &cpuspeed, &size, NULL, 0))
+  if (sysctl(which, 2, &cpuspeed, &size, NULL, 0))
     goto error;
 
   size = sizeof(info);
+  which[0] = CTL_KERN;
+  which[1] = KERN_CPTIME2;
   for (i = 0; i < numcpus; i++) {
-    percpu[2] = i;
-    if (sysctl(percpu, ARRAY_SIZE(percpu), &info, &size, NULL, 0))
+    which[2] = i;
+    size = sizeof(info);
+    if (sysctl(which, 3, &info, &size, NULL, 0))
       goto error;
 
     cpu_info = &(*cpu_infos)[i];
--- a/deps/uv/src/unix/os390.c
+++ b/deps/uv/src/unix/os390.c
@@ -923,7 +923,7 @@ void uv__io_poll(uv_loop_t* loop, int ti
         continue;
 
       ep = loop->ep;
-      if (pe->is_msg) {
+      if (fd == ep->msg_queue) {
         os390_message_queue_handler(ep);
         continue;
       }
--- a/deps/uv/src/unix/os390-syscalls.c
+++ b/deps/uv/src/unix/os390-syscalls.c
@@ -43,7 +43,6 @@ int scandir(const char* maindir, struct
             int (*compar)(const struct dirent**,
             const struct dirent **)) {
   struct dirent** nl;
-  struct dirent** nl_copy;
   struct dirent* dirent;
   unsigned count;
   size_t allocated;
@@ -63,17 +62,19 @@ int scandir(const char* maindir, struct
     if (!filter || filter(dirent)) {
       struct dirent* copy;
       copy = uv__malloc(sizeof(*copy));
-      if (!copy)
-        goto error;
-      memcpy(copy, dirent, sizeof(*copy));
-
-      nl_copy = uv__realloc(nl, sizeof(*copy) * (count + 1));
-      if (nl_copy == NULL) {
-        uv__free(copy);
-        goto error;
+      if (!copy) {
+        while (count) {
+          dirent = nl[--count];
+          uv__free(dirent);
+        }
+        uv__free(nl);
+        closedir(mdir);
+        errno = ENOMEM;
+        return -1;
       }
+      memcpy(copy, dirent, sizeof(*copy));
 
-      nl = nl_copy;
+      nl = uv__realloc(nl, sizeof(*copy) * (count + 1));
       nl[count++] = copy;
     }
   }
@@ -85,16 +86,6 @@ int scandir(const char* maindir, struct
 
   *namelist = nl;
   return count;
-
-error:
-  while (count > 0) {
-    dirent = nl[--count];
-    uv__free(dirent);
-  }
-  uv__free(nl);
-  closedir(mdir);
-  errno = ENOMEM;
-  return -1;
 }
 
 
@@ -128,7 +119,7 @@ static void maybe_resize(uv__os390_epoll
   }
 
   newsize = next_power_of_two(len);
-  newlst = uv__reallocf(lst->items, newsize * sizeof(lst->items[0]));
+  newlst = uv__realloc(lst->items, newsize * sizeof(lst->items[0]));
 
   if (newlst == NULL)
     abort();
@@ -278,8 +269,6 @@ int epoll_ctl(uv__os390_epoll* lst,
   return 0;
 }
 
-#define EP_MAX_PFDS (ULONG_MAX / sizeof(struct pollfd))
-#define EP_MAX_EVENTS (INT_MAX / sizeof(struct epoll_event))
 
 int epoll_wait(uv__os390_epoll* lst, struct epoll_event* events,
                int maxevents, int timeout) {
@@ -288,41 +277,18 @@ int epoll_wait(uv__os390_epoll* lst, str
   int pollret;
   int reventcount;
   int nevents;
-  struct pollfd msg_fd;
-  int i;
-
-  if (!lst || !lst->items || !events) {
-    errno = EFAULT;
-    return -1;
-  }
 
-  if (lst->size > EP_MAX_PFDS) {
-    errno = EINVAL;
-    return -1;
-  }
-
-  if (maxevents <= 0 || maxevents > EP_MAX_EVENTS) {
-    errno = EINVAL;
-    return -1;
-  }
-
-  if (lst->size > 0)
-    _SET_FDS_MSGS(size, 1, lst->size - 1);
-  else
-    _SET_FDS_MSGS(size, 0, 0);
+  _SET_FDS_MSGS(size, 1, lst->size - 1);
   pfds = lst->items;
   pollret = poll(pfds, size, timeout);
   if (pollret <= 0)
     return pollret;
 
-  assert(lst->size > 0);
-
   pollret = _NFDS(pollret) + _NMSGS(pollret);
 
   reventcount = 0;
   nevents = 0;
-  msg_fd = pfds[lst->size - 1];
-  for (i = 0;
+  for (int i = 0; 
        i < lst->size && i < maxevents && reventcount < pollret; ++i) {
     struct epoll_event ev;
     struct pollfd* pfd;
@@ -333,7 +299,6 @@ int epoll_wait(uv__os390_epoll* lst, str
 
     ev.fd = pfd->fd;
     ev.events = pfd->revents;
-    ev.is_msg = 0;
     if (pfd->revents & POLLIN && pfd->revents & POLLOUT)
       reventcount += 2;
     else if (pfd->revents & (POLLIN | POLLOUT))
@@ -343,10 +308,6 @@ int epoll_wait(uv__os390_epoll* lst, str
     events[nevents++] = ev;
   }
 
-  if (msg_fd.revents != 0 && msg_fd.fd != -1)
-    if (i == lst->size)
-      events[nevents - 1].is_msg = 1;
-
   return nevents;
 }
 
@@ -408,12 +369,10 @@ int nanosleep(const struct timespec* req
    * Don't leak EAGAIN, that just means the timeout expired.
    */
   if (rv == -1)
-    if (err == EAGAIN)
-      rv = 0;
-    else
+    if (err != EAGAIN)
       errno = err;
 
-  if (rem != NULL && (rv == 0 || err == EINTR)) {
+  if (rem != NULL && (rv == 0 || err == EINTR || err == EAGAIN)) {
     rem->tv_nsec = nanorem;
     rem->tv_sec = secrem;
   }
@@ -558,28 +517,3 @@ size_t strnlen(const char* str, size_t m
   else
     return p - str;
 }
-
-
-int sem_init(UV_PLATFORM_SEM_T* semid, int pshared, unsigned int value) {
-  UNREACHABLE();
-}
-
-
-int sem_destroy(UV_PLATFORM_SEM_T* semid) {
-  UNREACHABLE();
-}
-
-
-int sem_post(UV_PLATFORM_SEM_T* semid) {
-  UNREACHABLE();
-}
-
-
-int sem_trywait(UV_PLATFORM_SEM_T* semid) {
-  UNREACHABLE();
-}
-
-
-int sem_wait(UV_PLATFORM_SEM_T* semid) {
-  UNREACHABLE();
-}
--- a/deps/uv/src/unix/os390-syscalls.h
+++ b/deps/uv/src/unix/os390-syscalls.h
@@ -40,7 +40,6 @@
 struct epoll_event {
   int events;
   int fd;
-  int is_msg;
 };
 
 typedef struct {
@@ -65,10 +64,5 @@ int scandir(const char* maindir, struct
 char *mkdtemp(char* path);
 ssize_t os390_readlink(const char* path, char* buf, size_t len);
 size_t strnlen(const char* str, size_t maxlen);
-int sem_init(UV_PLATFORM_SEM_T* semid, int pshared, unsigned int value);
-int sem_destroy(UV_PLATFORM_SEM_T* semid);
-int sem_post(UV_PLATFORM_SEM_T* semid);
-int sem_trywait(UV_PLATFORM_SEM_T* semid);
-int sem_wait(UV_PLATFORM_SEM_T* semid);
 
 #endif /* UV_OS390_SYSCALL_H_ */
--- a/deps/uv/src/unix/pipe.c
+++ b/deps/uv/src/unix/pipe.c
@@ -95,12 +95,8 @@ int uv_pipe_listen(uv_pipe_t* handle, in
   if (uv__stream_fd(handle) == -1)
     return UV_EINVAL;
 
-  if (handle->ipc)
-    return UV_EINVAL;
-
-#if defined(__MVS__) || defined(__PASE__)
+#if defined(__MVS__)
   /* On zOS, backlog=0 has undefined behaviour */
-  /* On IBMi PASE, backlog=0 leads to "Connection refused" error */
   if (backlog == 0)
     backlog = 1;
   else if (backlog < 0)
--- a/deps/uv/src/unix/posix-poll.c
+++ b/deps/uv/src/unix/posix-poll.c
@@ -61,7 +61,7 @@ static void uv__pollfds_maybe_resize(uv_
     return;
 
   n = loop->poll_fds_size ? loop->poll_fds_size * 2 : 64;
-  p = uv__reallocf(loop->poll_fds, n * sizeof(*loop->poll_fds));
+  p = uv__realloc(loop->poll_fds, n * sizeof(*loop->poll_fds));
   if (p == NULL)
     abort();
 
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -112,64 +112,72 @@ static void uv__chld(uv_signal_t* handle
 }
 
 
-static int uv__make_socketpair(int fds[2]) {
-#if defined(__FreeBSD__) || defined(__linux__)
-  if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, fds))
+int uv__make_socketpair(int fds[2], int flags) {
+#if defined(__linux__)
+  static int no_cloexec;
+
+  if (no_cloexec)
+    goto skip;
+
+  if (socketpair(AF_UNIX, SOCK_STREAM | UV__SOCK_CLOEXEC | flags, 0, fds) == 0)
+    return 0;
+
+  /* Retry on EINVAL, it means SOCK_CLOEXEC is not supported.
+   * Anything else is a genuine error.
+   */
+  if (errno != EINVAL)
     return UV__ERR(errno);
 
-  return 0;
-#else
-  int err;
+  no_cloexec = 1;
+
+skip:
+#endif
 
   if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))
     return UV__ERR(errno);
 
-  err = uv__cloexec(fds[0], 1);
-  if (err == 0)
-    err = uv__cloexec(fds[1], 1);
-
-  if (err != 0) {
-    uv__close(fds[0]);
-    uv__close(fds[1]);
-    return UV__ERR(errno);
+  uv__cloexec(fds[0], 1);
+  uv__cloexec(fds[1], 1);
+
+  if (flags & UV__F_NONBLOCK) {
+    uv__nonblock(fds[0], 1);
+    uv__nonblock(fds[1], 1);
   }
 
   return 0;
-#endif
 }
 
 
 int uv__make_pipe(int fds[2], int flags) {
-#if defined(__FreeBSD__) || defined(__linux__)
-  if (pipe2(fds, flags | O_CLOEXEC))
+#if defined(__linux__)
+  static int no_pipe2;
+
+  if (no_pipe2)
+    goto skip;
+
+  if (uv__pipe2(fds, flags | UV__O_CLOEXEC) == 0)
+    return 0;
+
+  if (errno != ENOSYS)
     return UV__ERR(errno);
 
-  return 0;
-#else
+  no_pipe2 = 1;
+
+skip:
+#endif
+
   if (pipe(fds))
     return UV__ERR(errno);
 
-  if (uv__cloexec(fds[0], 1))
-    goto fail;
-
-  if (uv__cloexec(fds[1], 1))
-    goto fail;
+  uv__cloexec(fds[0], 1);
+  uv__cloexec(fds[1], 1);
 
   if (flags & UV__F_NONBLOCK) {
-    if (uv__nonblock(fds[0], 1))
-      goto fail;
-
-    if (uv__nonblock(fds[1], 1))
-      goto fail;
+    uv__nonblock(fds[0], 1);
+    uv__nonblock(fds[1], 1);
   }
 
   return 0;
-
-fail:
-  uv__close(fds[0]);
-  uv__close(fds[1]);
-  return UV__ERR(errno);
-#endif
 }
 
 
@@ -192,7 +200,7 @@ static int uv__process_init_stdio(uv_std
     if (container->data.stream->type != UV_NAMED_PIPE)
       return UV_EINVAL;
     else
-      return uv__make_socketpair(fds);
+      return uv__make_socketpair(fds, 0);
 
   case UV_INHERIT_FD:
   case UV_INHERIT_STREAM:
--- a/deps/uv/src/unix/proctitle.c
+++ b/deps/uv/src/unix/proctitle.c
@@ -24,27 +24,28 @@
 #include <stdlib.h>
 #include <string.h>
 
-struct uv__process_title {
-  char* str;
-  size_t len;  /* Length of the current process title. */
-  size_t cap;  /* Maximum capacity. Computed once in uv_setup_args(). */
-};
-
+extern void uv__set_process_title_platform_init(void);
 extern void uv__set_process_title(const char* title);
 
 static uv_mutex_t process_title_mutex;
 static uv_once_t process_title_mutex_once = UV_ONCE_INIT;
-static struct uv__process_title process_title;
 static void* args_mem;
 
+static struct {
+  char* str;
+  size_t len;
+} process_title;
+
 
 static void init_process_title_mutex_once(void) {
   uv_mutex_init(&process_title_mutex);
+#ifdef __APPLE__
+  uv__set_process_title_platform_init();
+#endif
 }
 
 
 char** uv_setup_args(int argc, char** argv) {
-  struct uv__process_title pt;
   char** new_argv;
   size_t size;
   char* s;
@@ -53,69 +54,53 @@ char** uv_setup_args(int argc, char** ar
   if (argc <= 0)
     return argv;
 
-  pt.str = argv[0];
-  pt.len = strlen(argv[0]);
-  pt.cap = pt.len + 1;
-
   /* Calculate how much memory we need for the argv strings. */
-  size = pt.cap;
-  for (i = 1; i < argc; i++)
+  size = 0;
+  for (i = 0; i < argc; i++)
     size += strlen(argv[i]) + 1;
 
+#if defined(__MVS__)
+  /* argv is not adjacent. So just use argv[0] */
+  process_title.str = argv[0];
+  process_title.len = strlen(argv[0]);
+#else
+  process_title.str = argv[0];
+  process_title.len = argv[argc - 1] + strlen(argv[argc - 1]) - argv[0];
+  assert(process_title.len + 1 == size);  /* argv memory should be adjacent. */
+#endif
+
   /* Add space for the argv pointers. */
   size += (argc + 1) * sizeof(char*);
 
   new_argv = uv__malloc(size);
   if (new_argv == NULL)
     return argv;
+  args_mem = new_argv;
 
   /* Copy over the strings and set up the pointer table. */
-  i = 0;
   s = (char*) &new_argv[argc + 1];
-  size = pt.cap;
-  goto loop;
-
-  for (/* empty */; i < argc; i++) {
+  for (i = 0; i < argc; i++) {
     size = strlen(argv[i]) + 1;
-  loop:
     memcpy(s, argv[i], size);
     new_argv[i] = s;
     s += size;
   }
   new_argv[i] = NULL;
 
-  /* argv is not adjacent on z/os, we use just argv[0] on that platform. */
-#ifndef __MVS__
-  pt.cap = argv[i - 1] + size - argv[0];
-#endif
-
-  args_mem = new_argv;
-  process_title = pt;
-
   return new_argv;
 }
 
 
 int uv_set_process_title(const char* title) {
-  struct uv__process_title* pt;
-  size_t len;
-
-  pt = &process_title;
-  len = strlen(title);
-
   uv_once(&process_title_mutex_once, init_process_title_mutex_once);
   uv_mutex_lock(&process_title_mutex);
 
-  if (len >= pt->cap) {
-    len = 0;
-    if (pt->cap > 0)
-      len = pt->cap - 1;
+  if (process_title.len != 0) {
+    /* No need to terminate, byte after is always '\0'. */
+    strncpy(process_title.str, title, process_title.len);
+    uv__set_process_title(title);
   }
 
-  memcpy(pt->str, title, len);
-  memset(pt->str + len, '\0', pt->cap - len);
-  pt->len = len;
-
   uv_mutex_unlock(&process_title_mutex);
 
   return 0;
@@ -145,7 +130,7 @@ int uv_get_process_title(char* buffer, s
 }
 
 
-void uv__process_title_cleanup(void) {
+UV_DESTRUCTOR(static void free_args_mem(void)) {
   uv__free(args_mem);  /* Keep valgrind happy. */
   args_mem = NULL;
 }
--- a/deps/uv/src/unix/random-devurandom.c
+++ b/deps/uv/src/unix/random-devurandom.c
@@ -37,8 +37,8 @@ int uv__random_readpath(const char* path
 
   fd = uv__open_cloexec(path, O_RDONLY);
 
-  if (fd < 0)
-    return fd;
+  if (fd == -1)
+    return UV__ERR(errno);
 
   if (fstat(fd, &s)) {
     uv__close(fd);
--- a/deps/uv/src/unix/signal.c
+++ b/deps/uv/src/unix/signal.c
@@ -77,7 +77,7 @@ static void uv__signal_global_init(void)
 }
 
 
-void uv__signal_cleanup(void) {
+UV_DESTRUCTOR(static void uv__signal_global_fini(void)) {
   /* We can only use signal-safe functions here.
    * That includes read/write and close, fortunately.
    * We do all of this directly here instead of resetting
@@ -98,7 +98,7 @@ void uv__signal_cleanup(void) {
 
 
 static void uv__signal_global_reinit(void) {
-  uv__signal_cleanup();
+  uv__signal_global_fini();
 
   if (uv__make_pipe(uv__signal_lock_pipefd, 0))
     abort();
@@ -331,7 +331,16 @@ int uv_signal_init(uv_loop_t* loop, uv_s
 
 
 void uv__signal_close(uv_signal_t* handle) {
+
   uv__signal_stop(handle);
+
+  /* If there are any caught signals "trapped" in the signal pipe, we can't
+   * call the close callback yet. Otherwise, add the handle to the finish_close
+   * queue.
+   */
+  if (handle->caught_signals == handle->dispatched_signals) {
+    uv__make_close_pending((uv_handle_t*) handle);
+  }
 }
 
 
@@ -463,6 +472,17 @@ static void uv__signal_event(uv_loop_t*
 
       if (handle->flags & UV_SIGNAL_ONE_SHOT)
         uv__signal_stop(handle);
+
+      /* If uv_close was called while there were caught signals that were not
+       * yet dispatched, the uv__finish_close was deferred. Make close pending
+       * now if this has happened.
+       */
+      if (handle->caught_signals == handle->dispatched_signals) {
+        if (handle->signum == 0)
+          uv__handle_stop(handle);
+        if (handle->flags & UV_HANDLE_CLOSING)
+          uv__make_close_pending((uv_handle_t*) handle);
+      }
     }
 
     bytes -= end;
@@ -545,12 +565,12 @@ static void uv__signal_stop(uv_signal_t*
     if (first_oneshot && !rem_oneshot) {
       ret = uv__signal_register_handler(handle->signum, 1);
       assert(ret == 0);
-      (void)ret;
     }
   }
 
   uv__signal_unlock_and_unblock(&saved_sigmask);
 
   handle->signum = 0;
-  uv__handle_stop(handle);
+  if (handle->caught_signals == handle->dispatched_signals)
+    uv__handle_stop(handle);
 }
--- a/deps/uv/src/unix/stream.c
+++ b/deps/uv/src/unix/stream.c
@@ -1048,12 +1048,7 @@ static int uv__stream_queue_fd(uv_stream
 }
 
 
-#if defined(__PASE__)
-/* on IBMi PASE the control message length can not exceed 256. */
-# define UV__CMSG_FD_COUNT 60
-#else
-# define UV__CMSG_FD_COUNT 64
-#endif
+#define UV__CMSG_FD_COUNT 64
 #define UV__CMSG_FD_SIZE (UV__CMSG_FD_COUNT * sizeof(int))
 
 
@@ -1185,6 +1180,10 @@ static void uv__read(uv_stream_t* stream
       } else if (errno == ECONNRESET && stream->type == UV_NAMED_PIPE) {
         uv__stream_eof(stream, &buf);
         return;
+#elif defined(_AIX)
+      } else if (errno == ECONNRESET && (stream->flags & UV_DISCONNECT)) {
+        uv__stream_eof(stream, &buf);
+        return;
 #endif
       } else {
         /* Error. User should call uv_close(). */
--- a/deps/uv/src/unix/tcp.c
+++ b/deps/uv/src/unix/tcp.c
@@ -379,16 +379,8 @@ int uv__tcp_keepalive(int fd, int on, un
     return UV__ERR(errno);
 
 #ifdef TCP_KEEPIDLE
-  if (on) {
-    int intvl = 1;  /*  1 second; same as default on Win32 */
-    int cnt = 10;  /* 10 retries; same as hardcoded on Win32 */
-    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay)))
-      return UV__ERR(errno);
-    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl)))
-      return UV__ERR(errno);
-    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt)))
-      return UV__ERR(errno);
-  }
+  if (on && setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay)))
+    return UV__ERR(errno);
 #endif
 
   /* Solaris/SmartOS, if you don't support keep-alive,
--- a/deps/uv/src/unix/thread.c
+++ b/deps/uv/src/unix/thread.c
@@ -172,11 +172,10 @@ static size_t thread_stack_size(void) {
 #if defined(__APPLE__) || defined(__linux__)
   struct rlimit lim;
 
-  /* getrlimit() can fail on some aarch64 systems due to a glibc bug where
-   * the system call wrapper invokes the wrong system call. Don't treat
-   * that as fatal, just use the default stack size instead.
-   */
-  if (0 == getrlimit(RLIMIT_STACK, &lim) && lim.rlim_cur != RLIM_INFINITY) {
+  if (getrlimit(RLIMIT_STACK, &lim))
+    abort();
+
+  if (lim.rlim_cur != RLIM_INFINITY) {
     /* pthread_attr_setstacksize() expects page-aligned values. */
     lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize();
 
--- a/deps/uv/src/unix/tty.c
+++ b/deps/uv/src/unix/tty.c
@@ -34,34 +34,6 @@
 #define IMAXBEL 0
 #endif
 
-#if defined(__PASE__)
-/* On IBM i PASE, for better compatibility with running interactive programs in
- * a 5250 environment, isatty() will return true for the stdin/stdout/stderr
- * streams created by QSH/QP2TERM.
- *
- * For more, see docs on PASE_STDIO_ISATTY in
- * https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_74/apis/pase_environ.htm
- *
- * This behavior causes problems for Node as it expects that if isatty() returns
- * true that TTY ioctls will be supported by that fd (which is not an
- * unreasonable expectation) and when they don't it crashes with assertion
- * errors.
- *
- * Here, we create our own version of isatty() that uses ioctl() to identify
- * whether the fd is *really* a TTY or not.
- */
-static int isreallyatty(int file) {
-  int rc;
- 
-  rc = !ioctl(file, TXISATTY + 0x81, NULL);
-  if (!rc && errno != EBADF)
-      errno = ENOTTY;
-
-  return rc;
-}
-#define isatty(fd) isreallyatty(fd)
-#endif
-
 static int orig_termios_fd = -1;
 static struct termios orig_termios;
 static uv_spinlock_t termios_spinlock = UV_SPINLOCK_INITIALIZER;
@@ -167,7 +139,7 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_
      * slave device.
      */
     if (uv__tty_is_slave(fd) && ttyname_r(fd, path, sizeof(path)) == 0)
-      r = uv__open_cloexec(path, mode | O_NOCTTY);
+      r = uv__open_cloexec(path, mode);
     else
       r = -1;
 
--- a/deps/uv/src/unix/udp.c
+++ b/deps/uv/src/unix/udp.c
@@ -32,8 +32,6 @@
 #endif
 #include <sys/un.h>
 
-#define UV__UDP_DGRAM_MAXSIZE (64 * 1024)
-
 #if defined(IPV6_JOIN_GROUP) && !defined(IPV6_ADD_MEMBERSHIP)
 # define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP
 #endif
@@ -42,11 +40,6 @@
 # define IPV6_DROP_MEMBERSHIP IPV6_LEAVE_GROUP
 #endif
 
-union uv__sockaddr {
-  struct sockaddr_in6 in6;
-  struct sockaddr_in in;
-  struct sockaddr addr;
-};
 
 static void uv__udp_run_completed(uv_udp_t* handle);
 static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents);
@@ -56,36 +49,6 @@ static int uv__udp_maybe_deferred_bind(u
                                        int domain,
                                        unsigned int flags);
 
-#if HAVE_MMSG
-
-#define UV__MMSG_MAXWIDTH 20
-
-static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf);
-static void uv__udp_sendmmsg(uv_udp_t* handle);
-
-static int uv__recvmmsg_avail;
-static int uv__sendmmsg_avail;
-static uv_once_t once = UV_ONCE_INIT;
-
-static void uv__udp_mmsg_init(void) {
-  int ret;
-  int s;
-  s = uv__socket(AF_INET, SOCK_DGRAM, 0);
-  if (s < 0)
-    return;
-  ret = uv__sendmmsg(s, NULL, 0, 0);
-  if (ret == 0 || errno != ENOSYS) {
-    uv__sendmmsg_avail = 1;
-    uv__recvmmsg_avail = 1;
-  } else {
-    ret = uv__recvmmsg(s, NULL, 0, 0, NULL);
-    if (ret == 0 || errno != ENOSYS)
-      uv__recvmmsg_avail = 1;
-  }
-  uv__close(s);
-}
-
-#endif
 
 void uv__udp_close(uv_udp_t* handle) {
   uv__io_close(handle->loop, &handle->io_watcher);
@@ -185,64 +148,6 @@ static void uv__udp_io(uv_loop_t* loop,
   }
 }
 
-#if HAVE_MMSG
-static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
-  struct sockaddr_in6 peers[UV__MMSG_MAXWIDTH];
-  struct iovec iov[UV__MMSG_MAXWIDTH];
-  struct uv__mmsghdr msgs[UV__MMSG_MAXWIDTH];
-  ssize_t nread;
-  uv_buf_t chunk_buf;
-  size_t chunks;
-  int flags;
-  size_t k;
-
-  /* prepare structures for recvmmsg */
-  chunks = buf->len / UV__UDP_DGRAM_MAXSIZE;
-  if (chunks > ARRAY_SIZE(iov))
-    chunks = ARRAY_SIZE(iov);
-  for (k = 0; k < chunks; ++k) {
-    iov[k].iov_base = buf->base + k * UV__UDP_DGRAM_MAXSIZE;
-    iov[k].iov_len = UV__UDP_DGRAM_MAXSIZE;
-    msgs[k].msg_hdr.msg_iov = iov + k;
-    msgs[k].msg_hdr.msg_iovlen = 1;
-    msgs[k].msg_hdr.msg_name = peers + k;
-    msgs[k].msg_hdr.msg_namelen = sizeof(peers[0]);
-    msgs[k].msg_hdr.msg_control = NULL;
-    msgs[k].msg_hdr.msg_controllen = 0;
-    msgs[k].msg_hdr.msg_flags = 0;
-  }
-
-  do
-    nread = uv__recvmmsg(handle->io_watcher.fd, msgs, chunks, 0, NULL);
-  while (nread == -1 && errno == EINTR);
-
-  if (nread < 1) {
-    if (nread == 0 || errno == EAGAIN || errno == EWOULDBLOCK)
-      handle->recv_cb(handle, 0, buf, NULL, 0);
-    else
-      handle->recv_cb(handle, UV__ERR(errno), buf, NULL, 0);
-  } else {
-    /* pass each chunk to the application */
-    for (k = 0; k < (size_t) nread && handle->recv_cb != NULL; k++) {
-      flags = UV_UDP_MMSG_CHUNK;
-      if (msgs[k].msg_hdr.msg_flags & MSG_TRUNC)
-        flags |= UV_UDP_PARTIAL;
-
-      chunk_buf = uv_buf_init(iov[k].iov_base, iov[k].iov_len);
-      handle->recv_cb(handle,
-                      msgs[k].msg_len,
-                      &chunk_buf,
-                      msgs[k].msg_hdr.msg_name,
-                      flags);
-    }
-
-    /* one last callback so the original buffer is freed */
-    if (handle->recv_cb != NULL)
-      handle->recv_cb(handle, 0, buf, NULL, 0);
-  }
-  return nread;
-}
-#endif
 
 static void uv__udp_recvmsg(uv_udp_t* handle) {
   struct sockaddr_storage peer;
@@ -262,25 +167,13 @@ static void uv__udp_recvmsg(uv_udp_t* ha
 
   do {
     buf = uv_buf_init(NULL, 0);
-    handle->alloc_cb((uv_handle_t*) handle, UV__UDP_DGRAM_MAXSIZE, &buf);
+    handle->alloc_cb((uv_handle_t*) handle, 64 * 1024, &buf);
     if (buf.base == NULL || buf.len == 0) {
       handle->recv_cb(handle, UV_ENOBUFS, &buf, NULL, 0);
       return;
     }
     assert(buf.base != NULL);
 
-#if HAVE_MMSG
-    if (handle->flags & UV_HANDLE_UDP_RECVMMSG) {
-      uv_once(&once, uv__udp_mmsg_init);
-      if (uv__recvmmsg_avail) {
-        nread = uv__udp_recvmmsg(handle, &buf);
-        if (nread > 0)
-          count -= nread;
-        continue;
-      }
-    }
-#endif
-
     memset(&h, 0, sizeof(h));
     memset(&peer, 0, sizeof(peer));
     h.msg_name = &peer;
@@ -306,120 +199,21 @@ static void uv__udp_recvmsg(uv_udp_t* ha
 
       handle->recv_cb(handle, nread, &buf, (const struct sockaddr*) &peer, flags);
     }
-    count--;
   }
   /* recv_cb callback may decide to pause or close the handle */
   while (nread != -1
-      && count > 0
+      && count-- > 0
       && handle->io_watcher.fd != -1
       && handle->recv_cb != NULL);
 }
 
-#if HAVE_MMSG
-static void uv__udp_sendmmsg(uv_udp_t* handle) {
-  uv_udp_send_t* req;
-  struct uv__mmsghdr h[UV__MMSG_MAXWIDTH];
-  struct uv__mmsghdr *p;
-  QUEUE* q;
-  ssize_t npkts;
-  size_t pkts;
-  size_t i;
-
-  if (QUEUE_EMPTY(&handle->write_queue))
-    return;
-
-write_queue_drain:
-  for (pkts = 0, q = QUEUE_HEAD(&handle->write_queue);
-       pkts < UV__MMSG_MAXWIDTH && q != &handle->write_queue;
-       ++pkts, q = QUEUE_HEAD(q)) {
-    assert(q != NULL);
-    req = QUEUE_DATA(q, uv_udp_send_t, queue);
-    assert(req != NULL);
-
-    p = &h[pkts];
-    memset(p, 0, sizeof(*p));
-    if (req->addr.ss_family == AF_UNSPEC) {
-      p->msg_hdr.msg_name = NULL;
-      p->msg_hdr.msg_namelen = 0;
-    } else {
-      p->msg_hdr.msg_name = &req->addr;
-      if (req->addr.ss_family == AF_INET6)
-        p->msg_hdr.msg_namelen = sizeof(struct sockaddr_in6);
-      else if (req->addr.ss_family == AF_INET)
-        p->msg_hdr.msg_namelen = sizeof(struct sockaddr_in);
-      else if (req->addr.ss_family == AF_UNIX)
-        p->msg_hdr.msg_namelen = sizeof(struct sockaddr_un);
-      else {
-        assert(0 && "unsupported address family");
-        abort();
-      }
-    }
-    h[pkts].msg_hdr.msg_iov = (struct iovec*) req->bufs;
-    h[pkts].msg_hdr.msg_iovlen = req->nbufs;
-  }
-
-  do
-    npkts = uv__sendmmsg(handle->io_watcher.fd, h, pkts, 0);
-  while (npkts == -1 && errno == EINTR);
-
-  if (npkts < 1) {
-    if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)
-      return;
-    for (i = 0, q = QUEUE_HEAD(&handle->write_queue);
-         i < pkts && q != &handle->write_queue;
-         ++i, q = QUEUE_HEAD(q)) {
-      assert(q != NULL);
-      req = QUEUE_DATA(q, uv_udp_send_t, queue);
-      assert(req != NULL);
-
-      req->status = UV__ERR(errno);
-      QUEUE_REMOVE(&req->queue);
-      QUEUE_INSERT_TAIL(&handle->write_completed_queue, &req->queue);
-    }
-    uv__io_feed(handle->loop, &handle->io_watcher);
-    return;
-  }
-
-  for (i = 0, q = QUEUE_HEAD(&handle->write_queue);
-       i < pkts && q != &handle->write_queue;
-       ++i, q = QUEUE_HEAD(&handle->write_queue)) {
-    assert(q != NULL);
-    req = QUEUE_DATA(q, uv_udp_send_t, queue);
-    assert(req != NULL);
-
-    req->status = req->bufs[0].len;
-
-    /* Sending a datagram is an atomic operation: either all data
-     * is written or nothing is (and EMSGSIZE is raised). That is
-     * why we don't handle partial writes. Just pop the request
-     * off the write queue and onto the completed queue, done.
-     */
-    QUEUE_REMOVE(&req->queue);
-    QUEUE_INSERT_TAIL(&handle->write_completed_queue, &req->queue);
-  }
-
-  /* couldn't batch everything, continue sending (jump to avoid stack growth) */
-  if (!QUEUE_EMPTY(&handle->write_queue))
-    goto write_queue_drain;
-  uv__io_feed(handle->loop, &handle->io_watcher);
-  return;
-}
-#endif
 
 static void uv__udp_sendmsg(uv_udp_t* handle) {
   uv_udp_send_t* req;
-  struct msghdr h;
   QUEUE* q;
+  struct msghdr h;
   ssize_t size;
 
-#if HAVE_MMSG
-  uv_once(&once, uv__udp_mmsg_init);
-  if (uv__sendmmsg_avail) {
-    uv__udp_sendmmsg(handle);
-    return;
-  }
-#endif
-
   while (!QUEUE_EMPTY(&handle->write_queue)) {
     q = QUEUE_HEAD(&handle->write_queue);
     assert(q != NULL);
@@ -469,6 +263,7 @@ static void uv__udp_sendmsg(uv_udp_t* ha
   }
 }
 
+
 /* On the BSDs, SO_REUSEPORT implies SO_REUSEADDR but with some additional
  * refinements for programs that use multicast.
  *
@@ -572,7 +367,11 @@ int uv__udp_bind(uv_udp_t* handle,
 static int uv__udp_maybe_deferred_bind(uv_udp_t* handle,
                                        int domain,
                                        unsigned int flags) {
-  union uv__sockaddr taddr;
+  union {
+    struct sockaddr_in6 in6;
+    struct sockaddr_in in;
+    struct sockaddr addr;
+  } taddr;
   socklen_t addrlen;
 
   if (handle->io_watcher.fd != -1)
@@ -854,7 +653,7 @@ static int uv__udp_set_membership6(uv_ud
 }
 
 
-#if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__ANDROID__)
+#if !defined(__OpenBSD__) && !defined(__NetBSD__)
 static int uv__udp_set_source_membership4(uv_udp_t* handle,
                                           const struct sockaddr_in* multicast_addr,
                                           const char* interface_addr,
@@ -925,10 +724,8 @@ static int uv__udp_set_source_membership
     mreq.gsr_interface = 0;
   }
 
-  STATIC_ASSERT(sizeof(mreq.gsr_group) >= sizeof(*multicast_addr));
-  STATIC_ASSERT(sizeof(mreq.gsr_source) >= sizeof(*source_addr));
-  memcpy(&mreq.gsr_group, multicast_addr, sizeof(*multicast_addr));
-  memcpy(&mreq.gsr_source, source_addr, sizeof(*source_addr));
+  memcpy(&mreq.gsr_group, multicast_addr, sizeof(mreq.gsr_group));
+  memcpy(&mreq.gsr_source, source_addr, sizeof(mreq.gsr_source));
 
   if (membership == UV_JOIN_GROUP)
     optname = MCAST_JOIN_SOURCE_GROUP;
@@ -950,17 +747,26 @@ static int uv__udp_set_source_membership
 #endif
 
 
-int uv__udp_init_ex(uv_loop_t* loop,
-                    uv_udp_t* handle,
-                    unsigned flags,
-                    int domain) {
+int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned int flags) {
+  int domain;
+  int err;
   int fd;
 
-  fd = -1;
+  /* Use the lower 8 bits for the domain */
+  domain = flags & 0xFF;
+  if (domain != AF_INET && domain != AF_INET6 && domain != AF_UNSPEC)
+    return UV_EINVAL;
+
+  if (flags & ~0xFF)
+    return UV_EINVAL;
+
   if (domain != AF_UNSPEC) {
-    fd = uv__socket(domain, SOCK_DGRAM, 0);
-    if (fd < 0)
-      return fd;
+    err = uv__socket(domain, SOCK_DGRAM, 0);
+    if (err < 0)
+      return err;
+    fd = err;
+  } else {
+    fd = -1;
   }
 
   uv__handle_init(loop, (uv_handle_t*)handle, UV_UDP);
@@ -976,6 +782,11 @@ int uv__udp_init_ex(uv_loop_t* loop,
 }
 
 
+int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {
+  return uv_udp_init_ex(loop, handle, AF_UNSPEC);
+}
+
+
 int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {
   int err;
 
@@ -1031,33 +842,42 @@ int uv_udp_set_source_membership(uv_udp_
                                  const char* interface_addr,
                                  const char* source_addr,
                                  uv_membership membership) {
-#if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__ANDROID__)
+#if !defined(__OpenBSD__) && !defined(__NetBSD__)
   int err;
-  union uv__sockaddr mcast_addr;
-  union uv__sockaddr src_addr;
+  struct sockaddr_storage mcast_addr;
+  struct sockaddr_in* mcast_addr4;
+  struct sockaddr_in6* mcast_addr6;
+  struct sockaddr_storage src_addr;
+  struct sockaddr_in* src_addr4;
+  struct sockaddr_in6* src_addr6;
+
+  mcast_addr4 = (struct sockaddr_in*)&mcast_addr;
+  mcast_addr6 = (struct sockaddr_in6*)&mcast_addr;
+  src_addr4 = (struct sockaddr_in*)&src_addr;
+  src_addr6 = (struct sockaddr_in6*)&src_addr;
 
-  err = uv_ip4_addr(multicast_addr, 0, &mcast_addr.in);
+  err = uv_ip4_addr(multicast_addr, 0, mcast_addr4);
   if (err) {
-    err = uv_ip6_addr(multicast_addr, 0, &mcast_addr.in6);
+    err = uv_ip6_addr(multicast_addr, 0, mcast_addr6);
     if (err)
       return err;
-    err = uv_ip6_addr(source_addr, 0, &src_addr.in6);
+    err = uv_ip6_addr(source_addr, 0, src_addr6);
     if (err)
       return err;
     return uv__udp_set_source_membership6(handle,
-                                          &mcast_addr.in6,
+                                          mcast_addr6,
                                           interface_addr,
-                                          &src_addr.in6,
+                                          src_addr6,
                                           membership);
   }
-
-  err = uv_ip4_addr(source_addr, 0, &src_addr.in);
+  
+  err = uv_ip4_addr(source_addr, 0, src_addr4);
   if (err)
     return err;
   return uv__udp_set_source_membership4(handle,
-                                        &mcast_addr.in,
+                                        mcast_addr4,
                                         interface_addr,
-                                        &src_addr.in,
+                                        src_addr4,
                                         membership);
 #else
   return UV_ENOSYS;
@@ -1069,7 +889,7 @@ static int uv__setsockopt(uv_udp_t* hand
                          int option4,
                          int option6,
                          const void* val,
-                         socklen_t size) {
+                         size_t size) {
   int r;
 
   if (handle->flags & UV_HANDLE_IPV6)
@@ -1192,7 +1012,7 @@ int uv_udp_set_multicast_loop(uv_udp_t*
  * and use the general uv__setsockopt_maybe_char call otherwise.
  */
 #if defined(__sun) || defined(_AIX) || defined(__OpenBSD__) || \
-    defined(__MVS__)
+    defined(__MVS__) 
   if (handle->flags & UV_HANDLE_IPV6)
     return uv__setsockopt(handle,
                           IP_MULTICAST_LOOP,
--- a/deps/uv/src/uv-common.c
+++ b/deps/uv/src/uv-common.c
@@ -100,17 +100,6 @@ void* uv__realloc(void* ptr, size_t size
   return NULL;
 }
 
-void* uv__reallocf(void* ptr, size_t size) {
-  void* newptr;
-
-  newptr = uv__realloc(ptr, size);
-  if (newptr == NULL)
-    if (size > 0)
-      uv__free(ptr);
-
-  return newptr;
-}
-
 int uv_replace_allocator(uv_malloc_func malloc_func,
                          uv_realloc_func realloc_func,
                          uv_calloc_func calloc_func,
@@ -293,36 +282,6 @@ int uv_tcp_bind(uv_tcp_t* handle,
 }
 
 
-int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned flags) {
-  unsigned extra_flags;
-  int domain;
-  int rc;
-
-  /* Use the lower 8 bits for the domain. */
-  domain = flags & 0xFF;
-  if (domain != AF_INET && domain != AF_INET6 && domain != AF_UNSPEC)
-    return UV_EINVAL;
-
-  /* Use the higher bits for extra flags. */
-  extra_flags = flags & ~0xFF;
-  if (extra_flags & ~UV_UDP_RECVMMSG)
-    return UV_EINVAL;
-
-  rc = uv__udp_init_ex(loop, handle, flags, domain);
-
-  if (rc == 0)
-    if (extra_flags & UV_UDP_RECVMMSG)
-      handle->flags |= UV_HANDLE_UDP_RECVMMSG;
-
-  return rc;
-}
-
-
-int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {
-  return uv_udp_init_ex(loop, handle, AF_UNSPEC);
-}
-
-
 int uv_udp_bind(uv_udp_t* handle,
                 const struct sockaddr* addr,
                 unsigned int flags) {
@@ -851,19 +810,3 @@ void uv_free_cpu_info(uv_cpu_info_t* cpu
 
   uv__free(cpu_infos);
 }
-
-
-#ifdef __GNUC__  /* Also covers __clang__ and __INTEL_COMPILER. */
-__attribute__((destructor))
-#endif
-void uv_library_shutdown(void) {
-  static int was_shutdown;
-
-  if (was_shutdown)
-    return;
-
-  uv__process_title_cleanup();
-  uv__signal_cleanup();
-  uv__threadpool_cleanup();
-  was_shutdown = 1;
-}
--- a/deps/uv/src/uv-common.h
+++ b/deps/uv/src/uv-common.h
@@ -104,7 +104,6 @@ enum {
   /* Only used by uv_udp_t handles. */
   UV_HANDLE_UDP_PROCESSING              = 0x01000000,
   UV_HANDLE_UDP_CONNECTED               = 0x02000000,
-  UV_HANDLE_UDP_RECVMMSG                = 0x04000000,
 
   /* Only used by uv_pipe_t handles. */
   UV_HANDLE_NON_OVERLAPPED_PIPE         = 0x01000000,
@@ -139,11 +138,6 @@ int uv__tcp_connect(uv_connect_t* req,
                    unsigned int addrlen,
                    uv_connect_cb cb);
 
-int uv__udp_init_ex(uv_loop_t* loop,
-                    uv_udp_t* handle,
-                    unsigned flags,
-                    int domain);
-
 int uv__udp_bind(uv_udp_t* handle,
                  const struct sockaddr* addr,
                  unsigned int  addrlen,
@@ -206,10 +200,6 @@ int uv__next_timeout(const uv_loop_t* lo
 void uv__run_timers(uv_loop_t* loop);
 void uv__timer_close(uv_timer_t* handle);
 
-void uv__process_title_cleanup(void);
-void uv__signal_cleanup(void);
-void uv__threadpool_cleanup(void);
-
 #define uv__has_active_reqs(loop)                                             \
   ((loop)->active_reqs.count > 0)
 
@@ -332,6 +322,5 @@ char *uv__strndup(const char* s, size_t
 void* uv__malloc(size_t size);
 void uv__free(void* ptr);
 void* uv__realloc(void* ptr, size_t size);
-void* uv__reallocf(void* ptr, size_t size);
 
 #endif /* UV_COMMON_H_ */
--- a/deps/uv/src/win/core.c
+++ b/deps/uv/src/win/core.c
@@ -321,13 +321,8 @@ void uv__loop_close(uv_loop_t* loop) {
 
   uv__loops_remove(loop);
 
-  /* Close the async handle without needing an extra loop iteration.
-   * We might have a pending message, but we're just going to destroy the IOCP
-   * soon, so we can just discard it now without the usual risk of a getting
-   * another notification from GetQueuedCompletionStatusEx after calling the
-   * close_cb (which we also skip defining). We'll assert later that queue was
-   * actually empty and all reqs handled. */
-  loop->wq_async.async_sent = 0;
+  /* close the async handle without needing an extra loop iteration */
+  assert(!loop->wq_async.async_sent);
   loop->wq_async.close_cb = NULL;
   uv__handle_closing(&loop->wq_async);
   uv__handle_close(&loop->wq_async);
@@ -449,12 +444,12 @@ static void uv__poll(uv_loop_t* loop, DW
   timeout_time = loop->time + timeout;
 
   for (repeat = 0; ; repeat++) {
-    success = pGetQueuedCompletionStatusEx(loop->iocp,
-                                           overlappeds,
-                                           ARRAY_SIZE(overlappeds),
-                                           &count,
-                                           timeout,
-                                           FALSE);
+    success = GetQueuedCompletionStatusEx(loop->iocp,
+                                          overlappeds,
+                                          ARRAY_SIZE(overlappeds),
+                                          &count,
+                                          timeout,
+                                          FALSE);
 
     if (success) {
       for (i = 0; i < count; i++) {
--- a/deps/uv/src/win/error.c
+++ b/deps/uv/src/win/error.c
@@ -72,7 +72,6 @@ int uv_translate_sys_error(int sys_errno
     case ERROR_NOACCESS:                    return UV_EACCES;
     case WSAEACCES:                         return UV_EACCES;
     case ERROR_ELEVATION_REQUIRED:          return UV_EACCES;
-    case ERROR_CANT_ACCESS_FILE:            return UV_EACCES;
     case ERROR_ADDRESS_ALREADY_ASSOCIATED:  return UV_EADDRINUSE;
     case WSAEADDRINUSE:                     return UV_EADDRINUSE;
     case WSAEADDRNOTAVAIL:                  return UV_EADDRNOTAVAIL;
--- a/deps/uv/src/win/fs.c
+++ b/deps/uv/src/win/fs.c
@@ -257,7 +257,6 @@ INLINE static void uv_fs_req_init(uv_loo
   req->loop = loop;
   req->flags = 0;
   req->fs_type = fs_type;
-  req->sys_errno_ = 0;
   req->result = 0;
   req->ptr = NULL;
   req->path = NULL;
@@ -322,8 +321,6 @@ INLINE static int fs__readlink_handle(HA
   WCHAR* w_target;
   DWORD w_target_len;
   DWORD bytes;
-  size_t i;
-  size_t len;
 
   if (!DeviceIoControl(handle,
                        FSCTL_GET_REPARSE_POINT,
@@ -408,38 +405,6 @@ INLINE static int fs__readlink_handle(HA
     w_target += 4;
     w_target_len -= 4;
 
-  } else if (reparse_data->ReparseTag == IO_REPARSE_TAG_APPEXECLINK) {
-    /* String #3 in the list has the target filename. */
-    if (reparse_data->AppExecLinkReparseBuffer.StringCount < 3) {
-      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);
-      return -1;
-    }
-    w_target = reparse_data->AppExecLinkReparseBuffer.StringList;
-    /* The StringList buffer contains a list of strings separated by "\0",   */
-    /* with "\0\0" terminating the list. Move to the 3rd string in the list: */
-    for (i = 0; i < 2; ++i) {
-      len = wcslen(w_target);
-      if (len == 0) {
-        SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);
-        return -1;
-      }
-      w_target += len + 1;
-    }
-    w_target_len = wcslen(w_target);
-    if (w_target_len == 0) {
-      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);
-      return -1;
-    }
-    /* Make sure it is an absolute path. */
-    if (!(w_target_len >= 3 &&
-         ((w_target[0] >= L'a' && w_target[0] <= L'z') ||
-          (w_target[0] >= L'A' && w_target[0] <= L'Z')) &&
-         w_target[1] == L':' &&
-         w_target[2] == L'\\')) {
-      SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);
-      return -1;
-    }
-
   } else {
     /* Reparse tag does not indicate a symlink. */
     SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);
@@ -2260,66 +2225,32 @@ INLINE static int fs__utime_handle(HANDL
   return 0;
 }
 
-INLINE static DWORD fs__utime_impl_from_path(WCHAR* path,
-                                             double atime,
-                                             double mtime,
-                                             int do_lutime) {
-  HANDLE handle;
-  DWORD flags;
-  DWORD ret;
 
-  flags = FILE_FLAG_BACKUP_SEMANTICS;
-  if (do_lutime) {
-    flags |= FILE_FLAG_OPEN_REPARSE_POINT;
-  }
+static void fs__utime(uv_fs_t* req) {
+  HANDLE handle;
 
-  handle = CreateFileW(path,
+  handle = CreateFileW(req->file.pathw,
                        FILE_WRITE_ATTRIBUTES,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
-                       flags,
+                       FILE_FLAG_BACKUP_SEMANTICS,
                        NULL);
 
   if (handle == INVALID_HANDLE_VALUE) {
-    ret = GetLastError();
-  } else if (fs__utime_handle(handle, atime, mtime) != 0) {
-    ret = GetLastError();
-  } else {
-    ret = 0;
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    return;
   }
 
-  CloseHandle(handle);
-  return ret;
-}
-
-INLINE static void fs__utime_impl(uv_fs_t* req, int do_lutime) {
-  DWORD error;
-
-  error = fs__utime_impl_from_path(req->file.pathw,
-                                   req->fs.time.atime,
-                                   req->fs.time.mtime,
-                                   do_lutime);
-
-  if (error != 0) {
-    if (do_lutime &&
-        (error == ERROR_SYMLINK_NOT_SUPPORTED ||
-         error == ERROR_NOT_A_REPARSE_POINT)) {
-      /* Opened file is a reparse point but not a symlink. Try again. */
-      fs__utime_impl(req, 0);
-    } else {
-      /* utime failed. */
-      SET_REQ_WIN32_ERROR(req, error);
-    }
-
+  if (fs__utime_handle(handle, req->fs.time.atime, req->fs.time.mtime) != 0) {
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    CloseHandle(handle);
     return;
   }
 
-  req->result = 0;
-}
+  CloseHandle(handle);
 
-static void fs__utime(uv_fs_t* req) {
-  fs__utime_impl(req, /* do_lutime */ 0);
+  req->result = 0;
 }
 
 
@@ -2343,10 +2274,6 @@ static void fs__futime(uv_fs_t* req) {
   req->result = 0;
 }
 
-static void fs__lutime(uv_fs_t* req) {
-  fs__utime_impl(req, /* do_lutime */ 1);
-}
-
 
 static void fs__link(uv_fs_t* req) {
   DWORD r = CreateHardLinkW(req->fs.info.new_pathw, req->file.pathw, NULL);
@@ -2694,62 +2621,14 @@ static void fs__statfs(uv_fs_t* req) {
   DWORD bytes_per_sector;
   DWORD free_clusters;
   DWORD total_clusters;
-  WCHAR* pathw;
 
-  pathw = req->file.pathw;
-retry_get_disk_free_space:
-  if (0 == GetDiskFreeSpaceW(pathw,
+  if (0 == GetDiskFreeSpaceW(req->file.pathw,
                              &sectors_per_cluster,
                              &bytes_per_sector,
                              &free_clusters,
                              &total_clusters)) {
-    DWORD err;
-    WCHAR* fpart;
-    size_t len;
-    DWORD ret;
-    BOOL is_second;
-
-    err = GetLastError();
-    is_second = pathw != req->file.pathw;
-    if (err != ERROR_DIRECTORY || is_second) {
-      if (is_second)
-        uv__free(pathw);
-
-      SET_REQ_WIN32_ERROR(req, err);
-      return;
-    }
-
-    len = MAX_PATH + 1;
-    pathw = uv__malloc(len * sizeof(*pathw));
-    if (pathw == NULL) {
-      SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
-      return;
-    }
-retry_get_full_path_name:
-    ret = GetFullPathNameW(req->file.pathw,
-                           len,
-                           pathw,
-                           &fpart);
-    if (ret == 0) {
-      uv__free(pathw);
-      SET_REQ_WIN32_ERROR(req, err);
-      return;
-    } else if (ret > len) {
-      len = ret;
-      pathw = uv__reallocf(pathw, len * sizeof(*pathw));
-      if (pathw == NULL) {
-        SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
-        return;
-      }
-      goto retry_get_full_path_name;
-    }
-    if (fpart != 0)
-      *fpart = L'\0';
-
-    goto retry_get_disk_free_space;
-  }
-  if (pathw != req->file.pathw) {
-    uv__free(pathw);
+    SET_REQ_WIN32_ERROR(req, GetLastError());
+    return;
   }
 
   stat_fs = uv__malloc(sizeof(*stat_fs));
@@ -2791,7 +2670,6 @@ static void uv__fs_work(struct uv__work*
     XX(FTRUNCATE, ftruncate)
     XX(UTIME, utime)
     XX(FUTIME, futime)
-    XX(LUTIME, lutime)
     XX(ACCESS, access)
     XX(CHMOD, chmod)
     XX(FCHMOD, fchmod)
@@ -2875,8 +2753,7 @@ int uv_fs_open(uv_loop_t* loop, uv_fs_t*
   INIT(UV_FS_OPEN);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   req->fs.info.file_flags = flags;
@@ -2901,10 +2778,8 @@ int uv_fs_read(uv_loop_t* loop,
                uv_fs_cb cb) {
   INIT(UV_FS_READ);
 
-  if (bufs == NULL || nbufs == 0) {
-    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);
+  if (bufs == NULL || nbufs == 0)
     return UV_EINVAL;
-  }
 
   req->file.fd = fd;
 
@@ -2913,10 +2788,8 @@ int uv_fs_read(uv_loop_t* loop,
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
     req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
 
-  if (req->fs.info.bufs == NULL) {
-    SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
+  if (req->fs.info.bufs == NULL)
     return UV_ENOMEM;
-  }
 
   memcpy(req->fs.info.bufs, bufs, nbufs * sizeof(*bufs));
 
@@ -2934,10 +2807,8 @@ int uv_fs_write(uv_loop_t* loop,
                 uv_fs_cb cb) {
   INIT(UV_FS_WRITE);
 
-  if (bufs == NULL || nbufs == 0) {
-    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);
+  if (bufs == NULL || nbufs == 0)
     return UV_EINVAL;
-  }
 
   req->file.fd = fd;
 
@@ -2946,10 +2817,8 @@ int uv_fs_write(uv_loop_t* loop,
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
     req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
 
-  if (req->fs.info.bufs == NULL) {
-    SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
+  if (req->fs.info.bufs == NULL)
     return UV_ENOMEM;
-  }
 
   memcpy(req->fs.info.bufs, bufs, nbufs * sizeof(*bufs));
 
@@ -2965,8 +2834,7 @@ int uv_fs_unlink(uv_loop_t* loop, uv_fs_
   INIT(UV_FS_UNLINK);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -2980,8 +2848,7 @@ int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t
   INIT(UV_FS_MKDIR);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   req->fs.info.mode = mode;
@@ -2997,10 +2864,8 @@ int uv_fs_mkdtemp(uv_loop_t* loop,
 
   INIT(UV_FS_MKDTEMP);
   err = fs__capture_path(req, tpl, NULL, TRUE);
-  if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
-  }
+  if (err)
+    return uv_translate_sys_error(err);
 
   POST;
 }
@@ -3014,10 +2879,8 @@ int uv_fs_mkstemp(uv_loop_t* loop,
 
   INIT(UV_FS_MKSTEMP);
   err = fs__capture_path(req, tpl, NULL, TRUE);
-  if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
-  }
+  if (err)
+    return uv_translate_sys_error(err);
 
   POST;
 }
@@ -3029,8 +2892,7 @@ int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t
   INIT(UV_FS_RMDIR);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3044,8 +2906,7 @@ int uv_fs_scandir(uv_loop_t* loop, uv_fs
   INIT(UV_FS_SCANDIR);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   req->fs.info.file_flags = flags;
@@ -3060,10 +2921,8 @@ int uv_fs_opendir(uv_loop_t* loop,
 
   INIT(UV_FS_OPENDIR);
   err = fs__capture_path(req, path, NULL, cb != NULL);
-  if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
-  }
+  if (err)
+    return uv_translate_sys_error(err);
   POST;
 }
 
@@ -3076,7 +2935,6 @@ int uv_fs_readdir(uv_loop_t* loop,
   if (dir == NULL ||
       dir->dirents == NULL ||
       dir->dir_handle == INVALID_HANDLE_VALUE) {
-    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);
     return UV_EINVAL;
   }
 
@@ -3089,10 +2947,8 @@ int uv_fs_closedir(uv_loop_t* loop,
                    uv_dir_t* dir,
                    uv_fs_cb cb) {
   INIT(UV_FS_CLOSEDIR);
-  if (dir == NULL) {
-    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);
+  if (dir == NULL)
     return UV_EINVAL;
-  }
   req->ptr = dir;
   POST;
 }
@@ -3104,8 +2960,7 @@ int uv_fs_link(uv_loop_t* loop, uv_fs_t*
   INIT(UV_FS_LINK);
   err = fs__capture_path(req, path, new_path, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3119,8 +2974,7 @@ int uv_fs_symlink(uv_loop_t* loop, uv_fs
   INIT(UV_FS_SYMLINK);
   err = fs__capture_path(req, path, new_path, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   req->fs.info.file_flags = flags;
@@ -3135,8 +2989,7 @@ int uv_fs_readlink(uv_loop_t* loop, uv_f
   INIT(UV_FS_READLINK);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3150,14 +3003,12 @@ int uv_fs_realpath(uv_loop_t* loop, uv_f
   INIT(UV_FS_REALPATH);
 
   if (!path) {
-    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);
     return UV_EINVAL;
   }
 
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3171,8 +3022,7 @@ int uv_fs_chown(uv_loop_t* loop, uv_fs_t
   INIT(UV_FS_CHOWN);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3193,10 +3043,8 @@ int uv_fs_lchown(uv_loop_t* loop, uv_fs_
   INIT(UV_FS_LCHOWN);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
-
   POST;
 }
 
@@ -3207,8 +3055,7 @@ int uv_fs_stat(uv_loop_t* loop, uv_fs_t*
   INIT(UV_FS_STAT);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3221,8 +3068,7 @@ int uv_fs_lstat(uv_loop_t* loop, uv_fs_t
   INIT(UV_FS_LSTAT);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3243,8 +3089,7 @@ int uv_fs_rename(uv_loop_t* loop, uv_fs_
   INIT(UV_FS_RENAME);
   err = fs__capture_path(req, path, new_path, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   POST;
@@ -3287,15 +3132,13 @@ int uv_fs_copyfile(uv_loop_t* loop,
   if (flags & ~(UV_FS_COPYFILE_EXCL |
                 UV_FS_COPYFILE_FICLONE |
                 UV_FS_COPYFILE_FICLONE_FORCE)) {
-    SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);
     return UV_EINVAL;
   }
 
   err = fs__capture_path(req, path, new_path, cb != NULL);
-  if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
-  }
+
+  if (err)
+    return uv_translate_sys_error(err);
 
   req->fs.info.file_flags = flags;
   POST;
@@ -3322,10 +3165,8 @@ int uv_fs_access(uv_loop_t* loop,
 
   INIT(UV_FS_ACCESS);
   err = fs__capture_path(req, path, NULL, cb != NULL);
-  if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
-  }
+  if (err)
+    return uv_translate_sys_error(err);
 
   req->fs.info.mode = flags;
   POST;
@@ -3339,8 +3180,7 @@ int uv_fs_chmod(uv_loop_t* loop, uv_fs_t
   INIT(UV_FS_CHMOD);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   req->fs.info.mode = mode;
@@ -3364,8 +3204,7 @@ int uv_fs_utime(uv_loop_t* loop, uv_fs_t
   INIT(UV_FS_UTIME);
   err = fs__capture_path(req, path, NULL, cb != NULL);
   if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
+    return uv_translate_sys_error(err);
   }
 
   req->fs.time.atime = atime;
@@ -3383,22 +3222,6 @@ int uv_fs_futime(uv_loop_t* loop, uv_fs_
   POST;
 }
 
-int uv_fs_lutime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,
-    double mtime, uv_fs_cb cb) {
-  int err;
-
-  INIT(UV_FS_LUTIME);
-  err = fs__capture_path(req, path, NULL, cb != NULL);
-  if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
-  }
-
-  req->fs.time.atime = atime;
-  req->fs.time.mtime = mtime;
-  POST;
-}
-
 
 int uv_fs_statfs(uv_loop_t* loop,
                  uv_fs_t* req,
@@ -3408,14 +3231,8 @@ int uv_fs_statfs(uv_loop_t* loop,
 
   INIT(UV_FS_STATFS);
   err = fs__capture_path(req, path, NULL, cb != NULL);
-  if (err) {
-    SET_REQ_WIN32_ERROR(req, err);
-    return req->result;
-  }
+  if (err)
+    return uv_translate_sys_error(err);
 
   POST;
 }
-
-int uv_fs_get_system_error(const uv_fs_t* req) {
-  return req->sys_errno_;
-}
--- a/deps/uv/src/win/fs-event.c
+++ b/deps/uv/src/win/fs-event.c
@@ -83,7 +83,6 @@ static void uv_relative_path(const WCHAR
 static int uv_split_path(const WCHAR* filename, WCHAR** dir,
     WCHAR** file) {
   size_t len, i;
-  DWORD dir_len;
 
   if (filename == NULL) {
     if (dir != NULL)
@@ -98,16 +97,12 @@ static int uv_split_path(const WCHAR* fi
 
   if (i == 0) {
     if (dir) {
-      dir_len = GetCurrentDirectoryW(0, NULL);
-      if (dir_len == 0) {
-        return -1;
-      }
-      *dir = (WCHAR*)uv__malloc(dir_len * sizeof(WCHAR));
+      *dir = (WCHAR*)uv__malloc((MAX_PATH + 1) * sizeof(WCHAR));
       if (!*dir) {
         uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
       }
 
-      if (!GetCurrentDirectoryW(dir_len, *dir)) {
+      if (!GetCurrentDirectoryW(MAX_PATH, *dir)) {
         uv__free(*dir);
         *dir = NULL;
         return -1;
@@ -160,11 +155,9 @@ int uv_fs_event_start(uv_fs_event_t* han
   int name_size, is_path_dir, size;
   DWORD attr, last_error;
   WCHAR* dir = NULL, *dir_to_watch, *pathw = NULL;
-  DWORD short_path_buffer_len;
-  WCHAR *short_path_buffer;
+  WCHAR short_path_buffer[MAX_PATH];
   WCHAR* short_path, *long_path;
 
-  short_path = NULL;
   if (uv__is_active(handle))
     return UV_EINVAL;
 
@@ -237,23 +230,13 @@ int uv_fs_event_start(uv_fs_event_t* han
      */
 
     /* Convert to short path. */
-    short_path_buffer = NULL;
-    short_path_buffer_len = GetShortPathNameW(pathw, NULL, 0);
-    if (short_path_buffer_len == 0) {
-      goto short_path_done;
-    }
-    short_path_buffer = uv__malloc(short_path_buffer_len * sizeof(WCHAR));
-    if (short_path_buffer == NULL) {
-      goto short_path_done;
-    }
     if (GetShortPathNameW(pathw,
                           short_path_buffer,
-                          short_path_buffer_len) == 0) {
-      uv__free(short_path_buffer);
-      short_path_buffer = NULL;
+                          ARRAY_SIZE(short_path_buffer))) {
+      short_path = short_path_buffer;
+    } else {
+      short_path = NULL;
     }
-short_path_done:
-    short_path = short_path_buffer;
 
     if (uv_split_path(pathw, &dir, &handle->filew) != 0) {
       last_error = GetLastError();
@@ -363,8 +346,6 @@ error:
   if (uv__is_active(handle))
     uv__handle_stop(handle);
 
-  uv__free(short_path);
-
   return uv_translate_sys_error(last_error);
 }
 
--- a/deps/uv/src/win/pipe.c
+++ b/deps/uv/src/win/pipe.c
@@ -264,9 +264,8 @@ static int uv_set_pipe_handle(uv_loop_t*
   DWORD current_mode = 0;
   DWORD err = 0;
 
-  if (handle->flags & UV_HANDLE_PIPESERVER)
-    return UV_EINVAL;
-  if (handle->handle != INVALID_HANDLE_VALUE)
+  if (!(handle->flags & UV_HANDLE_PIPESERVER) &&
+      handle->handle != INVALID_HANDLE_VALUE)
     return UV_EBUSY;
 
   if (!SetNamedPipeHandleState(pipeHandle, &mode, NULL, NULL)) {
@@ -313,7 +312,7 @@ static int uv_set_pipe_handle(uv_loop_t*
     /* Overlapped pipe.  Try to associate with IOCP. */
     if (CreateIoCompletionPort(pipeHandle,
                                loop->iocp,
-                               (ULONG_PTR) handle,
+                               (ULONG_PTR)handle,
                                0) == NULL) {
       handle->flags |= UV_HANDLE_EMULATE_IOCP;
     }
@@ -327,38 +326,6 @@ static int uv_set_pipe_handle(uv_loop_t*
 }
 
 
-static int pipe_alloc_accept(uv_loop_t* loop, uv_pipe_t* handle,
-                             uv_pipe_accept_t* req, BOOL firstInstance) {
-  assert(req->pipeHandle == INVALID_HANDLE_VALUE);
-
-  req->pipeHandle =
-      CreateNamedPipeW(handle->name,
-                       PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | WRITE_DAC |
-                         (firstInstance ? FILE_FLAG_FIRST_PIPE_INSTANCE : 0),
-                       PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
-                       PIPE_UNLIMITED_INSTANCES, 65536, 65536, 0, NULL);
-
-  if (req->pipeHandle == INVALID_HANDLE_VALUE) {
-    return 0;
-  }
-
-  /* Associate it with IOCP so we can get events. */
-  if (CreateIoCompletionPort(req->pipeHandle,
-                             loop->iocp,
-                             (ULONG_PTR) handle,
-                             0) == NULL) {
-    uv_fatal_error(GetLastError(), "CreateIoCompletionPort");
-  }
-
-  /* Stash a handle in the server object for use from places such as
-   * getsockname and chmod. As we transfer ownership of these to client
-   * objects, we'll allocate new ones here. */
-  handle->handle = req->pipeHandle;
-
-  return 1;
-}
-
-
 static DWORD WINAPI pipe_shutdown_thread_proc(void* parameter) {
   uv_loop_t* loop;
   uv_pipe_t* handle;
@@ -491,7 +458,7 @@ void uv_pipe_endgame(uv_loop_t* loop, uv
           UnregisterWait(handle->read_req.wait_handle);
           handle->read_req.wait_handle = INVALID_HANDLE_VALUE;
         }
-        if (handle->read_req.event_handle != NULL) {
+        if (handle->read_req.event_handle) {
           CloseHandle(handle->read_req.event_handle);
           handle->read_req.event_handle = NULL;
         }
@@ -573,10 +540,13 @@ int uv_pipe_bind(uv_pipe_t* handle, cons
    * Attempt to create the first pipe with FILE_FLAG_FIRST_PIPE_INSTANCE.
    * If this fails then there's already a pipe server for the given pipe name.
    */
-  if (!pipe_alloc_accept(loop,
-                         handle,
-                         &handle->pipe.serv.accept_reqs[0],
-                         TRUE)) {
+  handle->pipe.serv.accept_reqs[0].pipeHandle = CreateNamedPipeW(handle->name,
+      PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED |
+      FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_DAC,
+      PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
+      PIPE_UNLIMITED_INSTANCES, 65536, 65536, 0, NULL);
+
+  if (handle->pipe.serv.accept_reqs[0].pipeHandle == INVALID_HANDLE_VALUE) {
     err = GetLastError();
     if (err == ERROR_ACCESS_DENIED) {
       err = WSAEADDRINUSE;  /* Translates to UV_EADDRINUSE. */
@@ -586,6 +556,15 @@ int uv_pipe_bind(uv_pipe_t* handle, cons
     goto error;
   }
 
+  if (uv_set_pipe_handle(loop,
+                         handle,
+                         handle->pipe.serv.accept_reqs[0].pipeHandle,
+                         -1,
+                         0)) {
+    err = GetLastError();
+    goto error;
+  }
+
   handle->pipe.serv.pending_accepts = NULL;
   handle->flags |= UV_HANDLE_PIPESERVER;
   handle->flags |= UV_HANDLE_BOUND;
@@ -598,6 +577,11 @@ error:
     handle->name = NULL;
   }
 
+  if (handle->pipe.serv.accept_reqs[0].pipeHandle != INVALID_HANDLE_VALUE) {
+    CloseHandle(handle->pipe.serv.accept_reqs[0].pipeHandle);
+    handle->pipe.serv.accept_reqs[0].pipeHandle = INVALID_HANDLE_VALUE;
+  }
+
   return uv_translate_sys_error(err);
 }
 
@@ -843,11 +827,29 @@ static void uv_pipe_queue_accept(uv_loop
     uv_pipe_accept_t* req, BOOL firstInstance) {
   assert(handle->flags & UV_HANDLE_LISTENING);
 
-  if (!firstInstance && !pipe_alloc_accept(loop, handle, req, FALSE)) {
-    SET_REQ_ERROR(req, GetLastError());
-    uv_insert_pending_req(loop, (uv_req_t*) req);
-    handle->reqs_pending++;
-    return;
+  if (!firstInstance) {
+    assert(req->pipeHandle == INVALID_HANDLE_VALUE);
+
+    req->pipeHandle = CreateNamedPipeW(handle->name,
+        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | WRITE_DAC,
+        PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
+        PIPE_UNLIMITED_INSTANCES, 65536, 65536, 0, NULL);
+
+    if (req->pipeHandle == INVALID_HANDLE_VALUE) {
+      SET_REQ_ERROR(req, GetLastError());
+      uv_insert_pending_req(loop, (uv_req_t*) req);
+      handle->reqs_pending++;
+      return;
+    }
+
+    if (uv_set_pipe_handle(loop, handle, req->pipeHandle, -1, 0)) {
+      CloseHandle(req->pipeHandle);
+      req->pipeHandle = INVALID_HANDLE_VALUE;
+      SET_REQ_ERROR(req, GetLastError());
+      uv_insert_pending_req(loop, (uv_req_t*) req);
+      handle->reqs_pending++;
+      return;
+    }
   }
 
   assert(req->pipeHandle != INVALID_HANDLE_VALUE);
@@ -902,7 +904,7 @@ int uv_pipe_accept(uv_pipe_t* server, uv
     uv__free(item);
 
   } else {
-    pipe_client = (uv_pipe_t*) client;
+    pipe_client = (uv_pipe_t*)client;
 
     /* Find a connection instance that has been connected, but not yet
      * accepted. */
@@ -923,7 +925,6 @@ int uv_pipe_accept(uv_pipe_t* server, uv
     req->next_pending = NULL;
     req->pipeHandle = INVALID_HANDLE_VALUE;
 
-    server->handle = INVALID_HANDLE_VALUE;
     if (!(server->flags & UV_HANDLE_CLOSING)) {
       uv_pipe_queue_accept(loop, server, req, FALSE);
     }
@@ -954,10 +955,6 @@ int uv_pipe_listen(uv_pipe_t* handle, in
     return ERROR_NOT_SUPPORTED;
   }
 
-  if (handle->ipc) {
-    return WSAEINVAL;
-  }
-
   handle->flags |= UV_HANDLE_LISTENING;
   INCREASE_ACTIVE_COUNT(loop, handle);
   handle->stream.serv.connection_cb = cb;
@@ -1134,7 +1131,6 @@ static void uv_pipe_queue_read(uv_loop_t
   } else {
     memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
     if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
-      assert(req->event_handle != NULL);
       req->u.io.overlapped.hEvent = (HANDLE) ((uintptr_t) req->event_handle | 1);
     }
 
@@ -1152,9 +1148,15 @@ static void uv_pipe_queue_read(uv_loop_t
     }
 
     if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
+      if (!req->event_handle) {
+        req->event_handle = CreateEvent(NULL, 0, 0, NULL);
+        if (!req->event_handle) {
+          uv_fatal_error(GetLastError(), "CreateEvent");
+        }
+      }
       if (req->wait_handle == INVALID_HANDLE_VALUE) {
         if (!RegisterWaitForSingleObject(&req->wait_handle,
-            req->event_handle, post_completion_read_wait, (void*) req,
+            req->u.io.overlapped.hEvent, post_completion_read_wait, (void*) req,
             INFINITE, WT_EXECUTEINWAITTHREAD)) {
           SET_REQ_ERROR(req, GetLastError());
           goto error;
@@ -1188,16 +1190,8 @@ int uv_pipe_read_start(uv_pipe_t* handle
 
   /* If reading was stopped and then started again, there could still be a read
    * request pending. */
-  if (!(handle->flags & UV_HANDLE_READ_PENDING)) {
-    if (handle->flags & UV_HANDLE_EMULATE_IOCP &&
-        handle->read_req.event_handle == NULL) {
-      handle->read_req.event_handle = CreateEvent(NULL, 0, 0, NULL);
-      if (handle->read_req.event_handle == NULL) {
-        uv_fatal_error(GetLastError(), "CreateEvent");
-      }
-    }
+  if (!(handle->flags & UV_HANDLE_READ_PENDING))
     uv_pipe_queue_read(loop, handle);
-  }
 
   return 0;
 }
@@ -1332,16 +1326,7 @@ static int uv__pipe_write_data(uv_loop_t
   req->coalesced = 0;
   req->event_handle = NULL;
   req->wait_handle = INVALID_HANDLE_VALUE;
-
-  /* Prepare the overlapped structure. */
   memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
-  if (handle->flags & (UV_HANDLE_EMULATE_IOCP | UV_HANDLE_BLOCKING_WRITES)) {
-    req->event_handle = CreateEvent(NULL, 0, 0, NULL);
-    if (req->event_handle == NULL) {
-      uv_fatal_error(GetLastError(), "CreateEvent");
-    }
-    req->u.io.overlapped.hEvent = (HANDLE) ((uintptr_t) req->event_handle | 1);
-  }
   req->write_buffer = uv_null_buf_;
 
   if (nbufs == 0) {
@@ -1390,6 +1375,11 @@ static int uv__pipe_write_data(uv_loop_t
     handle->write_queue_size += req->u.io.queued_bytes;
   } else if (handle->flags & UV_HANDLE_BLOCKING_WRITES) {
     /* Using overlapped IO, but wait for completion before returning */
+    req->u.io.overlapped.hEvent = CreateEvent(NULL, 1, 0, NULL);
+    if (!req->u.io.overlapped.hEvent) {
+      uv_fatal_error(GetLastError(), "CreateEvent");
+    }
+
     result = WriteFile(handle->handle,
                        write_buf.base,
                        write_buf.len,
@@ -1398,8 +1388,7 @@ static int uv__pipe_write_data(uv_loop_t
 
     if (!result && GetLastError() != ERROR_IO_PENDING) {
       err = GetLastError();
-      CloseHandle(req->event_handle);
-      req->event_handle = NULL;
+      CloseHandle(req->u.io.overlapped.hEvent);
       return err;
     }
 
@@ -1410,16 +1399,14 @@ static int uv__pipe_write_data(uv_loop_t
       /* Request queued by the kernel. */
       req->u.io.queued_bytes = write_buf.len;
       handle->write_queue_size += req->u.io.queued_bytes;
-      if (WaitForSingleObject(req->event_handle, INFINITE) !=
+      if (WaitForSingleObject(req->u.io.overlapped.hEvent, INFINITE) !=
           WAIT_OBJECT_0) {
         err = GetLastError();
-        CloseHandle(req->event_handle);
-        req->event_handle = NULL;
+        CloseHandle(req->u.io.overlapped.hEvent);
         return err;
       }
     }
-    CloseHandle(req->event_handle);
-    req->event_handle = NULL;
+    CloseHandle(req->u.io.overlapped.hEvent);
 
     REGISTER_HANDLE_REQ(loop, handle, req);
     handle->reqs_pending++;
@@ -1446,8 +1433,12 @@ static int uv__pipe_write_data(uv_loop_t
     }
 
     if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
+      req->event_handle = CreateEvent(NULL, 0, 0, NULL);
+      if (!req->event_handle) {
+        uv_fatal_error(GetLastError(), "CreateEvent");
+      }
       if (!RegisterWaitForSingleObject(&req->wait_handle,
-          req->event_handle, post_completion_write_wait, (void*) req,
+          req->u.io.overlapped.hEvent, post_completion_write_wait, (void*) req,
           INFINITE, WT_EXECUTEINWAITTHREAD)) {
         return GetLastError();
       }
--- a/deps/uv/src/win/poll.c
+++ b/deps/uv/src/win/poll.c
@@ -134,6 +134,32 @@ static void uv__fast_poll_submit_poll_re
 }
 
 
+static int uv__fast_poll_cancel_poll_req(uv_loop_t* loop, uv_poll_t* handle) {
+  AFD_POLL_INFO afd_poll_info;
+  int result;
+
+  afd_poll_info.Exclusive = TRUE;
+  afd_poll_info.NumberOfHandles = 1;
+  afd_poll_info.Timeout.QuadPart = INT64_MAX;
+  afd_poll_info.Handles[0].Handle = (HANDLE) handle->socket;
+  afd_poll_info.Handles[0].Status = 0;
+  afd_poll_info.Handles[0].Events = AFD_POLL_ALL;
+
+  result = uv_msafd_poll(handle->socket,
+                         &afd_poll_info,
+                         uv__get_afd_poll_info_dummy(),
+                         uv__get_overlapped_dummy());
+
+  if (result == SOCKET_ERROR) {
+    DWORD error = WSAGetLastError();
+    if (error != WSA_IO_PENDING)
+      return error;
+  }
+
+  return 0;
+}
+
+
 static void uv__fast_poll_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,
     uv_req_t* req) {
   unsigned char mask_events;
@@ -200,6 +226,44 @@ static void uv__fast_poll_process_poll_r
 }
 
 
+static int uv__fast_poll_set(uv_loop_t* loop, uv_poll_t* handle, int events) {
+  assert(handle->type == UV_POLL);
+  assert(!(handle->flags & UV_HANDLE_CLOSING));
+  assert((events & ~(UV_READABLE | UV_WRITABLE | UV_DISCONNECT)) == 0);
+
+  handle->events = events;
+
+  if (handle->events != 0) {
+    uv__handle_start(handle);
+  } else {
+    uv__handle_stop(handle);
+  }
+
+  if ((handle->events & ~(handle->submitted_events_1 |
+      handle->submitted_events_2)) != 0) {
+    uv__fast_poll_submit_poll_req(handle->loop, handle);
+  }
+
+  return 0;
+}
+
+
+static int uv__fast_poll_close(uv_loop_t* loop, uv_poll_t* handle) {
+  handle->events = 0;
+  uv__handle_closing(handle);
+
+  if (handle->submitted_events_1 == 0 &&
+      handle->submitted_events_2 == 0) {
+    uv_want_endgame(loop, (uv_handle_t*) handle);
+    return 0;
+  } else {
+    /* Cancel outstanding poll requests by executing another, unique poll
+     * request that forces the outstanding ones to return. */
+    return uv__fast_poll_cancel_poll_req(loop, handle);
+  }
+}
+
+
 static SOCKET uv__fast_poll_create_peer_socket(HANDLE iocp,
     WSAPROTOCOL_INFOW* protocol_info) {
   SOCKET sock = 0;
@@ -405,6 +469,41 @@ static void uv__slow_poll_process_poll_r
 }
 
 
+static int uv__slow_poll_set(uv_loop_t* loop, uv_poll_t* handle, int events) {
+  assert(handle->type == UV_POLL);
+  assert(!(handle->flags & UV_HANDLE_CLOSING));
+  assert((events & ~(UV_READABLE | UV_WRITABLE)) == 0);
+
+  handle->events = events;
+
+  if (handle->events != 0) {
+    uv__handle_start(handle);
+  } else {
+    uv__handle_stop(handle);
+  }
+
+  if ((handle->events &
+      ~(handle->submitted_events_1 | handle->submitted_events_2)) != 0) {
+    uv__slow_poll_submit_poll_req(handle->loop, handle);
+  }
+
+  return 0;
+}
+
+
+static int uv__slow_poll_close(uv_loop_t* loop, uv_poll_t* handle) {
+  handle->events = 0;
+  uv__handle_closing(handle);
+
+  if (handle->submitted_events_1 == 0 &&
+      handle->submitted_events_2 == 0) {
+    uv_want_endgame(loop, (uv_handle_t*) handle);
+  }
+
+  return 0;
+}
+
+
 int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {
   return uv_poll_init_socket(loop, handle, (SOCKET) uv__get_osfhandle(fd));
 }
@@ -483,43 +582,35 @@ int uv_poll_init_socket(uv_loop_t* loop,
 }
 
 
-static int uv__poll_set(uv_poll_t* handle, int events, uv_poll_cb cb) {
-  int submitted_events;
-
-  assert(handle->type == UV_POLL);
-  assert(!(handle->flags & UV_HANDLE_CLOSING));
-  assert((events & ~(UV_READABLE | UV_WRITABLE | UV_DISCONNECT)) == 0);
-
-  handle->events = events;
-  handle->poll_cb = cb;
+int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb) {
+  int err;
 
-  if (handle->events == 0) {
-    uv__handle_stop(handle);
-    return 0;
+  if (!(handle->flags & UV_HANDLE_POLL_SLOW)) {
+    err = uv__fast_poll_set(handle->loop, handle, events);
+  } else {
+    err = uv__slow_poll_set(handle->loop, handle, events);
   }
 
-  uv__handle_start(handle);
-  submitted_events = handle->submitted_events_1 | handle->submitted_events_2;
-
-  if (handle->events & ~submitted_events) {
-    if (handle->flags & UV_HANDLE_POLL_SLOW) {
-      uv__slow_poll_submit_poll_req(handle->loop, handle);
-    } else {
-      uv__fast_poll_submit_poll_req(handle->loop, handle);
-    }
+  if (err) {
+    return uv_translate_sys_error(err);
   }
 
+  handle->poll_cb = cb;
+
   return 0;
 }
 
 
-int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb) {
-  return uv__poll_set(handle, events, cb);
-}
+int uv_poll_stop(uv_poll_t* handle) {
+  int err;
 
+  if (!(handle->flags & UV_HANDLE_POLL_SLOW)) {
+    err = uv__fast_poll_set(handle->loop, handle, 0);
+  } else {
+    err = uv__slow_poll_set(handle->loop, handle, 0);
+  }
 
-int uv_poll_stop(uv_poll_t* handle) {
-  return uv__poll_set(handle, 0, handle->poll_cb);
+  return uv_translate_sys_error(err);
 }
 
 
@@ -533,43 +624,11 @@ void uv_process_poll_req(uv_loop_t* loop
 
 
 int uv_poll_close(uv_loop_t* loop, uv_poll_t* handle) {
-  AFD_POLL_INFO afd_poll_info;
-  DWORD error;
-  int result;
-
-  handle->events = 0;
-  uv__handle_closing(handle);
-
-  if (handle->submitted_events_1 == 0 &&
-      handle->submitted_events_2 == 0) {
-    uv_want_endgame(loop, (uv_handle_t*) handle);
-    return 0;
-  }
-
-  if (handle->flags & UV_HANDLE_POLL_SLOW)
-    return 0;
-
-  /* Cancel outstanding poll requests by executing another, unique poll
-   * request that forces the outstanding ones to return. */
-  afd_poll_info.Exclusive = TRUE;
-  afd_poll_info.NumberOfHandles = 1;
-  afd_poll_info.Timeout.QuadPart = INT64_MAX;
-  afd_poll_info.Handles[0].Handle = (HANDLE) handle->socket;
-  afd_poll_info.Handles[0].Status = 0;
-  afd_poll_info.Handles[0].Events = AFD_POLL_ALL;
-
-  result = uv_msafd_poll(handle->socket,
-                         &afd_poll_info,
-                         uv__get_afd_poll_info_dummy(),
-                         uv__get_overlapped_dummy());
-
-  if (result == SOCKET_ERROR) {
-    error = WSAGetLastError();
-    if (error != WSA_IO_PENDING)
-      return uv_translate_sys_error(error);
+  if (!(handle->flags & UV_HANDLE_POLL_SLOW)) {
+    return uv__fast_poll_close(loop, handle);
+  } else {
+    return uv__slow_poll_close(loop, handle);
   }
-
-  return 0;
 }
 
 
--- a/deps/uv/src/win/process.c
+++ b/deps/uv/src/win/process.c
@@ -58,6 +58,7 @@ static const env_var_t required_vars[] =
   E_V("USERPROFILE"),
   E_V("WINDIR"),
 };
+static size_t n_required_vars = ARRAY_SIZE(required_vars);
 
 
 static HANDLE uv_global_job_handle_;
@@ -691,7 +692,7 @@ int make_program_env(char* env_block[],
   WCHAR* dst_copy;
   WCHAR** ptr_copy;
   WCHAR** env_copy;
-  DWORD required_vars_value_len[ARRAY_SIZE(required_vars)];
+  DWORD* required_vars_value_len = alloca(n_required_vars * sizeof(DWORD*));
 
   /* first pass: determine size in UTF-16 */
   for (env = env_block; *env; env++) {
@@ -744,7 +745,7 @@ int make_program_env(char* env_block[],
   qsort(env_copy, env_block_count-1, sizeof(wchar_t*), qsort_wcscmp);
 
   /* third pass: check for required variables */
-  for (ptr_copy = env_copy, i = 0; i < ARRAY_SIZE(required_vars); ) {
+  for (ptr_copy = env_copy, i = 0; i < n_required_vars; ) {
     int cmp;
     if (!*ptr_copy) {
       cmp = -1;
@@ -777,10 +778,10 @@ int make_program_env(char* env_block[],
   }
 
   for (ptr = dst, ptr_copy = env_copy, i = 0;
-       *ptr_copy || i < ARRAY_SIZE(required_vars);
+       *ptr_copy || i < n_required_vars;
        ptr += len) {
     int cmp;
-    if (i >= ARRAY_SIZE(required_vars)) {
+    if (i >= n_required_vars) {
       cmp = 1;
     } else if (!*ptr_copy) {
       cmp = -1;
--- a/deps/uv/src/win/signal.c
+++ b/deps/uv/src/win/signal.c
@@ -46,11 +46,6 @@ void uv_signals_init(void) {
 }
 
 
-void uv__signal_cleanup(void) {
-  /* TODO(bnoordhuis) Undo effects of uv_signal_init()? */
-}
-
-
 static int uv__signal_compare(uv_signal_t* w1, uv_signal_t* w2) {
   /* Compare signums first so all watchers with the same signnum end up
    * adjacent. */
--- a/deps/uv/src/win/tcp.c
+++ b/deps/uv/src/win/tcp.c
@@ -251,7 +251,7 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_
             UnregisterWait(req->wait_handle);
             req->wait_handle = INVALID_HANDLE_VALUE;
           }
-          if (req->event_handle != NULL) {
+          if (req->event_handle) {
             CloseHandle(req->event_handle);
             req->event_handle = NULL;
           }
@@ -268,7 +268,7 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_
         UnregisterWait(handle->read_req.wait_handle);
         handle->read_req.wait_handle = INVALID_HANDLE_VALUE;
       }
-      if (handle->read_req.event_handle != NULL) {
+      if (handle->read_req.event_handle) {
         CloseHandle(handle->read_req.event_handle);
         handle->read_req.event_handle = NULL;
       }
@@ -428,7 +428,6 @@ static void uv_tcp_queue_accept(uv_tcp_t
   /* Prepare the overlapped structure. */
   memset(&(req->u.io.overlapped), 0, sizeof(req->u.io.overlapped));
   if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
-    assert(req->event_handle != NULL);
     req->u.io.overlapped.hEvent = (HANDLE) ((ULONG_PTR) req->event_handle | 1);
   }
 
@@ -467,7 +466,7 @@ static void uv_tcp_queue_accept(uv_tcp_t
     closesocket(accept_socket);
     /* Destroy the event handle */
     if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
-      CloseHandle(req->event_handle);
+      CloseHandle(req->u.io.overlapped.hEvent);
       req->event_handle = NULL;
     }
   }
@@ -510,7 +509,7 @@ static void uv_tcp_queue_read(uv_loop_t*
   /* Prepare the overlapped structure. */
   memset(&(req->u.io.overlapped), 0, sizeof(req->u.io.overlapped));
   if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
-    assert(req->event_handle != NULL);
+    assert(req->event_handle);
     req->u.io.overlapped.hEvent = (HANDLE) ((ULONG_PTR) req->event_handle | 1);
   }
 
@@ -613,8 +612,8 @@ int uv_tcp_listen(uv_tcp_t* handle, int
   simultaneous_accepts = handle->flags & UV_HANDLE_TCP_SINGLE_ACCEPT ? 1
     : uv_simultaneous_server_accepts;
 
-  if (handle->tcp.serv.accept_reqs == NULL) {
-    handle->tcp.serv.accept_reqs =
+  if(!handle->tcp.serv.accept_reqs) {
+    handle->tcp.serv.accept_reqs = (uv_tcp_accept_t*)
       uv__malloc(uv_simultaneous_server_accepts * sizeof(uv_tcp_accept_t));
     if (!handle->tcp.serv.accept_reqs) {
       uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
@@ -629,7 +628,7 @@ int uv_tcp_listen(uv_tcp_t* handle, int
       req->wait_handle = INVALID_HANDLE_VALUE;
       if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
         req->event_handle = CreateEvent(NULL, 0, 0, NULL);
-        if (req->event_handle == NULL) {
+        if (!req->event_handle) {
           uv_fatal_error(GetLastError(), "CreateEvent");
         }
       } else {
@@ -738,9 +737,9 @@ int uv_tcp_read_start(uv_tcp_t* handle,
    * request pending. */
   if (!(handle->flags & UV_HANDLE_READ_PENDING)) {
     if (handle->flags & UV_HANDLE_EMULATE_IOCP &&
-        handle->read_req.event_handle == NULL) {
+        !handle->read_req.event_handle) {
       handle->read_req.event_handle = CreateEvent(NULL, 0, 0, NULL);
-      if (handle->read_req.event_handle == NULL) {
+      if (!handle->read_req.event_handle) {
         uv_fatal_error(GetLastError(), "CreateEvent");
       }
     }
@@ -863,7 +862,7 @@ int uv_tcp_write(uv_loop_t* loop,
   memset(&(req->u.io.overlapped), 0, sizeof(req->u.io.overlapped));
   if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
     req->event_handle = CreateEvent(NULL, 0, 0, NULL);
-    if (req->event_handle == NULL) {
+    if (!req->event_handle) {
       uv_fatal_error(GetLastError(), "CreateEvent");
     }
     req->u.io.overlapped.hEvent = (HANDLE) ((ULONG_PTR) req->event_handle | 1);
@@ -1081,7 +1080,7 @@ void uv_process_tcp_write_req(uv_loop_t*
       UnregisterWait(req->wait_handle);
       req->wait_handle = INVALID_HANDLE_VALUE;
     }
-    if (req->event_handle != NULL) {
+    if (req->event_handle) {
       CloseHandle(req->event_handle);
       req->event_handle = NULL;
     }
--- a/deps/uv/src/win/tty.c
+++ b/deps/uv/src/win/tty.c
@@ -46,16 +46,14 @@
 
 #define UNICODE_REPLACEMENT_CHARACTER (0xfffd)
 
-#define ANSI_NORMAL           0x0000
-#define ANSI_ESCAPE_SEEN      0x0002
-#define ANSI_CSI              0x0004
-#define ANSI_ST_CONTROL       0x0008
-#define ANSI_IGNORE           0x0010
-#define ANSI_IN_ARG           0x0020
-#define ANSI_IN_STRING        0x0040
-#define ANSI_BACKSLASH_SEEN   0x0080
-#define ANSI_EXTENSION        0x0100
-#define ANSI_DECSCUSR         0x0200
+#define ANSI_NORMAL           0x00
+#define ANSI_ESCAPE_SEEN      0x02
+#define ANSI_CSI              0x04
+#define ANSI_ST_CONTROL       0x08
+#define ANSI_IGNORE           0x10
+#define ANSI_IN_ARG           0x20
+#define ANSI_IN_STRING        0x40
+#define ANSI_BACKSLASH_SEEN   0x80
 
 #define MAX_INPUT_BUFFER_LENGTH 8192
 #define MAX_CONSOLE_CHAR 8192
@@ -64,12 +62,7 @@
 #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
 #endif
 
-#define CURSOR_SIZE_SMALL     25
-#define CURSOR_SIZE_LARGE     100
-
-static void uv_tty_capture_initial_style(
-    CONSOLE_SCREEN_BUFFER_INFO* screen_buffer_info,
-    CONSOLE_CURSOR_INFO* cursor_info);
+static void uv_tty_capture_initial_style(CONSOLE_SCREEN_BUFFER_INFO* info);
 static void uv_tty_update_virtual_window(CONSOLE_SCREEN_BUFFER_INFO* info);
 static int uv__cancel_read_console(uv_tty_t* handle);
 
@@ -156,8 +149,6 @@ static char uv_tty_default_fg_bright = 0
 static char uv_tty_default_bg_bright = 0;
 static char uv_tty_default_inverse = 0;
 
-static CONSOLE_CURSOR_INFO uv_tty_default_cursor_info;
-
 /* Determine whether or not ANSI support is enabled. */
 static BOOL uv__need_check_vterm_state = TRUE;
 static uv_tty_vtermstate_t uv__vterm_state = UV_TTY_UNSUPPORTED;
@@ -192,7 +183,6 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_
   DWORD NumberOfEvents;
   HANDLE handle;
   CONSOLE_SCREEN_BUFFER_INFO screen_buffer_info;
-  CONSOLE_CURSOR_INFO cursor_info;
   (void)unused;
 
   uv__once_init();
@@ -225,11 +215,6 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_
       return uv_translate_sys_error(GetLastError());
     }
 
-    /* Obtain the cursor info with the output handle. */
-    if (!GetConsoleCursorInfo(handle, &cursor_info)) {
-      return uv_translate_sys_error(GetLastError());
-    }
-
     /* Obtain the tty_output_lock because the virtual window state is shared
      * between all uv_tty_t handles. */
     uv_sem_wait(&uv_tty_output_lock);
@@ -237,8 +222,8 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_
     if (uv__need_check_vterm_state)
       uv__determine_vterm_state(handle);
 
-    /* Remember the original console text attributes and cursor info. */
-    uv_tty_capture_initial_style(&screen_buffer_info, &cursor_info);
+    /* Remember the original console text attributes. */
+    uv_tty_capture_initial_style(&screen_buffer_info);
 
     uv_tty_update_virtual_window(&screen_buffer_info);
 
@@ -289,9 +274,7 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_
 /* Set the default console text attributes based on how the console was
  * configured when libuv started.
  */
-static void uv_tty_capture_initial_style(
-    CONSOLE_SCREEN_BUFFER_INFO* screen_buffer_info,
-    CONSOLE_CURSOR_INFO* cursor_info) {
+static void uv_tty_capture_initial_style(CONSOLE_SCREEN_BUFFER_INFO* info) {
   static int style_captured = 0;
 
   /* Only do this once.
@@ -300,7 +283,7 @@ static void uv_tty_capture_initial_style
     return;
 
   /* Save raw win32 attributes. */
-  uv_tty_default_text_attributes = screen_buffer_info->wAttributes;
+  uv_tty_default_text_attributes = info->wAttributes;
 
   /* Convert black text on black background to use white text. */
   if (uv_tty_default_text_attributes == 0)
@@ -340,9 +323,6 @@ static void uv_tty_capture_initial_style
   if (uv_tty_default_text_attributes & COMMON_LVB_REVERSE_VIDEO)
     uv_tty_default_inverse = 1;
 
-  /* Save the cursor size and the cursor state. */
-  uv_tty_default_cursor_info = *cursor_info;
-
   style_captured = 1;
 }
 
@@ -1250,7 +1230,7 @@ static int uv_tty_move_caret(uv_tty_t* h
 static int uv_tty_reset(uv_tty_t* handle, DWORD* error) {
   const COORD origin = {0, 0};
   const WORD char_attrs = uv_tty_default_text_attributes;
-  CONSOLE_SCREEN_BUFFER_INFO screen_buffer_info;
+  CONSOLE_SCREEN_BUFFER_INFO info;
   DWORD count, written;
 
   if (*error != ERROR_SUCCESS) {
@@ -1271,12 +1251,12 @@ static int uv_tty_reset(uv_tty_t* handle
 
   /* Clear the screen buffer. */
  retry:
-   if (!GetConsoleScreenBufferInfo(handle->handle, &screen_buffer_info)) {
-     *error = GetLastError();
-     return -1;
+  if (!GetConsoleScreenBufferInfo(handle->handle, &info)) {
+    *error = GetLastError();
+    return -1;
   }
 
-  count = screen_buffer_info.dwSize.X * screen_buffer_info.dwSize.Y;
+  count = info.dwSize.X * info.dwSize.Y;
 
   if (!(FillConsoleOutputCharacterW(handle->handle,
                                     L'\x20',
@@ -1299,13 +1279,7 @@ static int uv_tty_reset(uv_tty_t* handle
 
   /* Move the virtual window up to the top. */
   uv_tty_virtual_offset = 0;
-  uv_tty_update_virtual_window(&screen_buffer_info);
-
-  /* Reset the cursor size and the cursor state. */
-  if (!SetConsoleCursorInfo(handle->handle, &uv_tty_default_cursor_info)) {
-    *error = GetLastError();
-    return -1;
-  }
+  uv_tty_update_virtual_window(&info);
 
   return 0;
 }
@@ -1644,31 +1618,6 @@ static int uv_tty_set_cursor_visibility(
   return 0;
 }
 
-static int uv_tty_set_cursor_shape(uv_tty_t* handle, int style, DWORD* error) {
-  CONSOLE_CURSOR_INFO cursor_info;
-
-  if (!GetConsoleCursorInfo(handle->handle, &cursor_info)) {
-    *error = GetLastError();
-    return -1;
-  }
-
-  if (style == 0) {
-    cursor_info.dwSize = uv_tty_default_cursor_info.dwSize;
-  } else if (style <= 2) {
-    cursor_info.dwSize = CURSOR_SIZE_LARGE;
-  } else {
-    cursor_info.dwSize = CURSOR_SIZE_SMALL;
-  }
-
-  if (!SetConsoleCursorInfo(handle->handle, &cursor_info)) {
-    *error = GetLastError();
-    return -1;
-  }
-
-  return 0;
-}
-
-
 static int uv_tty_write_bufs(uv_tty_t* handle,
                              const uv_buf_t bufs[],
                              unsigned int nbufs,
@@ -1676,16 +1625,28 @@ static int uv_tty_write_bufs(uv_tty_t* h
   /* We can only write 8k characters at a time. Windows can't handle much more
    * characters in a single console write anyway. */
   WCHAR utf16_buf[MAX_CONSOLE_CHAR];
+  WCHAR* utf16_buffer;
   DWORD utf16_buf_used = 0;
-  unsigned int i;
+  unsigned int i, len, max_len, pos;
+  int allocate = 0;
 
-#define FLUSH_TEXT()                                                \
-  do {                                                              \
-    if (utf16_buf_used > 0) {                                       \
-      uv_tty_emit_text(handle, utf16_buf, utf16_buf_used, error);   \
-      utf16_buf_used = 0;                                           \
-    }                                                               \
-  } while (0)
+#define FLUSH_TEXT()                                                 \
+  do {                                                               \
+    pos = 0;                                                         \
+    do {                                                             \
+      len = utf16_buf_used - pos;                                    \
+      if (len > MAX_CONSOLE_CHAR)                                    \
+        len = MAX_CONSOLE_CHAR;                                      \
+      uv_tty_emit_text(handle, &utf16_buffer[pos], len, error);      \
+      pos += len;                                                    \
+    } while (pos < utf16_buf_used);                                  \
+    if (allocate) {                                                  \
+      uv__free(utf16_buffer);                                        \
+      allocate = 0;                                                  \
+      utf16_buffer = utf16_buf;                                      \
+    }                                                                \
+    utf16_buf_used = 0;                                              \
+ } while (0)
 
 #define ENSURE_BUFFER_SPACE(wchars_needed)                          \
   if (wchars_needed > ARRAY_SIZE(utf16_buf) - utf16_buf_used) {     \
@@ -1696,18 +1657,54 @@ static int uv_tty_write_bufs(uv_tty_t* h
   unsigned char utf8_bytes_left = handle->tty.wr.utf8_bytes_left;
   unsigned int utf8_codepoint = handle->tty.wr.utf8_codepoint;
   unsigned char previous_eol = handle->tty.wr.previous_eol;
-  unsigned short ansi_parser_state = handle->tty.wr.ansi_parser_state;
+  unsigned char ansi_parser_state = handle->tty.wr.ansi_parser_state;
 
   /* Store the error here. If we encounter an error, stop trying to do i/o but
    * keep parsing the buffer so we leave the parser in a consistent state. */
   *error = ERROR_SUCCESS;
 
+  utf16_buffer = utf16_buf;
+
   uv_sem_wait(&uv_tty_output_lock);
 
   for (i = 0; i < nbufs; i++) {
     uv_buf_t buf = bufs[i];
     unsigned int j;
 
+    if (uv__vterm_state == UV_TTY_SUPPORTED && buf.len > 0) {
+      utf16_buf_used = MultiByteToWideChar(CP_UTF8,
+                                           0,
+                                           buf.base,
+                                           buf.len,
+                                           NULL,
+                                           0);
+
+      if (utf16_buf_used == 0) {
+        *error = GetLastError();
+        break;
+      }
+
+      max_len = (utf16_buf_used + 1) * sizeof(WCHAR);
+      allocate = max_len > MAX_CONSOLE_CHAR;
+      if (allocate)
+        utf16_buffer = uv__malloc(max_len);
+      if (!MultiByteToWideChar(CP_UTF8,
+                               0,
+                               buf.base,
+                               buf.len,
+                               utf16_buffer,
+                               utf16_buf_used)) {
+        if (allocate)
+          uv__free(utf16_buffer);
+        *error = GetLastError();
+        break;
+      }
+
+      FLUSH_TEXT();
+
+      continue;
+    }
+
     for (j = 0; j < buf.len; j++) {
       unsigned char c = buf.base[j];
 
@@ -1764,9 +1761,7 @@ static int uv_tty_write_bufs(uv_tty_t* h
       }
 
       /* Parse vt100/ansi escape codes */
-      if (uv__vterm_state == UV_TTY_SUPPORTED) {
-        /* Pass through escape codes if conhost supports them. */
-      } else if (ansi_parser_state == ANSI_NORMAL) {
+      if (ansi_parser_state == ANSI_NORMAL) {
         switch (utf8_codepoint) {
           case '\033':
             ansi_parser_state = ANSI_ESCAPE_SEEN;
@@ -1812,7 +1807,7 @@ static int uv_tty_write_bufs(uv_tty_t* h
             ansi_parser_state = ANSI_NORMAL;
             continue;
 
-          case '8':
+           case '8':
             /* Restore the cursor position and text attributes */
             FLUSH_TEXT();
             uv_tty_restore_state(handle, 1, error);
@@ -1830,193 +1825,121 @@ static int uv_tty_write_bufs(uv_tty_t* h
             }
         }
 
-      } else if (ansi_parser_state == ANSI_IGNORE) {
-        /* We're ignoring this command. Stop only on command character. */
-        if (utf8_codepoint >= '@' && utf8_codepoint <= '~') {
-          ansi_parser_state = ANSI_NORMAL;
-        }
-        continue;
-
-      } else if (ansi_parser_state == ANSI_DECSCUSR) {
-        /* So far we've the sequence `ESC [ arg space`, and we're waiting for
-         * the final command byte. */
-        if (utf8_codepoint >= '@' && utf8_codepoint <= '~') {
-          /* Command byte */
-          if (utf8_codepoint == 'q') {
-            /* Change the cursor shape */
-            int style = handle->tty.wr.ansi_csi_argc
-              ? handle->tty.wr.ansi_csi_argv[0] : 1;
-            if (style >= 0 && style <= 6) {
-              FLUSH_TEXT();
-              uv_tty_set_cursor_shape(handle, style, error);
-            }
-          }
-
-          /* Sequence ended - go back to normal state. */
-          ansi_parser_state = ANSI_NORMAL;
-          continue;
-        }
-        /* Unexpected character, but sequence hasn't ended yet. Ignore the rest
-         * of the sequence. */
-        ansi_parser_state = ANSI_IGNORE;
-
       } else if (ansi_parser_state & ANSI_CSI) {
-        /* So far we've seen `ESC [`, and we may or may not have already parsed
-         * some of the arguments that follow. */
-
-        if (utf8_codepoint >= '0' && utf8_codepoint <= '9') {
-          /* Parse a numerical argument. */
-          if (!(ansi_parser_state & ANSI_IN_ARG)) {
-            /* We were not currently parsing a number, add a new one. */
-            /* Check for that there are too many arguments. */
-            if (handle->tty.wr.ansi_csi_argc >=
-                ARRAY_SIZE(handle->tty.wr.ansi_csi_argv)) {
-              ansi_parser_state = ANSI_IGNORE;
+        if (!(ansi_parser_state & ANSI_IGNORE)) {
+          if (utf8_codepoint >= '0' && utf8_codepoint <= '9') {
+            /* Parsing a numerical argument */
+
+            if (!(ansi_parser_state & ANSI_IN_ARG)) {
+              /* We were not currently parsing a number */
+
+              /* Check for too many arguments */
+              if (handle->tty.wr.ansi_csi_argc >= ARRAY_SIZE(handle->tty.wr.ansi_csi_argv)) {
+                ansi_parser_state |= ANSI_IGNORE;
+                continue;
+              }
+
+              ansi_parser_state |= ANSI_IN_ARG;
+              handle->tty.wr.ansi_csi_argc++;
+              handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1] =
+                  (unsigned short) utf8_codepoint - '0';
               continue;
+            } else {
+              /* We were already parsing a number. Parse next digit. */
+              uint32_t value = 10 *
+                  handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1];
+
+              /* Check for overflow. */
+              if (value > UINT16_MAX) {
+                ansi_parser_state |= ANSI_IGNORE;
+                continue;
+              }
+
+               handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1] =
+                   (unsigned short) value + (utf8_codepoint - '0');
+               continue;
             }
-            ansi_parser_state |= ANSI_IN_ARG;
-            handle->tty.wr.ansi_csi_argc++;
-            handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1] =
-                (unsigned short) utf8_codepoint - '0';
-            continue;
 
-          } else {
-            /* We were already parsing a number. Parse next digit. */
-            uint32_t value = 10 *
-                handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1];
-
-            /* Check for overflow. */
-            if (value > UINT16_MAX) {
-              ansi_parser_state = ANSI_IGNORE;
+          } else if (utf8_codepoint == ';') {
+            /* Denotes the end of an argument. */
+            if (ansi_parser_state & ANSI_IN_ARG) {
+              ansi_parser_state &= ~ANSI_IN_ARG;
               continue;
-            }
-
-            handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1] =
-                (unsigned short) value + (utf8_codepoint - '0');
-            continue;
-          }
-
-        } else if (utf8_codepoint == ';') {
-          /* Denotes the end of an argument. */
-          if (ansi_parser_state & ANSI_IN_ARG) {
-            ansi_parser_state &= ~ANSI_IN_ARG;
-            continue;
 
-          } else {
-            /* If ANSI_IN_ARG is not set, add another argument and default
-             * it to 0. */
+            } else {
+              /* If ANSI_IN_ARG is not set, add another argument and default it
+               * to 0. */
 
-            /* Check for too many arguments */
-            if (handle->tty.wr.ansi_csi_argc >=
+              /* Check for too many arguments */
+              if (handle->tty.wr.ansi_csi_argc >= ARRAY_SIZE(handle->tty.wr.ansi_csi_argv)) {
+                ansi_parser_state |= ANSI_IGNORE;
+                continue;
+              }
 
-                ARRAY_SIZE(handle->tty.wr.ansi_csi_argv)) {
-              ansi_parser_state = ANSI_IGNORE;
+              handle->tty.wr.ansi_csi_argc++;
+              handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1] = 0;
               continue;
             }
 
-            handle->tty.wr.ansi_csi_argc++;
-            handle->tty.wr.ansi_csi_argv[handle->tty.wr.ansi_csi_argc - 1] = 0;
+          } else if (utf8_codepoint == '?' && !(ansi_parser_state & ANSI_IN_ARG) &&
+                     handle->tty.wr.ansi_csi_argc == 0) {
+            /* Ignores '?' if it is the first character after CSI[. This is an
+             * extension character from the VT100 codeset that is supported and
+             * used by most ANSI terminals today. */
             continue;
-          }
-
-        } else if (utf8_codepoint == '?' &&
-                   !(ansi_parser_state & ANSI_IN_ARG) &&
-                   !(ansi_parser_state & ANSI_EXTENSION) &&
-                   handle->tty.wr.ansi_csi_argc == 0) {
-          /* Pass through '?' if it is the first character after CSI */
-          /* This is an extension character from the VT100 codeset */
-          /* that is supported and used by most ANSI terminals today. */
-          ansi_parser_state |= ANSI_EXTENSION;
-          continue;
-
-        } else if (utf8_codepoint == ' ' &&
-                   !(ansi_parser_state & ANSI_EXTENSION)) {
-          /* We expect a command byte to follow after this space. The only
-           * command that we current support is 'set cursor style'. */
-          ansi_parser_state = ANSI_DECSCUSR;
-          continue;
-
-        } else if (utf8_codepoint >= '@' && utf8_codepoint <= '~') {
-          /* Command byte */
-          if (ansi_parser_state & ANSI_EXTENSION) {
-            /* Sequence is `ESC [ ? args command`. */
-            switch (utf8_codepoint) {
-              case 'l':
-                /* Hide the cursor */
-                if (handle->tty.wr.ansi_csi_argc == 1 &&
-                    handle->tty.wr.ansi_csi_argv[0] == 25) {
-                  FLUSH_TEXT();
-                  uv_tty_set_cursor_visibility(handle, 0, error);
-                }
-                break;
-
-              case 'h':
-                /* Show the cursor */
-                if (handle->tty.wr.ansi_csi_argc == 1 &&
-                    handle->tty.wr.ansi_csi_argv[0] == 25) {
-                  FLUSH_TEXT();
-                  uv_tty_set_cursor_visibility(handle, 1, error);
-                }
-                break;
-            }
 
-          } else {
-            /* Sequence is `ESC [ args command`. */
+          } else if (utf8_codepoint >= '@' && utf8_codepoint <= '~' &&
+                     (handle->tty.wr.ansi_csi_argc > 0 || utf8_codepoint != '[')) {
             int x, y, d;
+
+            /* Command byte */
             switch (utf8_codepoint) {
               case 'A':
                 /* cursor up */
                 FLUSH_TEXT();
-                y = -(handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 1);
+                y = -(handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 1);
                 uv_tty_move_caret(handle, 0, 1, y, 1, error);
                 break;
 
               case 'B':
                 /* cursor down */
                 FLUSH_TEXT();
-                y = handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 1;
+                y = handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 1;
                 uv_tty_move_caret(handle, 0, 1, y, 1, error);
                 break;
 
               case 'C':
                 /* cursor forward */
                 FLUSH_TEXT();
-                x = handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 1;
+                x = handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 1;
                 uv_tty_move_caret(handle, x, 1, 0, 1, error);
                 break;
 
               case 'D':
                 /* cursor back */
                 FLUSH_TEXT();
-                x = -(handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 1);
+                x = -(handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 1);
                 uv_tty_move_caret(handle, x, 1, 0, 1, error);
                 break;
 
               case 'E':
                 /* cursor next line */
                 FLUSH_TEXT();
-                y = handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 1;
+                y = handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 1;
                 uv_tty_move_caret(handle, 0, 0, y, 1, error);
                 break;
 
               case 'F':
                 /* cursor previous line */
                 FLUSH_TEXT();
-                y = -(handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 1);
+                y = -(handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 1);
                 uv_tty_move_caret(handle, 0, 0, y, 1, error);
                 break;
 
               case 'G':
                 /* cursor horizontal move absolute */
                 FLUSH_TEXT();
-                x = (handle->tty.wr.ansi_csi_argc >= 1 &&
-                     handle->tty.wr.ansi_csi_argv[0])
+                x = (handle->tty.wr.ansi_csi_argc >= 1 && handle->tty.wr.ansi_csi_argv[0])
                   ? handle->tty.wr.ansi_csi_argv[0] - 1 : 0;
                 uv_tty_move_caret(handle, x, 0, 0, 1, error);
                 break;
@@ -2025,11 +1948,9 @@ static int uv_tty_write_bufs(uv_tty_t* h
               case 'f':
                 /* cursor move absolute */
                 FLUSH_TEXT();
-                y = (handle->tty.wr.ansi_csi_argc >= 1 &&
-                     handle->tty.wr.ansi_csi_argv[0])
+                y = (handle->tty.wr.ansi_csi_argc >= 1 && handle->tty.wr.ansi_csi_argv[0])
                   ? handle->tty.wr.ansi_csi_argv[0] - 1 : 0;
-                x = (handle->tty.wr.ansi_csi_argc >= 2 &&
-                     handle->tty.wr.ansi_csi_argv[1])
+                x = (handle->tty.wr.ansi_csi_argc >= 2 && handle->tty.wr.ansi_csi_argv[1])
                   ? handle->tty.wr.ansi_csi_argv[1] - 1 : 0;
                 uv_tty_move_caret(handle, x, 0, y, 0, error);
                 break;
@@ -2037,8 +1958,7 @@ static int uv_tty_write_bufs(uv_tty_t* h
               case 'J':
                 /* Erase screen */
                 FLUSH_TEXT();
-                d = handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 0;
+                d = handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 0;
                 if (d >= 0 && d <= 2) {
                   uv_tty_clear(handle, d, 1, error);
                 }
@@ -2047,8 +1967,7 @@ static int uv_tty_write_bufs(uv_tty_t* h
               case 'K':
                 /* Erase line */
                 FLUSH_TEXT();
-                d = handle->tty.wr.ansi_csi_argc
-                  ? handle->tty.wr.ansi_csi_argv[0] : 0;
+                d = handle->tty.wr.ansi_csi_argc ? handle->tty.wr.ansi_csi_argv[0] : 0;
                 if (d >= 0 && d <= 2) {
                   uv_tty_clear(handle, d, 0, error);
                 }
@@ -2071,17 +1990,41 @@ static int uv_tty_write_bufs(uv_tty_t* h
                 FLUSH_TEXT();
                 uv_tty_restore_state(handle, 0, error);
                 break;
+
+              case 'l':
+                /* Hide the cursor */
+                if (handle->tty.wr.ansi_csi_argc == 1 &&
+                    handle->tty.wr.ansi_csi_argv[0] == 25) {
+                  FLUSH_TEXT();
+                  uv_tty_set_cursor_visibility(handle, 0, error);
+                }
+                break;
+
+              case 'h':
+                /* Show the cursor */
+                if (handle->tty.wr.ansi_csi_argc == 1 &&
+                    handle->tty.wr.ansi_csi_argv[0] == 25) {
+                  FLUSH_TEXT();
+                  uv_tty_set_cursor_visibility(handle, 1, error);
+                }
+                break;
             }
-          }
 
-          /* Sequence ended - go back to normal state. */
-          ansi_parser_state = ANSI_NORMAL;
-          continue;
+            /* Sequence ended - go back to normal state. */
+            ansi_parser_state = ANSI_NORMAL;
+            continue;
 
+          } else {
+            /* We don't support commands that use private mode characters or
+             * intermediaries. Ignore the rest of the sequence. */
+            ansi_parser_state |= ANSI_IGNORE;
+            continue;
+          }
         } else {
-          /* We don't support commands that use private mode characters or
-           * intermediaries. Ignore the rest of the sequence. */
-          ansi_parser_state = ANSI_IGNORE;
+          /* We're ignoring this command. Stop only on command character. */
+          if (utf8_codepoint >= '@' && utf8_codepoint <= '~') {
+            ansi_parser_state = ANSI_NORMAL;
+          }
           continue;
         }
 
--- a/deps/uv/src/win/udp.c
+++ b/deps/uv/src/win/udp.c
@@ -125,10 +125,17 @@ static int uv_udp_set_socket(uv_loop_t*
 }
 
 
-int uv__udp_init_ex(uv_loop_t* loop,
-                    uv_udp_t* handle,
-                    unsigned flags,
-                    int domain) {
+int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned int flags) {
+  int domain;
+
+  /* Use the lower 8 bits for the domain */
+  domain = flags & 0xFF;
+  if (domain != AF_INET && domain != AF_INET6 && domain != AF_UNSPEC)
+    return UV_EINVAL;
+
+  if (flags & ~0xFF)
+    return UV_EINVAL;
+
   uv__handle_init(loop, (uv_handle_t*) handle, UV_UDP);
   handle->socket = INVALID_SOCKET;
   handle->reqs_pending = 0;
@@ -167,6 +174,11 @@ int uv__udp_init_ex(uv_loop_t* loop,
 }
 
 
+int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {
+  return uv_udp_init_ex(loop, handle, AF_UNSPEC);
+}
+
+
 void uv_udp_close(uv_loop_t* loop, uv_udp_t* handle) {
   uv_udp_recv_stop(handle);
   closesocket(handle->socket);
@@ -774,10 +786,8 @@ int uv__udp_set_source_membership6(uv_ud
     mreq.gsr_interface = 0;
   }
 
-  STATIC_ASSERT(sizeof(mreq.gsr_group) >= sizeof(*multicast_addr));
-  STATIC_ASSERT(sizeof(mreq.gsr_source) >= sizeof(*source_addr));
-  memcpy(&mreq.gsr_group, multicast_addr, sizeof(*multicast_addr));
-  memcpy(&mreq.gsr_source, source_addr, sizeof(*source_addr));
+  memcpy(&mreq.gsr_group, multicast_addr, sizeof(mreq.gsr_group));
+  memcpy(&mreq.gsr_source, source_addr, sizeof(mreq.gsr_source));
 
   if (membership == UV_JOIN_GROUP)
     optname = MCAST_JOIN_SOURCE_GROUP;
--- a/deps/uv/src/win/util.c
+++ b/deps/uv/src/win/util.c
@@ -60,8 +60,8 @@
 #endif
 
 
-/* A RtlGenRandom() by any other name... */
-extern BOOLEAN NTAPI SystemFunction036(PVOID Buffer, ULONG BufferLength);
+/* Maximum environment variable size, including the terminating null */
+#define MAX_ENV_VAR_LENGTH 32767
 
 /* Cached copy of the process title, plus a mutex guarding it. */
 static char *process_title;
@@ -151,26 +151,20 @@ int uv_exepath(char* buffer, size_t* siz
 
 int uv_cwd(char* buffer, size_t* size) {
   DWORD utf16_len;
-  WCHAR *utf16_buffer;
+  WCHAR utf16_buffer[MAX_PATH];
   int r;
 
   if (buffer == NULL || size == NULL) {
     return UV_EINVAL;
   }
 
-  utf16_len = GetCurrentDirectoryW(0, NULL);
+  utf16_len = GetCurrentDirectoryW(MAX_PATH, utf16_buffer);
   if (utf16_len == 0) {
     return uv_translate_sys_error(GetLastError());
-  }
-  utf16_buffer = uv__malloc(utf16_len * sizeof(WCHAR));
-  if (utf16_buffer == NULL) {
-    return UV_ENOMEM;
-  }
-
-  utf16_len = GetCurrentDirectoryW(utf16_len, utf16_buffer);
-  if (utf16_len == 0) {
-    uv__free(utf16_buffer);
-    return uv_translate_sys_error(GetLastError());
+  } else if (utf16_len > MAX_PATH) {
+    /* This should be impossible; however the CRT has a code path to deal with
+     * this scenario, so I added a check anyway. */
+    return UV_EIO;
   }
 
   /* utf16_len contains the length, *not* including the terminating null. */
@@ -194,10 +188,8 @@ int uv_cwd(char* buffer, size_t* size) {
                           NULL,
                           NULL);
   if (r == 0) {
-    uv__free(utf16_buffer);
     return uv_translate_sys_error(GetLastError());
   } else if (r > (int) *size) {
-    uv__free(utf16_buffer);
     *size = r;
     return UV_ENOBUFS;
   }
@@ -211,8 +203,6 @@ int uv_cwd(char* buffer, size_t* size) {
                           *size > INT_MAX ? INT_MAX : (int) *size,
                           NULL,
                           NULL);
-  uv__free(utf16_buffer);
-
   if (r == 0) {
     return uv_translate_sys_error(GetLastError());
   }
@@ -223,61 +213,43 @@ int uv_cwd(char* buffer, size_t* size) {
 
 
 int uv_chdir(const char* dir) {
-  WCHAR *utf16_buffer;
-  size_t utf16_len, new_utf16_len;
+  WCHAR utf16_buffer[MAX_PATH];
+  size_t utf16_len;
   WCHAR drive_letter, env_var[4];
 
   if (dir == NULL) {
     return UV_EINVAL;
   }
 
-  utf16_len = MultiByteToWideChar(CP_UTF8,
-                                  0,
-                                  dir,
-                                  -1,
-                                  NULL,
-                                  0);
-  if (utf16_len == 0) {
-    return uv_translate_sys_error(GetLastError());
-  }
-  utf16_buffer = uv__malloc(utf16_len * sizeof(WCHAR));
-  if (utf16_buffer == NULL) {
-    return UV_ENOMEM;
-  }
-
   if (MultiByteToWideChar(CP_UTF8,
                           0,
                           dir,
                           -1,
                           utf16_buffer,
-                          utf16_len) == 0) {
-    uv__free(utf16_buffer);
-    return uv_translate_sys_error(GetLastError());
+                          MAX_PATH) == 0) {
+    DWORD error = GetLastError();
+    /* The maximum length of the current working directory is 260 chars,
+     * including terminating null. If it doesn't fit, the path name must be too
+     * long. */
+    if (error == ERROR_INSUFFICIENT_BUFFER) {
+      return UV_ENAMETOOLONG;
+    } else {
+      return uv_translate_sys_error(error);
+    }
   }
 
   if (!SetCurrentDirectoryW(utf16_buffer)) {
-    uv__free(utf16_buffer);
     return uv_translate_sys_error(GetLastError());
   }
 
   /* Windows stores the drive-local path in an "hidden" environment variable,
    * which has the form "=C:=C:\Windows". SetCurrentDirectory does not update
    * this, so we'll have to do it. */
-  new_utf16_len = GetCurrentDirectoryW(utf16_len, utf16_buffer);
-  if (new_utf16_len > utf16_len ) {
-    uv__free(utf16_buffer);
-    utf16_buffer = uv__malloc(new_utf16_len * sizeof(WCHAR));
-    if (utf16_buffer == NULL) {
-      /* When updating the environment variable fails, return UV_OK anyway.
-       * We did successfully change current working directory, only updating
-       * hidden env variable failed. */
-      return 0;
-    }
-    new_utf16_len = GetCurrentDirectoryW(new_utf16_len, utf16_buffer);
-  }
+  utf16_len = GetCurrentDirectoryW(MAX_PATH, utf16_buffer);
   if (utf16_len == 0) {
-    uv__free(utf16_buffer);
-    return 0;
+    return uv_translate_sys_error(GetLastError());
+  } else if (utf16_len > MAX_PATH) {
+    return UV_EIO;
   }
 
   /* The returned directory should not have a trailing slash, unless it points
@@ -309,10 +281,11 @@ int uv_chdir(const char* dir) {
     env_var[2] = L':';
     env_var[3] = L'\0';
 
-    SetEnvironmentVariableW(env_var, utf16_buffer);
+    if (!SetEnvironmentVariableW(env_var, utf16_buffer)) {
+      return uv_translate_sys_error(GetLastError());
+    }
   }
 
-  uv__free(utf16_buffer);
   return 0;
 }
 
@@ -385,10 +358,6 @@ char** uv_setup_args(int argc, char** ar
 }
 
 
-void uv__process_title_cleanup(void) {
-}
-
-
 int uv_set_process_title(const char* title) {
   int err;
   int length;
@@ -1191,29 +1160,20 @@ int uv_os_homedir(char* buffer, size_t*
 
 
 int uv_os_tmpdir(char* buffer, size_t* size) {
-  wchar_t *path;
+  wchar_t path[MAX_PATH + 2];
   DWORD bufsize;
   size_t len;
 
   if (buffer == NULL || size == NULL || *size == 0)
     return UV_EINVAL;
 
-  len = 0;
-  len = GetTempPathW(0, NULL);
-  if (len == 0) {
-    return uv_translate_sys_error(GetLastError());
-  }
-  /* Include space for terminating null char. */
-  len += 1;
-  path = uv__malloc(len * sizeof(wchar_t));
-  if (path == NULL) {
-    return UV_ENOMEM;
-  }
-  len  = GetTempPathW(len, path);
+  len = GetTempPathW(ARRAY_SIZE(path), path);
 
   if (len == 0) {
-    uv__free(path);
     return uv_translate_sys_error(GetLastError());
+  } else if (len > ARRAY_SIZE(path)) {
+    /* This should not be possible */
+    return UV_EIO;
   }
 
   /* The returned directory should not have a trailing slash, unless it points
@@ -1228,10 +1188,8 @@ int uv_os_tmpdir(char* buffer, size_t* s
   bufsize = WideCharToMultiByte(CP_UTF8, 0, path, -1, NULL, 0, NULL, NULL);
 
   if (bufsize == 0) {
-    uv__free(path);
     return uv_translate_sys_error(GetLastError());
   } else if (bufsize > *size) {
-    uv__free(path);
     *size = bufsize;
     return UV_ENOBUFS;
   }
@@ -1245,7 +1203,6 @@ int uv_os_tmpdir(char* buffer, size_t* s
                                 *size,
                                 NULL,
                                 NULL);
-  uv__free(path);
 
   if (bufsize == 0)
     return uv_translate_sys_error(GetLastError());
@@ -1365,7 +1322,7 @@ int uv__convert_utf8_to_utf16(const char
 int uv__getpwuid_r(uv_passwd_t* pwd) {
   HANDLE token;
   wchar_t username[UNLEN + 1];
-  wchar_t *path;
+  wchar_t path[MAX_PATH];
   DWORD bufsize;
   int r;
 
@@ -1376,24 +1333,15 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   if (OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &token) == 0)
     return uv_translate_sys_error(GetLastError());
 
-  bufsize = 0;
-  GetUserProfileDirectoryW(token, NULL, &bufsize);
-  if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
+  bufsize = ARRAY_SIZE(path);
+  if (!GetUserProfileDirectoryW(token, path, &bufsize)) {
     r = GetLastError();
     CloseHandle(token);
-    return uv_translate_sys_error(r);
-  }
 
-  path = uv__malloc(bufsize * sizeof(wchar_t));
-  if (path == NULL) {
-    CloseHandle(token);
-    return UV_ENOMEM;
-  }
+    /* This should not be possible */
+    if (r == ERROR_INSUFFICIENT_BUFFER)
+      return UV_ENOMEM;
 
-  if (!GetUserProfileDirectoryW(token, path, &bufsize)) {
-    r = GetLastError();
-    CloseHandle(token);
-    uv__free(path);
     return uv_translate_sys_error(r);
   }
 
@@ -1403,7 +1351,6 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   bufsize = ARRAY_SIZE(username);
   if (!GetUserNameW(username, &bufsize)) {
     r = GetLastError();
-    uv__free(path);
 
     /* This should not be possible */
     if (r == ERROR_INSUFFICIENT_BUFFER)
@@ -1414,7 +1361,6 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
 
   pwd->homedir = NULL;
   r = uv__convert_utf16_to_utf8(path, -1, &pwd->homedir);
-  uv__free(path);
 
   if (r != 0)
     return r;
@@ -1456,7 +1402,7 @@ int uv_os_environ(uv_env_item_t** envite
   for (penv = env, i = 0; *penv != L'\0'; penv += wcslen(penv) + 1, i++);
 
   *envitems = uv__calloc(i, sizeof(**envitems));
-  if (*envitems == NULL) {
+  if (envitems == NULL) {
     FreeEnvironmentStringsW(env);
     return UV_ENOMEM;
   }
@@ -1512,9 +1458,7 @@ fail:
 
 
 int uv_os_getenv(const char* name, char* buffer, size_t* size) {
-  wchar_t fastvar[512];
-  wchar_t* var;
-  DWORD varlen;
+  wchar_t var[MAX_ENV_VAR_LENGTH];
   wchar_t* name_w;
   DWORD bufsize;
   size_t len;
@@ -1528,52 +1472,25 @@ int uv_os_getenv(const char* name, char*
   if (r != 0)
     return r;
 
-  var = fastvar;
-  varlen = ARRAY_SIZE(fastvar);
-
-  for (;;) {
-    SetLastError(ERROR_SUCCESS);
-    len = GetEnvironmentVariableW(name_w, var, varlen);
-
-    if (len < varlen)
-      break;
-
-    /* Try repeatedly because we might have been preempted by another thread
-     * modifying the environment variable just as we're trying to read it.
-     */
-    if (var != fastvar)
-      uv__free(var);
-
-    varlen = 1 + len;
-    var = uv__malloc(varlen * sizeof(*var));
-
-    if (var == NULL) {
-      r = UV_ENOMEM;
-      goto fail;
-    }
-  }
-
+  SetLastError(ERROR_SUCCESS);
+  len = GetEnvironmentVariableW(name_w, var, MAX_ENV_VAR_LENGTH);
   uv__free(name_w);
-  name_w = NULL;
+  assert(len < MAX_ENV_VAR_LENGTH); /* len does not include the null */
 
   if (len == 0) {
     r = GetLastError();
-    if (r != ERROR_SUCCESS) {
-      r = uv_translate_sys_error(r);
-      goto fail;
-    }
+    if (r != ERROR_SUCCESS)
+      return uv_translate_sys_error(r);
   }
 
   /* Check how much space we need */
   bufsize = WideCharToMultiByte(CP_UTF8, 0, var, -1, NULL, 0, NULL, NULL);
 
   if (bufsize == 0) {
-    r = uv_translate_sys_error(GetLastError());
-    goto fail;
+    return uv_translate_sys_error(GetLastError());
   } else if (bufsize > *size) {
     *size = bufsize;
-    r = UV_ENOBUFS;
-    goto fail;
+    return UV_ENOBUFS;
   }
 
   /* Convert to UTF-8 */
@@ -1586,23 +1503,11 @@ int uv_os_getenv(const char* name, char*
                                 NULL,
                                 NULL);
 
-  if (bufsize == 0) {
-    r = uv_translate_sys_error(GetLastError());
-    goto fail;
-  }
+  if (bufsize == 0)
+    return uv_translate_sys_error(GetLastError());
 
   *size = bufsize - 1;
-  r = 0;
-
-fail:
-
-  if (name_w != NULL)
-    uv__free(name_w);
-
-  if (var != fastvar)
-    uv__free(var);
-
-  return r;
+  return 0;
 }
 
 
@@ -1957,10 +1862,13 @@ int uv_gettimeofday(uv_timeval64_t* tv)
 }
 
 int uv__random_rtlgenrandom(void* buf, size_t buflen) {
+  if (pRtlGenRandom == NULL)
+    return UV_ENOSYS;
+
   if (buflen == 0)
     return 0;
 
-  if (SystemFunction036(buf, buflen) == FALSE)
+  if (pRtlGenRandom(buf, buflen) == FALSE)
     return UV_EIO;
 
   return 0;
--- a/deps/uv/src/win/winapi.c
+++ b/deps/uv/src/win/winapi.c
@@ -36,6 +36,9 @@ sNtQueryDirectoryFile pNtQueryDirectoryF
 sNtQuerySystemInformation pNtQuerySystemInformation;
 sNtQueryInformationProcess pNtQueryInformationProcess;
 
+/* Advapi32 function pointers */
+sRtlGenRandom pRtlGenRandom;
+
 /* Kernel32 function pointers */
 sGetQueuedCompletionStatusEx pGetQueuedCompletionStatusEx;
 
@@ -51,6 +54,7 @@ void uv_winapi_init(void) {
   HMODULE powrprof_module;
   HMODULE user32_module;
   HMODULE kernel32_module;
+  HMODULE advapi32_module;
 
   ntdll_module = GetModuleHandleA("ntdll.dll");
   if (ntdll_module == NULL) {
@@ -134,4 +138,12 @@ void uv_winapi_init(void) {
     pSetWinEventHook = (sSetWinEventHook)
       GetProcAddress(user32_module, "SetWinEventHook");
   }
+
+  advapi32_module = GetModuleHandleA("advapi32.dll");
+  if (advapi32_module == NULL) {
+    uv_fatal_error(GetLastError(), "GetModuleHandleA");
+  }
+
+  pRtlGenRandom =
+      (sRtlGenRandom) GetProcAddress(advapi32_module, "SystemFunction036");
 }
--- a/deps/uv/src/win/winapi.h
+++ b/deps/uv/src/win/winapi.h
@@ -4152,10 +4152,6 @@ typedef const UNICODE_STRING *PCUNICODE_
       struct {
         UCHAR  DataBuffer[1];
       } GenericReparseBuffer;
-      struct {
-        ULONG StringCount;
-        WCHAR StringList[1];
-      } AppExecLinkReparseBuffer;
     };
   } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
 #endif
@@ -4521,9 +4517,6 @@ typedef struct _SYSTEM_PROCESSOR_PERFORM
 #ifndef IO_REPARSE_TAG_SYMLINK
 # define IO_REPARSE_TAG_SYMLINK (0xA000000CL)
 #endif
-#ifndef IO_REPARSE_TAG_APPEXECLINK
-# define IO_REPARSE_TAG_APPEXECLINK (0x8000001BL)
-#endif
 
 typedef VOID (NTAPI *PIO_APC_ROUTINE)
              (PVOID ApcContext,
@@ -4597,6 +4590,11 @@ typedef NTSTATUS (NTAPI *sNtQueryInforma
                   PULONG ReturnLength);
 
 /*
+ * Advapi32 headers
+ */
+typedef BOOLEAN (WINAPI *sRtlGenRandom)(PVOID Buffer, ULONG BufferLength);
+
+/*
  * Kernel32 headers
  */
 #ifndef FILE_SKIP_COMPLETION_PORT_ON_SUCCESS
@@ -4738,6 +4736,9 @@ extern sNtQueryDirectoryFile pNtQueryDir
 extern sNtQuerySystemInformation pNtQuerySystemInformation;
 extern sNtQueryInformationProcess pNtQueryInformationProcess;
 
+/* Advapi32 function pointers */
+extern sRtlGenRandom pRtlGenRandom;
+
 /* Kernel32 function pointers */
 extern sGetQueuedCompletionStatusEx pGetQueuedCompletionStatusEx;
 
--- a/deps/uv/src/win/winsock.c
+++ b/deps/uv/src/win/winsock.c
@@ -74,6 +74,11 @@ BOOL uv_get_connectex_function(SOCKET so
 }
 
 
+static int error_means_no_support(DWORD error) {
+  return error == WSAEPROTONOSUPPORT || error == WSAESOCKTNOSUPPORT ||
+         error == WSAEPFNOSUPPORT || error == WSAEAFNOSUPPORT;
+}
+
 
 void uv_winsock_init(void) {
   WSADATA wsa_data;
@@ -100,36 +105,50 @@ void uv_winsock_init(void) {
     uv_fatal_error(errorno, "WSAStartup");
   }
 
-  /* Try to detect non-IFS LSPs */
-  uv_tcp_non_ifs_lsp_ipv4 = 1;
+  /* Detect non-IFS LSPs */
   dummy = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
+
   if (dummy != INVALID_SOCKET) {
     opt_len = (int) sizeof protocol_info;
     if (getsockopt(dummy,
                    SOL_SOCKET,
                    SO_PROTOCOL_INFOW,
                    (char*) &protocol_info,
-                   &opt_len) == 0) {
-      if (protocol_info.dwServiceFlags1 & XP1_IFS_HANDLES)
-        uv_tcp_non_ifs_lsp_ipv4 = 0;
-    }
-    closesocket(dummy);
+                   &opt_len) == SOCKET_ERROR)
+      uv_fatal_error(WSAGetLastError(), "getsockopt");
+
+    if (!(protocol_info.dwServiceFlags1 & XP1_IFS_HANDLES))
+      uv_tcp_non_ifs_lsp_ipv4 = 1;
+
+    if (closesocket(dummy) == SOCKET_ERROR)
+      uv_fatal_error(WSAGetLastError(), "closesocket");
+
+  } else if (!error_means_no_support(WSAGetLastError())) {
+    /* Any error other than "socket type not supported" is fatal. */
+    uv_fatal_error(WSAGetLastError(), "socket");
   }
 
-  /* Try to detect IPV6 support and non-IFS LSPs */
-  uv_tcp_non_ifs_lsp_ipv6 = 1;
+  /* Detect IPV6 support and non-IFS LSPs */
   dummy = socket(AF_INET6, SOCK_STREAM, IPPROTO_IP);
+
   if (dummy != INVALID_SOCKET) {
     opt_len = (int) sizeof protocol_info;
     if (getsockopt(dummy,
                    SOL_SOCKET,
                    SO_PROTOCOL_INFOW,
                    (char*) &protocol_info,
-                   &opt_len) == 0) {
-      if (protocol_info.dwServiceFlags1 & XP1_IFS_HANDLES)
-        uv_tcp_non_ifs_lsp_ipv6 = 0;
-    }
-    closesocket(dummy);
+                   &opt_len) == SOCKET_ERROR)
+      uv_fatal_error(WSAGetLastError(), "getsockopt");
+
+    if (!(protocol_info.dwServiceFlags1 & XP1_IFS_HANDLES))
+      uv_tcp_non_ifs_lsp_ipv6 = 1;
+
+    if (closesocket(dummy) == SOCKET_ERROR)
+      uv_fatal_error(WSAGetLastError(), "closesocket");
+
+  } else if (!error_means_no_support(WSAGetLastError())) {
+    /* Any error other than "socket type not supported" is fatal. */
+    uv_fatal_error(WSAGetLastError(), "socket");
   }
 }
 
--- a/deps/uv/SUPPORTED_PLATFORMS.md
+++ b/deps/uv/SUPPORTED_PLATFORMS.md
@@ -47,9 +47,8 @@ All functionality related to the new pla
 file inside ``src/unix/`` unless it's already done in a common file, in which
 case adding an `ifdef` is fine.
 
-Two build systems are supported: autotools and cmake. Ideally both need to be
-supported, but if one of the two does not support the new platform it can be
-left out.
+Two build systems are supported: autotools and GYP. Ideally both need to be
+supported, but if GYP does not support the new platform it can be left out.
 
 ### Windows
 
--- a/deps/uv/uv.gyp
+++ b/deps/uv/uv.gyp
@@ -93,7 +93,7 @@
           '-Wno-unused-parameter',
           '-Wstrict-prototypes',
         ],
-        'OTHER_CFLAGS': [ '-g', '--std=gnu89' ],
+        'OTHER_CFLAGS': [ '-g', '--std=gnu89', '-pedantic' ],
       },
       'conditions': [
         [ 'OS=="win"', {
@@ -217,6 +217,7 @@
             '-fvisibility=hidden',
             '-g',
             '--std=gnu89',
+            '-pedantic',
             '-Wall',
             '-Wextra',
             '-Wno-unused-parameter',
--- a/deps/uv/uv_win_longpath.manifest
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="utf-8" ?>
-<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
-    <application xmlns="urn:schemas-microsoft-com:asm.v3">
-        <windowsSettings xmlns:ws2="http://schemas.microsoft.com/SMI/2016/WindowsSettings">
-            <ws2:longPathAware>true</ws2:longPathAware>
-        </windowsSettings>
-    </application>
-</assembly>
--- /dev/null
+++ b/deps/uv/vcbuild.bat
@@ -0,0 +1,184 @@
+@echo off
+
+cd %~dp0
+
+if /i "%1"=="help" goto help
+if /i "%1"=="--help" goto help
+if /i "%1"=="-help" goto help
+if /i "%1"=="/help" goto help
+if /i "%1"=="?" goto help
+if /i "%1"=="-?" goto help
+if /i "%1"=="--?" goto help
+if /i "%1"=="/?" goto help
+
+@rem Process arguments.
+set config=
+set target=Build
+set target_arch=ia32
+set target_env=
+set noprojgen=
+set nobuild=
+set run=
+set vs_toolset=x86
+set msbuild_platform=WIN32
+set library=static_library
+
+:next-arg
+if "%1"=="" goto args-done
+if /i "%1"=="debug"        set config=Debug&goto arg-ok
+if /i "%1"=="release"      set config=Release&goto arg-ok
+if /i "%1"=="test"         set run=run-tests.exe&goto arg-ok
+if /i "%1"=="bench"        set run=run-benchmarks.exe&goto arg-ok
+if /i "%1"=="clean"        set target=Clean&goto arg-ok
+if /i "%1"=="vs2017"       set target_env=vs2017&goto arg-ok
+if /i "%1"=="noprojgen"    set noprojgen=1&goto arg-ok
+if /i "%1"=="nobuild"      set nobuild=1&goto arg-ok
+if /i "%1"=="x86"          set target_arch=ia32&set msbuild_platform=WIN32&set vs_toolset=x86&goto arg-ok
+if /i "%1"=="ia32"         set target_arch=ia32&set msbuild_platform=WIN32&set vs_toolset=x86&goto arg-ok
+if /i "%1"=="x64"          set target_arch=x64&set msbuild_platform=x64&set vs_toolset=x64&goto arg-ok
+if /i "%1"=="shared"       set library=shared_library&goto arg-ok
+if /i "%1"=="static"       set library=static_library&goto arg-ok
+:arg-ok
+shift
+goto next-arg
+:args-done
+
+if defined WindowsSDKDir goto select-target
+if defined VCINSTALLDIR goto select-target
+
+@rem Look for Visual Studio 2017 only if explicitly requested.
+if "%target_env%" NEQ "vs2017" goto vs-set-2015
+echo Looking for Visual Studio 2017
+@rem Check if VS2017 is already setup, and for the requested arch.
+if "_%VisualStudioVersion%_" == "_15.0_" if "_%VSCMD_ARG_TGT_ARCH%_"=="_%vs_toolset%_" goto found_vs2017
+set "VSINSTALLDIR="
+call tools\vswhere_usability_wrapper.cmd
+if "_%VCINSTALLDIR%_" == "__" goto vs-set-2015
+@rem Need to clear VSINSTALLDIR for vcvarsall to work as expected.
+@rem Keep current working directory after call to vcvarsall
+set "VSCMD_START_DIR=%CD%"
+set vcvars_call="%VCINSTALLDIR%\Auxiliary\Build\vcvarsall.bat" %vs_toolset%
+echo calling: %vcvars_call%
+call %vcvars_call%
+
+:found_vs2017
+echo Found MSVS version %VisualStudioVersion%
+if %VSCMD_ARG_TGT_ARCH%==x64 set target_arch=x64&set msbuild_platform=x64&set vs_toolset=x64
+set GYP_MSVS_VERSION=2017
+goto select-target
+
+
+@rem Look for Visual Studio 2015
+:vs-set-2015
+if not defined VS140COMNTOOLS goto vc-set-2013
+if not exist "%VS140COMNTOOLS%\..\..\vc\vcvarsall.bat" goto vc-set-2013
+call "%VS140COMNTOOLS%\..\..\vc\vcvarsall.bat" %vs_toolset%
+set GYP_MSVS_VERSION=2015
+echo Using Visual Studio 2015
+goto select-target
+
+:vc-set-2013
+@rem Look for Visual Studio 2013
+if not defined VS120COMNTOOLS goto vc-set-2012
+if not exist "%VS120COMNTOOLS%\..\..\vc\vcvarsall.bat" goto vc-set-2012
+call "%VS120COMNTOOLS%\..\..\vc\vcvarsall.bat" %vs_toolset%
+set GYP_MSVS_VERSION=2013
+echo Using Visual Studio 2013
+goto select-target
+
+:vc-set-2012
+@rem Look for Visual Studio 2012
+if not defined VS110COMNTOOLS goto vc-set-2010
+if not exist "%VS110COMNTOOLS%\..\..\vc\vcvarsall.bat" goto vc-set-2010
+call "%VS110COMNTOOLS%\..\..\vc\vcvarsall.bat" %vs_toolset%
+set GYP_MSVS_VERSION=2012
+echo Using Visual Studio 2012
+goto select-target
+
+:vc-set-2010
+@rem Look for Visual Studio 2010
+if not defined VS100COMNTOOLS goto vc-set-2008
+if not exist "%VS100COMNTOOLS%\..\..\vc\vcvarsall.bat" goto vc-set-2008
+call "%VS100COMNTOOLS%\..\..\vc\vcvarsall.bat" %vs_toolset%
+set GYP_MSVS_VERSION=2010
+echo Using Visual Studio 2010
+goto select-target
+
+:vc-set-2008
+@rem Look for Visual Studio 2008
+if not defined VS90COMNTOOLS goto vc-set-notfound
+if not exist "%VS90COMNTOOLS%\..\..\vc\vcvarsall.bat" goto vc-set-notfound
+call "%VS90COMNTOOLS%\..\..\vc\vcvarsall.bat" %vs_toolset%
+set GYP_MSVS_VERSION=2008
+echo Using Visual Studio 2008
+goto select-target
+
+:vc-set-notfound
+echo Warning: Visual Studio not found
+
+:select-target
+if not "%config%"=="" goto project-gen
+if "%run%"=="run-tests.exe" set config=Debug& goto project-gen
+if "%run%"=="run-benchmarks.exe" set config=Release& goto project-gen
+set config=Debug
+
+:project-gen
+@rem Skip project generation if requested.
+if defined noprojgen goto msbuild
+
+@rem Generate the VS project.
+if exist build\gyp goto have_gyp
+echo git clone https://chromium.googlesource.com/external/gyp build/gyp
+git clone https://chromium.googlesource.com/external/gyp build/gyp
+if errorlevel 1 goto gyp_install_failed
+goto have_gyp
+
+:gyp_install_failed
+echo Failed to download gyp. Make sure you have git installed, or
+echo manually install gyp into %~dp0build\gyp.
+exit /b 1
+
+:have_gyp
+if not defined PYTHON set PYTHON=python
+"%PYTHON%" gyp_uv.py -Dtarget_arch=%target_arch% -Duv_library=%library%
+if errorlevel 1 goto create-msvs-files-failed
+if not exist uv.sln goto create-msvs-files-failed
+echo Project files generated.
+
+:msbuild
+@rem Skip project generation if requested.
+if defined nobuild goto run
+
+@rem Check if VS build env is available
+if defined VCINSTALLDIR goto msbuild-found
+if defined WindowsSDKDir goto msbuild-found
+echo Build skipped. To build, this file needs to run from VS cmd prompt.
+goto run
+
+@rem Build the sln with msbuild.
+:msbuild-found
+msbuild uv.sln /t:%target% /p:Configuration=%config% /p:Platform="%msbuild_platform%" /clp:NoSummary;NoItemAndPropertyList;Verbosity=minimal /nologo
+if errorlevel 1 exit /b 1
+msbuild test\test.sln /t:%target% /p:Configuration=%config% /p:Platform="%msbuild_platform%" /clp:NoSummary;NoItemAndPropertyList;Verbosity=minimal /nologo
+if errorlevel 1 exit /b 1
+
+:run
+@rem Run tests if requested.
+if "%run%"=="" goto exit
+echo running 'test\%config%\%run%'
+test\%config%\%run%
+goto exit
+
+:create-msvs-files-failed
+echo Failed to create vc project files.
+exit /b 1
+
+:help
+echo vcbuild.bat [debug/release] [test/bench] [clean] [noprojgen] [nobuild] [vs2017] [x86/x64] [static/shared]
+echo Examples:
+echo   vcbuild.bat              : builds debug build
+echo   vcbuild.bat test         : builds debug build and runs tests
+echo   vcbuild.bat release bench: builds release build and runs benchmarks
+goto exit
+
+:exit
