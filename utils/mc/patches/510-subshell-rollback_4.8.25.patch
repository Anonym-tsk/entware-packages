diff -Naur mc-4.8.26.orig/src/filemanager/layout.c mc-4.8.26/src/filemanager/layout.c
--- mc-4.8.26.orig/src/filemanager/layout.c	2021-01-10 14:50:16.000000000 +0300
+++ mc-4.8.26/src/filemanager/layout.c	2021-03-26 19:00:15.028213716 +0300
@@ -966,6 +966,9 @@
     char *tmp_prompt = (char *) mc_prompt;
 
 #ifdef ENABLE_SUBSHELL
+    if (!command_prompt || subshell_prompt == NULL)
+        return;
+
     if (mc_global.tty.use_subshell)
     {
         tmp_prompt = g_string_free (subshell_prompt, FALSE);
@@ -1498,11 +1501,7 @@
     (void) fd;
     (void) unused;
 
-    if (should_read_new_subshell_prompt)
-        do_load_prompt ();
-    else
-        flush_subshell (0, QUIETLY);
-
+    do_load_prompt ();
     return 0;
 }
 #endif /* ENABLE_SUBSHELL */
diff -Naur mc-4.8.26.orig/src/subshell/common.c mc-4.8.26/src/subshell/common.c
--- mc-4.8.26.orig/src/subshell/common.c	2021-01-21 20:13:35.000000000 +0300
+++ mc-4.8.26/src/subshell/common.c	2020-11-30 22:25:26.180912859 +0300
@@ -9,26 +9,25 @@
    Aliaksey Kandratsenka <alk@tut.by>
    Andreas Mohr <and@gmx.li>
    Andrew Borodin <aborodin@vmail.ru>
+   Andrew Borodin <borodin@borodin.zarya>
    Andrew V. Samoilov <sav@bcs.zp.ua>
    Chris Owen <chris@candu.co.uk>
    Claes Nästén <me@pekdon.net>
    Egmont Koblinger <egmont@gmail.com>
    Enrico Weigelt, metux IT service <weigelt@metux.de>
-   Eric Roberts <ericmrobertsdeveloper@gmail.com>
    Igor Urazov <z0rc3r@gmail.com>
    Ilia Maslakov <il.smind@gmail.com>
    Leonard den Ottolander <leonard@den.ottolander.nl>
    Miguel de Icaza <miguel@novell.com>
    Mikhail S. Pobolovets <styx.mp@gmail.com>
    Norbert Warmuth <nwarmuth@privat.circular.de>
-   Oswald Buddenhagen <oswald.buddenhagen@gmx.de>
    Patrick Winnertz <winnie@debian.org>
    Pavel Machek <pavel@suse.cz>
    Pavel Roskin <proski@gnu.org>
    Pavel Tsekov <ptsekov@gmx.net>
    Roland Illig <roland.illig@gmx.de>
    Sergei Trofimovich <slyfox@inbox.ru>
-   Slava Zanko <slavazanko@gmail.com>
+   Slava Zanko <slavazanko@gmail.com>, 2013,2015.
    Timur Bakeyev <mc@bat.ru>
    Vit Rosin <vit_r@list.ru>
 
@@ -106,9 +105,6 @@
 #include "lib/util.h"
 #include "lib/widget.h"
 
-#include "src/filemanager/layout.h"     /* setup_cmdline() */
-#include "src/filemanager/command.h"    /* cmdline */
-
 #include "subshell.h"
 #include "internal.h"
 
@@ -127,10 +123,6 @@
 /* We need to paint it after CONSOLE_RESTORE, see: load_prompt */
 gboolean update_subshell_prompt = FALSE;
 
-/* If set, then a command has just finished executing, and we need */
-/* to be on the lookout for a new prompt string from the subshell. */
-gboolean should_read_new_subshell_prompt;
-
 /*** file scope macro definitions ****************************************************************/
 
 #ifndef WEXITSTATUS
@@ -159,14 +151,6 @@
     WRITE = 1
 };
 
-/* This is the keybinding that is sent to the shell, to make the shell send us the contents of
- * the current command buffer. */
-#define SHELL_BUFFER_KEYBINDING "_"
-
-/* This is the keybinding that is sent to the shell, to make the shell send us the location of
- * the cursor. */
-#define SHELL_CURSOR_KEYBINDING "+"
-
 /*** file scope variables ************************************************************************/
 
 /* tcsh closes all non-standard file descriptors, so we have to use a pipe */
@@ -185,9 +169,6 @@
 /* To pass CWD info from the subshell to MC */
 static int subshell_pipe[2];
 
-/* To pass command buffer info from the subshell to MC */
-static int command_buffer_pipe[2];
-
 /* The subshell's process ID */
 static pid_t subshell_pid = 1;
 
@@ -197,17 +178,6 @@
 /* Flag to indicate whether the subshell is ready for next command */
 static int subshell_ready;
 
-/* Flag to indicate if the subshell supports the persistent buffer feature. */
-static gboolean use_persistent_buffer = FALSE;
-
-/* Flag to indicate if the contents of the subshell command line need to be cleared before */
-/* executing a command. This should only end up set to true if there is some sort of error. */
-/* This allows us to recover gracefully from an error. */
-static gboolean subshell_should_clear_command_line = FALSE;
-
-/* This is the local variable where the subshell prompt is stored while we are working on it. */
-static GString *subshell_prompt_temp_buffer = NULL;
-
 /* The following two flags can be changed by the SIGCHLD handler. This is */
 /* OK, because the 'int' type is updated atomically on all known machines */
 static volatile int subshell_alive, subshell_stopped;
@@ -383,7 +353,7 @@
 
     /* Attach all our standard file descriptors to the pty */
 
-    /* This is done just before the exec, because stderr must still      */
+    /* This is done just before the fork, because stderr must still      */
     /* be connected to the real tty during the above error messages; */
     /* otherwise the user will never see them.                   */
 
@@ -392,10 +362,6 @@
     dup2 (subshell_pty_slave, STDERR_FILENO);
 
     close (subshell_pipe[READ]);
-
-    if (use_persistent_buffer)
-        close (command_buffer_pipe[READ]);
-
     close (subshell_pty_slave); /* These may be FD_CLOEXEC, but just in case... */
     /* Close master side of pty.  This is important; apart from */
     /* freeing up the descriptor for use in the subshell, it also       */
@@ -503,232 +469,6 @@
 }
 
 /* --------------------------------------------------------------------------------------------- */
-/* Get the contents of the current subshell command line buffer, and */
-/* transfer the contents to the panel command prompt. */
-
-static gboolean
-read_command_line_buffer (gboolean test_mode)
-{
-    char subshell_command_buffer[BUF_LARGE];
-    char subshell_cursor_buffer[BUF_SMALL];
-
-    fd_set read_set;
-    int i;
-    ssize_t bytes;
-    struct timeval subshell_prompt_timer = { 0, 0 };
-    int command_buffer_length;
-    int command_buffer_char_length;
-    int bash_version;
-    int cursor_position;
-    int maxfdp;
-    int rc;
-
-    if (!use_persistent_buffer)
-        return TRUE;
-
-    FD_ZERO (&read_set);
-    FD_SET (command_buffer_pipe[READ], &read_set);
-    maxfdp = command_buffer_pipe[READ];
-
-    /* First, flush the command buffer pipe. This pipe shouldn't be written
-     * to under normal circumstances, but if it somehow does get written
-     * to, we need to make sure to discard whatever data is there before
-     * we try to use it. */
-    while ((rc = select (maxfdp + 1, &read_set, NULL, NULL, &subshell_prompt_timer)) != 0)
-    {
-        if (rc == -1)
-        {
-            if (errno == EINTR)
-                continue;
-
-            return FALSE;
-        }
-
-        if (rc == 1)
-        {
-            bytes = read (command_buffer_pipe[READ], subshell_command_buffer,
-                          sizeof (subshell_command_buffer));
-            (void) bytes;
-        }
-    }
-
-    /* get contents of command line buffer */
-    write_all (mc_global.tty.subshell_pty, ESC_STR SHELL_BUFFER_KEYBINDING,
-               sizeof (ESC_STR SHELL_CURSOR_KEYBINDING) - 1);
-
-    subshell_prompt_timer.tv_sec = 1;
-    FD_ZERO (&read_set);
-    FD_SET (command_buffer_pipe[READ], &read_set);
-
-    while ((rc = select (maxfdp + 1, &read_set, NULL, NULL, &subshell_prompt_timer)) != 1)
-    {
-        if (rc == -1)
-        {
-            if (errno == EINTR)
-                continue;
-
-            return FALSE;
-        }
-
-        if (rc == 0)
-            return FALSE;
-    }
-
-    bytes =
-        read (command_buffer_pipe[READ], subshell_command_buffer, sizeof (subshell_command_buffer));
-    if (bytes == 0 || bytes == sizeof (subshell_command_buffer))
-        return FALSE;
-
-    command_buffer_char_length = bytes - 1;
-    subshell_command_buffer[command_buffer_char_length] = '\0';
-    command_buffer_length = str_length (subshell_command_buffer);
-
-    /* get cursor position */
-    write_all (mc_global.tty.subshell_pty, ESC_STR SHELL_CURSOR_KEYBINDING,
-               sizeof (ESC_STR SHELL_CURSOR_KEYBINDING) - 1);
-
-    subshell_prompt_timer.tv_sec = 1;
-    subshell_prompt_timer.tv_usec = 0;
-    FD_ZERO (&read_set);
-    FD_SET (command_buffer_pipe[READ], &read_set);
-
-    while ((rc = select (maxfdp + 1, &read_set, NULL, NULL, &subshell_prompt_timer)) != 1)
-    {
-        if (rc == -1)
-        {
-            if (errno == EINTR)
-                continue;
-
-            return FALSE;
-        }
-
-        if (rc == 0)
-            return FALSE;
-    }
-
-    bytes =
-        read (command_buffer_pipe[READ], subshell_cursor_buffer, sizeof (subshell_cursor_buffer));
-    if (bytes == 0)
-        return FALSE;
-
-    subshell_cursor_buffer[bytes - 1] = '\0';
-    if (mc_global.shell->type == SHELL_BASH)
-    {
-        if (sscanf (subshell_cursor_buffer, "%d:%d", &bash_version, &cursor_position) != 2)
-            return FALSE;
-    }
-    else
-    {
-        if (sscanf (subshell_cursor_buffer, "%d", &cursor_position) != 1)
-            return FALSE;
-        bash_version = 1000;
-    }
-
-    if (test_mode)
-        return TRUE;
-
-    /* Substitute non-text characters in the command buffer, such as tab, or newline, as this
-     * could cause problems. */
-    for (i = 0; i < command_buffer_char_length; i++)
-        if ((unsigned char) subshell_command_buffer[i] < 32
-            || (unsigned char) subshell_command_buffer[i] == 127)
-            subshell_command_buffer[i] = ' ';
-
-    input_assign_text (cmdline, "");
-    input_insert (cmdline, subshell_command_buffer, FALSE);
-
-    if (bash_version < 5)       /* implies SHELL_BASH */
-    {
-        /* We need to do this because bash < v5 gives the cursor position in a utf-8 string based
-         * on the location in bytes, not in unicode characters. */
-        char *curr, *stop;
-
-        curr = subshell_command_buffer;
-        stop = curr + cursor_position;
-
-        for (cursor_position = 0; curr < stop; cursor_position++)
-            str_next_char_safe (&curr);
-    }
-    if (cursor_position > command_buffer_length)
-        cursor_position = command_buffer_length;
-    cmdline->point = cursor_position;
-    /* We send any remaining data to STDOUT before we finish. */
-    flush_subshell (0, VISIBLY);
-
-    /* Now we erase the current contents of the command line buffer */
-    if (mc_global.shell->type != SHELL_ZSH)
-    {
-        /* In zsh, we can just press c-u to clear the line, without needing to go to the end of
-         * the line first first. In all other shells, we must go to the end of the line first. */
-
-        /* If we are not at the end of the line, we go to the end. */
-        if (cursor_position != command_buffer_length)
-        {
-            write_all (mc_global.tty.subshell_pty, "\005", 1);
-            if (flush_subshell (1, VISIBLY) != 1)
-                return FALSE;
-        }
-    }
-
-    if (command_buffer_length > 0)
-    {
-        /* Now we clear the line. */
-        write_all (mc_global.tty.subshell_pty, "\025", 1);
-        if (flush_subshell (1, VISIBLY) != 1)
-            return FALSE;
-    }
-
-    return TRUE;
-}
-
-/* --------------------------------------------------------------------------------------------- */
-
-static void
-clear_subshell_prompt_string (void)
-{
-    if (subshell_prompt_temp_buffer != NULL)
-        g_string_set_size (subshell_prompt_temp_buffer, 0);
-}
-
-/* --------------------------------------------------------------------------------------------- */
-
-static void
-parse_subshell_prompt_string (const char *buffer, int bytes)
-{
-    int i;
-
-    if (mc_global.mc_run_mode != MC_RUN_FULL)
-        return;
-
-    /* First time through */
-    if (subshell_prompt == NULL)
-        subshell_prompt = g_string_sized_new (INITIAL_PROMPT_SIZE);
-    if (subshell_prompt_temp_buffer == NULL)
-        subshell_prompt_temp_buffer = g_string_sized_new (INITIAL_PROMPT_SIZE);
-
-    /* Extract the prompt from the shell output */
-    for (i = 0; i < bytes; i++)
-        if (buffer[i] == '\n' || buffer[i] == '\r')
-            g_string_set_size (subshell_prompt_temp_buffer, 0);
-        else if (buffer[i] != '\0')
-            g_string_append_c (subshell_prompt_temp_buffer, buffer[i]);
-}
-
-/* --------------------------------------------------------------------------------------------- */
-
-static void
-set_prompt_string (void)
-{
-    if (mc_global.mc_run_mode != MC_RUN_FULL)
-        return;
-
-    if (subshell_prompt_temp_buffer->len != 0)
-        g_string_assign (subshell_prompt, subshell_prompt_temp_buffer->str);
-
-    setup_cmdline ();
-}
-
-/* --------------------------------------------------------------------------------------------- */
 /** Feed the subshell our keyboard input until it says it's finished */
 
 static gboolean
@@ -741,9 +481,6 @@
     struct timeval wtime;       /* Maximum time we wait for the subshell */
     struct timeval *wptr;
 
-    should_read_new_subshell_prompt = FALSE;
-    subshell_should_clear_command_line = FALSE;
-
     /* we wait up to 10 seconds if fail_on_error, forever otherwise */
     wtime.tv_sec = 10;
     wtime.tv_usec = 0;
@@ -812,9 +549,6 @@
 
             if (how == VISIBLY)
                 write_all (STDOUT_FILENO, pty_buffer, bytes);
-
-            if (should_read_new_subshell_prompt)
-                parse_subshell_prompt_string (pty_buffer, bytes);
         }
 
         else if (FD_ISSET (subshell_pipe[READ], &read_set))
@@ -829,12 +563,10 @@
                 exit (EXIT_FAILURE);
             }
 
-            subshell_cwd[bytes - 1] = '\0';     /* Squash the final '\n' */
+            subshell_cwd[bytes - 1] = 0;        /* Squash the final '\n' */
 
             synchronize ();
 
-            clear_subshell_prompt_string ();
-            should_read_new_subshell_prompt = TRUE;
             subshell_ready = TRUE;
             if (subshell_state == RUNNING_COMMAND)
             {
@@ -846,7 +578,6 @@
         else if (FD_ISSET (STDIN_FILENO, &read_set))
             /* Read from stdin, write to the subshell */
         {
-            should_read_new_subshell_prompt = FALSE;
             bytes = read (STDIN_FILENO, pty_buffer, sizeof (pty_buffer));
             if (bytes <= 0)
             {
@@ -860,33 +591,15 @@
                 if (pty_buffer[i] == subshell_switch_key)
                 {
                     write_all (mc_global.tty.subshell_pty, pty_buffer, i);
-
                     if (subshell_ready)
-                    {
                         subshell_state = INACTIVE;
-                        set_prompt_string ();
-                        if (subshell_ready && !read_command_line_buffer (FALSE))
-                        {
-                            /* If we got here, some unforseen error must have occurred. */
-                            flush_subshell (0, VISIBLY);
-                            input_assign_text (cmdline, "");
-                            subshell_should_clear_command_line = TRUE;
-                        }
-                    }
-
                     return TRUE;
                 }
 
             write_all (mc_global.tty.subshell_pty, pty_buffer, bytes);
 
             if (pty_buffer[bytes - 1] == '\n' || pty_buffer[bytes - 1] == '\r')
-            {
-                /* We should only clear the command line if we are using a shell that works
-                 * with persistent command buffer, otherwise we get awkward results. */
-                if (use_persistent_buffer)
-                    input_assign_text (cmdline, "");
                 subshell_ready = FALSE;
-            }
         }
         else
             return FALSE;
@@ -1071,13 +784,8 @@
     {
     case SHELL_BASH:
         g_snprintf (precmd, buff_size,
-                    " mc_print_command_buffer () { printf \"%%s\\\\n\" \"$READLINE_LINE\" >&%d; }\n"
-                    " bind -x '\"\\e" SHELL_BUFFER_KEYBINDING "\":\"mc_print_command_buffer\"'\n"
-                    " bind -x '\"\\e" SHELL_CURSOR_KEYBINDING
-                    "\":\"echo $BASH_VERSINFO:$READLINE_POINT >&%d\"'\n"
                     " PROMPT_COMMAND=${PROMPT_COMMAND:+$PROMPT_COMMAND\n}'pwd>&%d;kill -STOP $$'\n"
-                    "PS1='\\u@\\h:\\w\\$ '\n", command_buffer_pipe[WRITE],
-                    command_buffer_pipe[WRITE], subshell_pipe[WRITE]);
+                    "PS1='\\u@\\h:\\w\\$ '\n", subshell_pipe[WRITE]);
         break;
 
     case SHELL_ASH_BUSYBOX:
@@ -1092,7 +800,7 @@
          *    "PS1='$(precmd)\\u@\\h:\\w\\$ '\n",
          *
          * C: This works if user calls "ash" command because in sub-subshell
-         *    PRECMD is undefined, thus evaluated to empty string - no damage done.
+         *    PRECMD is unfedined, thus evaluated to empty string - no damage done.
          *    Attention: BusyBox must be built with FEATURE_EDITING_FANCY_PROMPT to
          *    permit \u, \w, \h, \$ escape sequences. Unfortunately this cannot be guaranteed,
          *    especially on embedded systems where people try to save space, so let's use
@@ -1128,7 +836,7 @@
                     "else "
                     "[ \"${PWD##$HOME/}\" = \"$PWD\" ] && MC_PWD=\"$PWD\" || MC_PWD=\"~/${PWD##$HOME/}\"; "
                     "fi; "
-                    "echo \"$USER@$(hostname -s):$MC_PWD\"; "
+                    "echo \"$USER@$HOSTNAME:$MC_PWD\"; "
                     "pwd>&%d; "
                     "kill -STOP $$; "
                     "}; " "PRECMD=precmd; " "PS1='$($PRECMD)$ '\n", subshell_pipe[WRITE]);
@@ -1136,33 +844,25 @@
 
     case SHELL_ZSH:
         g_snprintf (precmd, buff_size,
-                    " mc_print_command_buffer () { printf \"%%s\\\\n\" \"$BUFFER\" >&%d; }\n"
-                    " zle -N mc_print_command_buffer\n"
-                    " bindkey '^[" SHELL_BUFFER_KEYBINDING "' mc_print_command_buffer\n"
-                    " mc_print_cursor_position () { echo $CURSOR >&%d}\n"
-                    " zle -N mc_print_cursor_position\n"
-                    " bindkey '^[" SHELL_CURSOR_KEYBINDING "' mc_print_cursor_position\n"
                     " _mc_precmd(){ pwd>&%d;kill -STOP $$ }; precmd_functions+=(_mc_precmd)\n"
-                    "PS1='%%n@%%m:%%~%%# '\n",
-                    command_buffer_pipe[WRITE], command_buffer_pipe[WRITE], subshell_pipe[WRITE]);
+                    "PS1='%%n@%%m:%%~%%# '\n", subshell_pipe[WRITE]);
         break;
 
     case SHELL_TCSH:
         g_snprintf (precmd, buff_size,
                     "set echo_style=both; "
                     "set prompt='%%n@%%m:%%~%%# '; "
-                    "alias precmd 'echo -n;echo $cwd:q >>%s; kill -STOP $$'\n", tcsh_fifo);
+                    "alias precmd 'echo $cwd:q >>%s; kill -STOP $$'\n", tcsh_fifo);
         break;
+
     case SHELL_FISH:
         g_snprintf (precmd, buff_size,
-                    " bind \\e" SHELL_BUFFER_KEYBINDING " 'commandline >&%d';"
-                    "bind \\e" SHELL_CURSOR_KEYBINDING " 'commandline -C >&%d';"
-                    "if not functions -q fish_prompt_mc;"
+                    " if not functions -q fish_prompt_mc;"
                     "functions -e fish_right_prompt;"
                     "functions -c fish_prompt fish_prompt_mc; end;"
                     "function fish_prompt;"
                     "echo \"$PWD\">&%d; fish_prompt_mc; kill -STOP %%self; end\n",
-                    command_buffer_pipe[WRITE], command_buffer_pipe[WRITE], subshell_pipe[WRITE]);
+                    subshell_pipe[WRITE]);
         break;
 
     default:
@@ -1334,18 +1034,7 @@
                 return;
             }
         }
-        else if (pipe (subshell_pipe) != 0)     /* subshell_type is BASH, ASH_BUSYBOX, DASH or ZSH */
-        {
-            perror (__FILE__ ": couldn't create pipe");
-            mc_global.tty.use_subshell = FALSE;
-            return;
-        }
-
-        if (mc_global.mc_run_mode == MC_RUN_FULL &&
-            (mc_global.shell->type == SHELL_BASH || mc_global.shell->type == SHELL_ZSH
-             || mc_global.shell->type == SHELL_FISH))
-            use_persistent_buffer = TRUE;
-        if (use_persistent_buffer && pipe (command_buffer_pipe) != 0)
+        else if (pipe (subshell_pipe))  /* subshell_type is BASH, ASH_BUSYBOX, DASH or ZSH */
         {
             perror (__FILE__ ": couldn't create pipe");
             mc_global.tty.use_subshell = FALSE;
@@ -1382,17 +1071,12 @@
     subshell_state = RUNNING_COMMAND;
     tty_enable_interrupt_key ();
     if (!feed_subshell (QUIETLY, TRUE))
+    {
         mc_global.tty.use_subshell = FALSE;
+    }
     tty_disable_interrupt_key ();
     if (!subshell_alive)
         mc_global.tty.use_subshell = FALSE;     /* Subshell died instantly, so don't use it */
-
-    /* Try out the persistent command buffer feature. If it doesn't work the first time, we
-     * assume there must be something wrong with the shell, and we turn persistent buffer off
-     * for good. This will save the user the trouble of having to wait for the persistent
-     * buffer function to time out every time they try to close the subshell. */
-    if (use_persistent_buffer && !read_command_line_buffer (TRUE))
-        use_persistent_buffer = FALSE;
 }
 
 /* --------------------------------------------------------------------------------------------- */
@@ -1416,45 +1100,10 @@
             /* FIXME: possibly take out this hack; the user can re-play it by hitting C-hyphen a few times! */
             if (subshell_ready && mc_global.mc_run_mode == MC_RUN_FULL)
                 write_all (mc_global.tty.subshell_pty, " \b", 2);       /* Hack to make prompt reappear */
-
-            if (use_persistent_buffer)
-            {
-                size_t i;
-                int pos;
-
-                /* Check to make sure there are no non text characters in the command buffer,
-                 * such as tab, or newline, as this could cause problems. */
-                for (i = 0; cmdline->buffer[i] != '\0'; i++)
-                    if ((unsigned char) cmdline->buffer[i] < 32
-                        || (unsigned char) cmdline->buffer[i] == 127)
-                        cmdline->buffer[i] = ' ';
-
-                /* Write the command buffer to the subshell. */
-                write_all (mc_global.tty.subshell_pty, cmdline->buffer, strlen (cmdline->buffer));
-
-                /* Put the cursor in the correct place in the subshell. */
-                pos = str_length (cmdline->buffer) - cmdline->point;
-                for (i = 0; i < (size_t) pos; i++)
-                    write_all (mc_global.tty.subshell_pty, ESC_STR "[D", 3);
-            }
         }
     }
     else                        /* MC has passed us a user command */
     {
-        /* Before we write to the command prompt, we need to clear whatever */
-        /* data is there, but only if we are using one of the shells that */
-        /* doesn't support keeping command buffer contents, OR if there was */
-        /* some sort of error. */
-        if (!use_persistent_buffer || subshell_should_clear_command_line)
-        {
-            write_all (mc_global.tty.subshell_pty, "\003", 1);
-            subshell_state = RUNNING_COMMAND;
-            /* We need to call feed_subshell here if we are using fish, because of a quirk
-             * in the behavioral of that particular shell. */
-            if (mc_global.shell->type != SHELL_FISH)
-                feed_subshell (QUIETLY, FALSE);
-        }
-
         if (how == QUIETLY)
             write_all (mc_global.tty.subshell_pty, " ", 1);
         /* FIXME: if command is long (>8KB ?) we go comma */
@@ -1482,50 +1131,6 @@
     return subshell_get_mainloop_quit ();
 }
 
-/* --------------------------------------------------------------------------------------------- */
-
-gboolean
-flush_subshell (int max_wait_length, int how)
-{
-    int rc = 0;
-    ssize_t bytes = 0;
-    struct timeval timeleft = { 0, 0 };
-    gboolean return_value = FALSE;
-    fd_set tmp;
-
-    timeleft.tv_sec = max_wait_length;
-    FD_ZERO (&tmp);
-    FD_SET (mc_global.tty.subshell_pty, &tmp);
-
-    while (subshell_alive
-           && (rc = select (mc_global.tty.subshell_pty + 1, &tmp, NULL, NULL, &timeleft)) != 0)
-    {
-        /* Check for 'select' errors */
-        if (rc == -1)
-        {
-            if (errno == EINTR)
-            {
-                if (tty_got_winch ())
-                    tty_change_screen_size ();
-
-                continue;
-            }
-
-            fprintf (stderr, "select (FD_SETSIZE, &tmp...): %s\r\n", unix_error_string (errno));
-            exit (EXIT_FAILURE);
-        }
-
-        return_value = TRUE;
-        timeleft.tv_sec = 0;
-        timeleft.tv_usec = 0;
-
-        bytes = read (mc_global.tty.subshell_pty, pty_buffer, sizeof (pty_buffer));
-        if (how == VISIBLY)
-            write_all (STDOUT_FILENO, pty_buffer, bytes);
-    }
-
-    return return_value;
-}
 
 /* --------------------------------------------------------------------------------------------- */
 
@@ -1535,16 +1140,24 @@
     int rc = 0;
     ssize_t bytes = 0;
     struct timeval timeleft = { 0, 0 };
-    gboolean should_reset_prompt = TRUE;
-    gboolean got_new_prompt = FALSE;
+    GString *p;
+    gboolean prompt_was_reset = FALSE;
 
     fd_set tmp;
     FD_ZERO (&tmp);
     FD_SET (mc_global.tty.subshell_pty, &tmp);
 
+    /* First time through */
+    if (subshell_prompt == NULL)
+        subshell_prompt = g_string_sized_new (INITIAL_PROMPT_SIZE);
+
+    p = g_string_sized_new (INITIAL_PROMPT_SIZE);
+
     while (subshell_alive
            && (rc = select (mc_global.tty.subshell_pty + 1, &tmp, NULL, NULL, &timeleft)) != 0)
     {
+        ssize_t i;
+
         /* Check for 'select' errors */
         if (rc == -1)
         {
@@ -1561,18 +1174,22 @@
         }
 
         bytes = read (mc_global.tty.subshell_pty, pty_buffer, sizeof (pty_buffer));
-        if (should_reset_prompt)
-        {
-            should_reset_prompt = FALSE;
-            clear_subshell_prompt_string ();
-        }
 
-        parse_subshell_prompt_string (pty_buffer, bytes);
-        got_new_prompt = TRUE;
+        /* Extract the prompt from the shell output */
+        for (i = 0; i < bytes; i++)
+            if (pty_buffer[i] == '\n' || pty_buffer[i] == '\r')
+            {
+                g_string_set_size (p, 0);
+                prompt_was_reset = TRUE;
+            }
+            else if (pty_buffer[i] != '\0')
+                g_string_append_c (p, pty_buffer[i]);
     }
 
-    if (got_new_prompt)
-        set_prompt_string ();
+    if (p->len != 0 || prompt_was_reset)
+        g_string_assign (subshell_prompt, p->str);
+
+    g_string_free (p, TRUE);
 
     return (rc != 0 || bytes != 0);
 }
@@ -1584,11 +1201,8 @@
 {
     if (update_subshell_prompt)
     {
-        if (subshell_prompt != NULL)
-        {
-            printf ("\r\n%s", subshell_prompt->str);
-            fflush (stdout);
-        }
+        printf ("\r\n%s", subshell_prompt->str);
+        fflush (stdout);
         update_subshell_prompt = FALSE;
     }
 }
@@ -1615,18 +1229,8 @@
                          tcsh_fifo, unix_error_string (errno));
         }
 
-        if (subshell_prompt != NULL)
-        {
-            g_string_free (subshell_prompt, TRUE);
-            subshell_prompt = NULL;
-        }
-
-        if (subshell_prompt_temp_buffer != NULL)
-        {
-            g_string_free (subshell_prompt_temp_buffer, TRUE);
-            subshell_prompt_temp_buffer = NULL;
-        }
-
+        g_string_free (subshell_prompt, TRUE);
+        subshell_prompt = NULL;
         pty_buffer[0] = '\0';
     }
 
@@ -1655,15 +1259,6 @@
         return;
     }
 
-    /* If we are using a shell that doesn't support persistent command buffer, we need to clear
-     * the command prompt before we send the cd command. */
-    if (!use_persistent_buffer || subshell_should_clear_command_line)
-    {
-        write_all (mc_global.tty.subshell_pty, "\003", 1);
-        subshell_state = RUNNING_COMMAND;
-        if (mc_global.shell->type != SHELL_FISH)
-            feed_subshell (QUIETLY, FALSE);
-    }
     /* The initial space keeps this out of the command history (in bash
        because we set "HISTCONTROL=ignorespace") */
     write_all (mc_global.tty.subshell_pty, " cd ", 4);
diff -Naur mc-4.8.26.orig/src/subshell/Makefile.in mc-4.8.26/src/subshell/Makefile.in
--- mc-4.8.26.orig/src/subshell/Makefile.in	2021-01-21 20:14:05.000000000 +0300
+++ mc-4.8.26/src/subshell/Makefile.in	2021-03-26 18:54:01.940213716 +0300
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.16.2 from Makefile.am.
+# Makefile.in generated by automake 1.15.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+# Copyright (C) 1994-2017 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -90,15 +90,10 @@
 host_triplet = @host@
 subdir = src/subshell
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/m4/gettext.m4 \
-	$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/intlmacosx.m4 \
-	$(top_srcdir)/m4/lib-ld.m4 $(top_srcdir)/m4/lib-link.m4 \
-	$(top_srcdir)/m4/lib-prefix.m4 $(top_srcdir)/m4/libtool.m4 \
+am__aclocal_m4_deps = $(top_srcdir)/m4/libtool.m4 \
 	$(top_srcdir)/m4/longlong.m4 $(top_srcdir)/m4/ltoptions.m4 \
 	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
-	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/progtest.m4 \
-	$(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \
 	$(top_srcdir)/m4.include/gnulib/mode_t.m4 \
 	$(top_srcdir)/m4.include/gnulib/stat-size.m4 \
 	$(top_srcdir)/m4.include/gnulib/fstypename.m4 \
@@ -168,8 +163,7 @@
 am__v_at_1 = 
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/config/depcomp
-am__maybe_remake_depfiles = depfiles
-am__depfiles_remade = ./$(DEPDIR)/common.Plo ./$(DEPDIR)/proxyfunc.Plo
+am__depfiles_maybe = depfiles
 am__mv = mv -f
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
@@ -311,7 +305,6 @@
 LTLIBICONV = @LTLIBICONV@
 LTLIBINTL = @LTLIBINTL@
 LTLIBOBJS = @LTLIBOBJS@
-LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
 MAINT = @MAINT@
 MAKEINFO = @MAKEINFO@
 MANDOC = @MANDOC@
@@ -321,8 +314,8 @@
 MCLIBS = @MCLIBS@
 MKDIR_P = @MKDIR_P@
 MSGFMT = @MSGFMT@
-MSGFMT_015 = @MSGFMT_015@
 MSGMERGE = @MSGMERGE@
+MSGMERGE_FOR_MSGFMT_OPTION = @MSGMERGE_FOR_MSGFMT_OPTION@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
@@ -450,8 +443,8 @@
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
 	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
 	esac;
 
 $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
@@ -483,14 +476,8 @@
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/common.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proxyfunc.Plo@am__quote@ # am--include-marker
-
-$(am__depfiles_remade):
-	@$(MKDIR_P) $(@D)
-	@echo '# dummy' >$@-t && $(am__mv) $@-t $@
-
-am--depfiles: $(am__depfiles_remade)
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proxyfunc.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -571,10 +558,7 @@
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
-distdir: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) distdir-am
-
-distdir-am: $(DISTFILES)
+distdir: $(DISTFILES)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
 	list='$(DISTFILES)'; \
@@ -644,8 +628,7 @@
 	mostlyclean-am
 
 distclean: distclean-am
-		-rm -f ./$(DEPDIR)/common.Plo
-	-rm -f ./$(DEPDIR)/proxyfunc.Plo
+	-rm -rf ./$(DEPDIR)
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
@@ -691,8 +674,7 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-		-rm -f ./$(DEPDIR)/common.Plo
-	-rm -f ./$(DEPDIR)/proxyfunc.Plo
+	-rm -rf ./$(DEPDIR)
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -713,16 +695,16 @@
 
 .MAKE: install-am install-strip
 
-.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \
-	clean-generic clean-libtool clean-noinstLTLIBRARIES \
-	cscopelist-am ctags ctags-am distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
-	installcheck installcheck-am installdirs maintainer-clean \
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
 	tags tags-am uninstall uninstall-am
diff -Naur mc-4.8.26.orig/src/subshell/proxyfunc.c mc-4.8.26/src/subshell/proxyfunc.c
--- mc-4.8.26.orig/src/subshell/proxyfunc.c	2021-01-10 14:50:16.000000000 +0300
+++ mc-4.8.26/src/subshell/proxyfunc.c	2021-03-26 19:04:26.504213716 +0300
@@ -34,7 +34,7 @@
 #include "lib/vfs/vfs.h"        /* vfs_get_raw_current_dir() */
 
 #include "src/setup.h"          /* quit */
-#include "src/filemanager/filemanager.h"        /* current_panel */
+#include "src/filemanager/filemanager.h"   /* current_panel */
 #include "src/consaver/cons.saver.h"    /* handle_console() */
 
 #include "internal.h"
diff -Naur mc-4.8.26.orig/src/subshell/subshell.h mc-4.8.26/src/subshell/subshell.h
--- mc-4.8.26.orig/src/subshell/subshell.h	2021-01-10 14:50:16.000000000 +0300
+++ mc-4.8.26/src/subshell/subshell.h	2020-01-01 18:52:34.000000000 +0300
@@ -36,13 +36,10 @@
 
 extern gboolean update_subshell_prompt;
 
-extern gboolean should_read_new_subshell_prompt;
-
 /*** declarations of public functions ************************************************************/
 
 void init_subshell (void);
 int invoke_subshell (const char *command, int how, vfs_path_t ** new_dir);
-gboolean flush_subshell (int max_wait_length, int how);
 gboolean read_subshell_prompt (void);
 void do_update_prompt (void);
 gboolean exit_subshell (void);
